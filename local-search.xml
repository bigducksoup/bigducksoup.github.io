<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>高性能网络模式-Reactor</title>
    <link href="/2023/10/13/reactor/"/>
    <url>/2023/10/13/reactor/</url>
    
    <content type="html"><![CDATA[<h1 id="Reactor-模式详解"><a href="#Reactor-模式详解" class="headerlink" title="Reactor 模式详解"></a>Reactor 模式详解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文章知识需要对BIO，NIO，AIO，以及IO多路复用（select，poll，epoll，kqueue）等技术有一定的了解与认识。</p><h2 id="什么是Reactor"><a href="#什么是Reactor" class="headerlink" title="什么是Reactor"></a>什么是Reactor</h2><p>Reactor 模式又叫反应堆模式，是一种常见的高性能的服务器开发模式，它是基于事件驱动的，并且使用了IO多路复用技术。</p><p>Reactor 模式的核心思想是将并发性与异步事件处理相结合，通过事件驱动的方式处理输入和输出，以提供高效的事件分发和处理能力。它广泛应用于构建网络服务器、消息传递系统和其他需要处理大量并发请求的应用程序。</p><h2 id="深入理解Reactor"><a href="#深入理解Reactor" class="headerlink" title="深入理解Reactor"></a>深入理解Reactor</h2><p><strong>Reactor 模式</strong>分为 <strong>reactor</strong>和<strong>处理资源池</strong>组成，reactor 只负责监听以及分发事件，它将事件分发给处理资源池进行处理。</p><p><strong>Reactor模式</strong>中有以下三种角色：</p><ul><li><strong>Reactor</strong> 将I&#x2F;O事件分派给对应的Handler</li><li><strong>Acceptor</strong> 处理客户端新连接，并分派请求到处理器链中</li><li><strong>Handlers</strong> 执行非阻塞读&#x2F;写 任务</li></ul><h3 id="基于事件驱动"><a href="#基于事件驱动" class="headerlink" title="基于事件驱动"></a><strong>基于事件驱动</strong></h3><p><strong>reactor</strong> 对事件进行反应，它通过IO多路复用监听事件，收到事件后，根据事件的类型分配给<strong>处理资源池</strong>处理。</p><p><strong>reactor</strong>接收到的事件包括连接事件，读写事件。这两种事件分别被分配给<strong>Acceptor</strong>和<strong>Handler</strong>处理。</p><p>我们以<strong>单reactor单线程</strong>为例</p><p><img src="/../img/reactor/single-reactor-single-thread.png" alt="单reactor单线程"></p><p>上图既展现了reactor模式的基本思想。</p><p>reactor 通过IO多路复用监听事件，并根据事件类型通过dispatch进行分发。</p><p>对于连接建立事件，acceptor会使用accept方法接受连接，并创建hanlder对象，处理后续事件。</p><p>对于读写事件，交给连接对应的handler进行处理。</p><p>单 Reactor 单进程的方案<strong>不适用计算机密集型的场景，只适用于业务处理非常快速的场景</strong>。</p><p>在Redis 6.0版本之前，正是使用的单reactor单进程 Reactor模式。</p><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>单reactor单线程方案存在 2 个缺点：</p><ul><li>第一个缺点，因为只有一个线程，<strong>无法充分利用 多核 CPU 的性能</strong>；</li><li>第二个缺点，Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，<strong>如果业务处理耗时比较长，那么就造成响应的延迟</strong>；</li></ul><p>所以Reactor还有多线程实现方式。</p><ul><li>单 reactor 多线程 &#x2F; 进程；</li><li>多 reactor 多进程 &#x2F; 线程；</li></ul><h4 id="单-reactor-多线程"><a href="#单-reactor-多线程" class="headerlink" title="单 reactor 多线程"></a>单 reactor 多线程</h4><p>本方案将Handler对象的业务处理操作交由子线程的Processor执行，而Handler本身只负责数据收发工作。</p><p><img src="/../img/reactor/single-reactor-multi-thread.png" alt="单reactor，多线程"></p><p>reactor对象通过IO多路复用技术监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；</p><p>如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；</p><p>如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；</p><p>Handler对象只负责数据收发，它read到数据后交由子线程的Processor对数据进行处理；</p><p>子线程的Processor处理完后，将结果发送给主线程的Handler对象；</p><p>Handler对象将处理的数据进行send；</p><p>单 Reator 多线程的方案优势在于<strong>能够充分利用多核 CPU 的能</strong>，那既然引入多线程，那么自然就带来了多线程竞争资源的问题。</p><p>例如，子线程完成业务处理后，要把结果传递给主线程的 Handler 进行发送，这里涉及共享数据的竞争。</p><p>要避免多线程由于竞争共享资源而导致数据错乱的问题，就需要在操作共享资源前加上互斥锁，以保证任意时间里只有一个线程在操作共享资源，待该线程操作完释放互斥锁后，其他线程才有机会操作共享数据。</p><h4 id="多reactor-多线程"><a href="#多reactor-多线程" class="headerlink" title="多reactor 多线程"></a>多reactor 多线程</h4><p><strong>因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方</strong>。所以产生了<strong>多 Reactor 多进程 &#x2F; 线程</strong>的方案。</p><p><img src="/../img/reactor/multi-reactor-multi-thread.png" alt="多reactor 多线程"></p><p>主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept 获取连接，将新的连接分配给某个子线程；</p><p>子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 select 继续进行监听，并创建一个 Handler 用于处理连接的响应事件。</p><p>如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。</p><p>Handler 对象通过 read -&gt; 业务处理 -&gt; send 的流程来完成完整的业务流程。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>视频网站后端架构</title>
    <link href="/2023/09/18/my-bilibili/"/>
    <url>/2023/09/18/my-bilibili/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>直播服务架构设计</title>
    <link href="/2023/09/17/live-server/"/>
    <url>/2023/09/17/live-server/</url>
    
    <content type="html"><![CDATA[<h1 id="直播服务架构设计"><a href="#直播服务架构设计" class="headerlink" title="直播服务架构设计"></a>直播服务架构设计</h1><p>设计直播服务架构时，有几个关键方面需要考虑，包括视频流处理、实时通信、负载均衡和可扩展性。</p><h2 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="1.需求分析"></a>1.需求分析</h2><ol><li><p>直播服务需要一种可以实时传输视频流的协议，主播端向服务器发送视频流，观众端从服务器拉取流进行播放。</p></li><li><p>向服务器的推流需要支持权限验证，检查推流方的身份。</p></li><li><p>管理员支持对直播的强制结束，对房间的封禁。</p></li><li><p>服务器支持扩展，并且根据服务器的不同配置，需要选择合适的负载均衡策略。</p></li><li><p>直播服务器处于拉流多推流少的状态，需要支持拉流与推流的分离。</p></li><li><p>直播支持多种清晰度的选择，以适应观众端的网络情况。</p></li><li><p>（可选）对直播的回放进行保存。</p></li><li><p>集成消息服务，包括但不限于：用户弹幕，礼物消息，房间进入与退出，直播状态。</p></li><li><p>直播数据与信息统计，包括但不限于：直播人数统计，点赞数，房间基本信息</p></li></ol><h2 id="2-技术选型"><a href="#2-技术选型" class="headerlink" title="2.技术选型"></a>2.技术选型</h2><h4 id="RTMP协议"><a href="#RTMP协议" class="headerlink" title="RTMP协议"></a>RTMP协议</h4><p>RTMP（Real Time Messaging Protocol） 是由 Adobe 公司基于 Flash Player 播放器对应的音视频 flv 封装格式提出的一种，基于TCP 的数据传输协议。本身具有稳定、兼容性强、高穿透的特点。常被应用于流媒体直播、点播等场景。常用于推推流方（主播）的稳定传输需求。</p><h4 id="nginx-rtmp-module"><a href="#nginx-rtmp-module" class="headerlink" title="nginx-rtmp-module"></a>nginx-rtmp-module</h4><p>一款强大的NGINX 的流媒体插件，拥有诸多强大的功能</p><h5 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h5><ul><li>RTMP&#x2F;HLS&#x2F;MPEG-DASH live streaming          常见协议直播</li><li>RTMP Video on demand FLV&#x2F;MP4, playing from local filesystem or HTTP    RTMP视频点播FLV&#x2F;MP4</li><li>Stream relay support for distributed streaming: push &amp; pull models  </li><li>Recording streams in multiple FLVs                直播流记录</li><li>H264&#x2F;AAC support                                             支持H.264&#x2F;ACC 视频音频编码</li><li>Online transcoding with FFmpeg                     支持调用FFmpeg在线转码</li><li>HTTP callbacks (publish&#x2F;play&#x2F;record&#x2F;update etc)            多种回调</li><li>Running external programs on certain events (exec)      支持exec调用其他命令</li><li>HTTP control module for recording audio&#x2F;video and dropping clients       基于http的直播权限控制</li><li>Advanced buffering techniques to keep memory allocations at a minimum level for faster streaming and low memory footprint              buffer优化</li><li>Proved to work with Wirecast, FMS, Wowza, JWPlayer, FlowPlayer, StrobeMediaPlayback, ffmpeg, avconv, rtmpdump, flvstreamer and many more        </li><li>Statistics in XML&#x2F;XSL in machine- &amp; human- readable form</li><li>Linux&#x2F;FreeBSD&#x2F;MacOS&#x2F;Windows     多平台支持</li></ul><p><a href="https://bigducksoup.github.io/2023/08/11/nginx-rtmp-module/">https://bigducksoup.github.io/2023/08/11/nginx-rtmp-module/</a></p><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><ul><li><code>WebSocket</code> 是一种<code>支持双向通讯</code>网络通信协议。</li><li>意思就是服务器可以<code>主动向客户端推送信息</code>，客户端也可以<code>主动向服务器发送信息</code></li><li>属于服务器推送技术的一种.</li></ul><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>（1）建立在<code> TCP 协议</code>之上，服务器端的实现比较容易。</p><p>（2）与 <code>HTTP 协议</code>有着良好的兼容性。默认端口也是80和443，并且<code>握手阶段</code>采用 HTTP 协议，因此握手时不容易屏蔽，<code>能通过各种 HTTP 代理服务器</code>。</p><p>（3）数据格式比较轻量，性能开销小，通信高效。</p><p>（4）可以发送<code>文本</code>，也可以发送<code>二进制数据</code>（<code>blob</code>对象或<code>Arraybuffer</code>对象）</p><p>（5）收到的数据类型 可以使用binaryType 指定， 显式指定收到的二进制数据类型</p><p>（6）没有<code>同源限制</code>，客户端可以与任意服务器通信。</p><p>（7）协议标识符是<code>ws（握手http）</code>（如果加密，则为<code>wss（tcp +TLS)</code>），服务器网址就是 URL。</p><h4 id="RabbitMQ（消息队列）"><a href="#RabbitMQ（消息队列）" class="headerlink" title="RabbitMQ（消息队列）"></a>RabbitMQ（消息队列）</h4><p>RabbitMQ是一个开源的消息代理和队列服务器，用来通过普通协议在不同的应用之间共享数据(跨平台跨语言)。RabbitMQ是使用Erlang语言编写，并且基于AMQP协议实现。</p><h2 id="3-直播服务架构设计"><a href="#3-直播服务架构设计" class="headerlink" title="3.直播服务架构设计"></a>3.直播服务架构设计</h2><h4 id="1-基本需求"><a href="#1-基本需求" class="headerlink" title="1.基本需求"></a>1.基本需求</h4><p>直播功能的核心是<strong>向服务器推送视频流</strong>和<strong>从服务器拉取视频流播放</strong> </p><p>通过Nginx-rtmp-module我们可以轻松实现这一功能</p><p><img src="/../img/live-server/simple.png" alt="简单示例"></p><h4 id="2-推流权限控制"><a href="#2-推流权限控制" class="headerlink" title="2.推流权限控制"></a>2.推流权限控制</h4><p>我们需要对 <strong>向nginx推流的请求</strong> 进行权限管理与身份的认证，以保证直播服务器不受恶意攻击。</p><p>对此，我们可以通过配置on_publish {url} 让请求必须通过nginx回调 {url} 且 {url}  **返回HTTP.OK(200)**时，才能进行推流。</p><p>对于这个问题以及之后的需求我们使用SpringBoot构建自己的直播服务模块。</p><p>其中on_publish自带的参数有：</p><ul><li>call&#x3D;play</li><li>addr - client IP address</li><li>clientid - nginx client id (displayed in log and stat)</li><li>app - application name</li><li>flashVer - client flash version</li><li>swfUrl - client swf url</li><li>tcUrl - tcUrl</li><li>pageUrl - client page url</li><li>name - stream name</li></ul><p>我们也可以在url中设置自定义参数，例如：rtmp:&#x2F;&#x2F;localhost&#x2F;app&#x2F;movie?a&#x3D;100&amp;b&#x3D;face&amp;foo&#x3D;bar</p><p><img src="/../img/live-server/on_publish.png" alt="on_publish"></p><p>此时我们注意到一些问题</p><ol><li>我们如何获取推流的地址，以及地址上我们应该携带什么参数</li><li>服务器如何验证我们的身份</li></ol><p>对于这两个问题，本质上是因为我们当前没有对推流方赋予一个身份，所以我们需要一套用户认证系统来进行推流方的身份验证。</p><p>同时当推流方拥有身份后，我们可以通过身份获取推流地址，并在服务端保存必要的信息，这样我们在回调on_publish时就可以通过传来的参数验证身份。</p><p>（因此架构为我的个人视频APP项目设计，所以在此处我已经拥有了一个用户认证服务）</p><p><img src="/../img/live-server/get-push-url.png" alt="get-push-url"></p><p>当然，我们对直播房间的一些信息与状态，也可以在on_publish内进行操作</p><h4 id="3-直播控制"><a href="#3-直播控制" class="headerlink" title="3.直播控制"></a>3.直播控制</h4><p>在上面推流的过程中，on_publish中携带了许多的默认参数，这些参数可以让我们对推流进行精准的控制</p><p>首先我们在nginx配置中配置rtmp_control all;</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs abnf">http &#123;<br>...<br>    server &#123;<br>        listen       <span class="hljs-number">8080</span><span class="hljs-comment">;</span><br>        server_name  localhost<span class="hljs-comment">;</span><br>        ....<br>        location /control &#123;<br>            rtmp_control all<span class="hljs-comment">;</span><br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h5><p><code>http://server.com/control/record/start|stop?srv=SRV&amp;app=APP&amp;name=NAME&amp;rec=REC</code></p><ul><li>srv&#x3D;SRV - optional server{} block number within rtmp{} block, default to first server{} block  </li><li>app&#x3D;APP - required application name</li><li>name&#x3D;NAME - required stream name</li><li>rec&#x3D;REC - optional recorder name, defaults to root (unnamed) recorder</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">rtmp</span> &#123;<br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">1935</span>;<br>        <span class="hljs-attribute">application</span> myapp &#123;<br>            <span class="hljs-attribute">live</span> <span class="hljs-literal">on</span>;<br>            <span class="hljs-attribute">recorder</span> rec1 &#123;<br>               <span class="hljs-attribute">record</span> all manual;<br>               <span class="hljs-attribute">record_suffix</span> all.flv;<br>               <span class="hljs-attribute">record_path</span> /tmp/rec;<br>               <span class="hljs-attribute">record_unique</span> <span class="hljs-literal">on</span>;<br>           &#125;<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>推流</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ffmpeg -i http:<span class="hljs-regexp">//</span>someserver.com<span class="hljs-regexp">/mychannel.ts -c:v copy -c:a nellymoser -ar 44100 -ac 1 -f flv rtmp:/</span><span class="hljs-regexp">/localhost/my</span>app/mystream<br></code></pre></td></tr></table></figure><p>开始与结束录制</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">curl</span> <span class="hljs-string">&quot;http://localhost:8080/control/record/start?app=myapp&amp;name=mystream&amp;rec=rec1&quot;</span><br><span class="hljs-built_in">curl</span> <span class="hljs-string">&quot;http://localhost:8080/control/record/stop?app=myapp&amp;name=mystream&amp;rec=rec1&quot;</span><br></code></pre></td></tr></table></figure><h5 id="强制断开-drop"><a href="#强制断开-drop" class="headerlink" title="强制断开(drop)"></a>强制断开(drop)</h5><p><code>http://server.com/control/drop/publisher|subscriber|client? srv=SRV&amp;app=APP&amp;name=NAME&amp;addr=ADDR&amp;clientid=CLIENTID</code></p><ul><li>srv, app, name - the same as above. </li><li>addr - optional client address (the same as returned by rtmp_stat)</li><li>clientid - optional nginx client id (displayed in log and stat)</li></ul><p>The first method <code>drop/publisher</code> drops publisher connection. The second <code>drop/client</code> drops every connection matching <code>addr</code> argument or all clients (including publisher) if <code>addr</code> is not specified.</p><p>drop&#x2F;publisher会让nginx断开与后面参数对应的推流方的连接</p><p>drop&#x2F;client会让匹配addr参数的所以连接关闭（包括推流与拉流的所有客户端）</p><h5 id="以超管关闭直播为例"><a href="#以超管关闭直播为例" class="headerlink" title="以超管关闭直播为例"></a>以超管关闭直播为例</h5><p><img src="/../img/live-server/kick.png" alt="kick publisher"></p><h4 id="4-不同清晰度"><a href="#4-不同清晰度" class="headerlink" title="4.不同清晰度"></a>4.不同清晰度</h4><p>在nginx-rtmp-module中我们可以通过exec调用指令，在系统安装了FFmpeg的情况下，可以通过调用FFmpeg生成不同清晰度的流并push到其他地址</p><h5 id="exec-push-exec"><a href="#exec-push-exec" class="headerlink" title="exec_push(exec)"></a>exec_push(exec)</h5><p>Syntax: <code>exec_push command arg*</code><br>Context: rtmp, server, application</p><p>Specifies external command with arguments to be executed on every stream published. When publishing stops the process is terminated. Full path to binary should be specified as the first argument. There are no assumptions about what this process should do. However this feature is useful with ffmpeg for stream transcoding. FFmpeg is supposed to connect to nginx-rtmp as a client and output transcoded stream back to nginx-rtmp as publisher. Substitutions of form &#x2F;{var} can be used within command line:</p><ul><li>$name - stream name</li><li>$app - application name</li><li>$addr - client address</li><li>$flashver - client flash version</li><li>$swfurl - client swf url</li><li>$tcurl - client tc url</li><li>$pageurl - client page url</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">rtmp</span> &#123;<br>    <span class="hljs-section">server</span> &#123;<br>            <span class="hljs-attribute">listen</span> <span class="hljs-number">1935</span>;<br>            <span class="hljs-attribute">chunk_size</span> <span class="hljs-number">4096</span>;<br><br>            <span class="hljs-attribute">application</span> live &#123;<br>                    <span class="hljs-attribute">live</span> <span class="hljs-literal">on</span>;<br>                    <span class="hljs-attribute">record</span> <span class="hljs-literal">off</span>;<br>       　　　　　　　　<span class="hljs-attribute">exec</span> ffmpeg -i rtmp://localhost/live/<span class="hljs-variable">$name</span> -threads <span class="hljs-number">1</span> -c:v libx264 -profile:v baseline -b:v <span class="hljs-number">350K</span> -s 640x360 -f flv -c:a aac -ac <span class="hljs-number">1</span> -strict -<span class="hljs-number">2</span> -b:a <span class="hljs-number">56k</span> rtmp://localhost/live360p/<span class="hljs-variable">$name</span>;<br>            &#125;<br>            <span class="hljs-attribute">application</span> live360p &#123;<br>                    <span class="hljs-attribute">live</span> <span class="hljs-literal">on</span>;<br>                    <span class="hljs-attribute">record</span> <span class="hljs-literal">off</span>;<br>                    <span class="hljs-attribute">allow</span> publish <span class="hljs-number">127.0.0.1</span>;<br>                    <span class="hljs-attribute">allow</span> publish <span class="hljs-number">0.0.0.0</span>;<br>                    <span class="hljs-attribute">deny</span> publish all;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上面的配置为例，这样观众端就需要从新的地址拉流，而不是和推流地址相同，我们可以将转换分辨率后的推流地址设置为其他服务器的地址，并且其他服务器也可以配置**push {url}**在向其他服务器推流。</p><p>这样我们就可以实现推拉流的分离，观众播放时，为其选择返回对应地址即可。</p><p>而且push命令可以二次推流，这样我们可以为服务器设置不同数量的push，这样我们就可以根据直播间人气的大小，让流传播不同次数，人气越大，我们可以选择传播数多的服务器，支撑观众数量带来的压力。</p><p><img src="/../img/live-server/re-push.png" alt="re-push"></p><h4 id="5-推流架构"><a href="#5-推流架构" class="headerlink" title="5.推流架构"></a>5.推流架构</h4><p>经过了上一部分的分析后，我们就明确了一个推拉分离的高可用架构</p><p>我们将其与之前的权限验证与控制部分相结合,设计我们的推流架构</p><p><img src="/../img/live-server/push-structure.png" alt="推流架构"></p><h4 id="6-播放流程"><a href="#6-播放流程" class="headerlink" title="6.播放流程"></a>6.播放流程</h4><p>有了以上架构的设计，我们在拉取视频流时，对nginx集群做负载均衡即可。</p><p><img src="/../img/live-server/pull.png" alt="pull stream"></p><p>如果我们希望对观众端进行控制，nginx-rtmp-module也为我们提供了对应的回调接口。</p><p>使用方法类似on_publish</p><h5 id="on-play"><a href="#on-play" class="headerlink" title="on_play"></a>on_play</h5><p>Syntax: <code>on_play url</code><br>Context: rtmp, server, application</p><p>Sets HTTP play callback. Each time a clients issues play command an HTTP request is issued asynchronously and command processing is suspended until it returns result code. HTTP result code is then analyzed.</p><ul><li>HTTP 2xx code continues RTMP session</li><li>HTTP 3xx redirects RTMP to another stream whose name is taken from <code>Location</code> HTTP response header. If new stream name is started with <code>rtmp://</code> then remote relay is created instead. Relays require that IP address is specified instead of domain name and only work with nginx versions greater than 1.3.10. See also <code>notify_relay_redirect</code>.</li><li>Otherwise RTMP connection is dropped</li></ul><p>HTTP request receives a number of arguments. POST method is used with application&#x2F;x-www-form-urlencoded MIME type. The following arguments are passed to caller:</p><ul><li>call&#x3D;play</li><li>addr - client IP address</li><li>clientid - nginx client id (displayed in log and stat)</li><li>app - application name</li><li>flashVer - client flash version</li><li>swfUrl - client swf url</li><li>tcUrl - tcUrl</li><li>pageUrl - client page url</li><li>name - stream name</li></ul><p>In addition to the above mentioned items all arguments passed explicitly to play command are also sent with the callback. For example if stream is accessed with the url <code>rtmp://localhost/app/movie?a=100&amp;b=face&amp;foo=bar</code> then <code>a</code>, <code>b</code> &amp; <code>foo</code> are also sent with callback.</p><h2 id="4-消息服务架构设计"><a href="#4-消息服务架构设计" class="headerlink" title="4..消息服务架构设计"></a>4..消息服务架构设计</h2><p>在直播过程中，一个用户发送弹幕，消息，礼物等需要需要广播给整个直播间的用户，我们需要让每个用户与服务器端建立全双工通信，并且因为我们的服务端是微服务集群，一个直播间内的用户可能连接到不同机器的服务上，所以在用户向服务端发送消息时，服务端需要能将消息广播到其他服务端，其他服务端接收到消息后再返回给其他用户。</p><p>经以上分析，我们可以选用websocket，和消息队列实现这些功能。</p><p><img src="/../img/live-server/message.png" alt="message"></p><p>虽然服务使用concurrentHashMap存储了与之建立连接的用户的Session，让服务变成了‘’有状态的‘’，但是消息的流转可以经过MQ传达到每一个服务，我们依然可以通过简单的增加服务实例的方式，快速扩展服务集群。</p>]]></content>
    
    
    <categories>
      
      <category>architecture</category>
      
    </categories>
    
    
    <tags>
      
      <tag>design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySql中的MVCC（多版本并发控制）</title>
    <link href="/2023/09/09/mvcc/"/>
    <url>/2023/09/09/mvcc/</url>
    
    <content type="html"><![CDATA[<h1 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h1><p><code>MVCC</code>，全称<code>Multi-Version Concurrency Control</code>，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p><p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读</p><p>MySQL中的MVCC基于undo log版本链，和Read View实现。</p><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p><strong>什么是undo log？</strong></p><p>撤销日志，在数据库事务开始之前，MYSQL会去记录更新前的数据到undo log文件中。如果事务回滚或者数据库崩溃时，可以利用undo log日志中记录的日志信息进行回退。同时也可以提供多版本并发控制下的读(MVCC)。</p><p><strong>undo log的生命周期</strong></p><p>undo log产生： 在事务开始之前生成<br>undo log销毁： 当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。<br>注意： undo log也会生产redo log，undo log也要实现持久性保护。</p><h2 id="undo-log版本链"><a href="#undo-log版本链" class="headerlink" title="undo log版本链"></a>undo log版本链</h2><p>多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为<strong>版本链</strong>。</p><p><img src="/../img/mvcc/undolog-chain.png" alt="undolog-chain"></p><p>我们可以看到版本链中的每条记录有<strong>TRX_ID</strong>，和<strong>DB_ROLL_PTR</strong>两个重要的字段</p><p>其中 <strong>TRX_ID</strong> 代表着当前记录的事务ID。<strong>DB_ROLL_PTR</strong>指向了上一条undo log</p><p>每当一个事务修改了一条记录时，都会产生一条关于这个记录的undo log，并插入undo log版本链中，记录当前事务ID，并指向此条记录的上一条undolog</p><h2 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h2><p>什么是MySQL InnoDB下的当前读和快照读?</p><ul><li><p>当前读<br>像select lock in share mode(<code>共享锁</code>), select for update ; update, insert ,delete(<code>排他锁</code>)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁</p></li><li><p>快照读<br>像<code>不加锁</code>的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p><p>MVCC就是为了实现读-写冲突不加锁，而这个读指的就是<code>快照读</code>, 而非当前读，当前读实际上是一种加锁的操作，是悲观锁的实现</p></li></ul><h2 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h2><p><strong>Read View是什么呢？</strong> </p><p>它就是事务执行SQL语句时，产生的读视图。实际上在innodb中，每个SQL语句执行前都会得到一个Read View。</p><p><strong>Read View有什么用呢？</strong> </p><p>它主要是用来做可见性判断的，即判断当前事务可见哪个版本的数据~</p><p><strong>Read View拥有如下数据结构</strong></p><ul><li>m_ids:当前系统中那些活跃(未提交)的读写事务ID, 它数据结构为一个List。</li><li>min_limit_id:表示在生成Read View时，当前系统中活跃的读写事务中最小的事务id，即m_ids中的最小值。</li><li>max_limit_id:表示生成Read View时，系统中应该分配给下一个事务的id值。</li><li>creator_trx_id: 创建当前Read View的事务ID</li></ul><p><img src="/../img/mvcc/readview.png" alt="ReadView"></p><h2 id="版本链访问规则"><a href="#版本链访问规则" class="headerlink" title="版本链访问规则"></a>版本链访问规则</h2><ul><li>判断当前事务id等于creator_trx_id吗？成立说明数据就是自己这个事务更改的，可以访问</li><li>判断trx id&lt;min_trx_id？成立说明数据已经提交了，可以访问</li><li>判断trx id&gt;max_trx_id？成立说明该事务是在ReadView:生成以后才开启，不允许访问</li><li>判断min_trx_id&lt;&#x3D;trx_id&lt;&#x3D;max_trx_id, 成立在mids数据中对比，不存数据在的则代表数据是已提交的，可以访问。</li></ul><p>总结</p><p>1.自己的事务更改的可以读</p><p>2.已经提交的可以读</p><p>3.没有提交的不能读</p><p>Read View生成后会在undo log版本链中由新到旧按顺序寻找，对找到的第一个匹配的记录进行读取。</p><h2 id="在RC（Read-Commit）隔离级别下的Read-View生成"><a href="#在RC（Read-Commit）隔离级别下的Read-View生成" class="headerlink" title="在RC（Read Commit）隔离级别下的Read View生成"></a>在RC（Read Commit）隔离级别下的Read View生成</h2><p><img src="/../img/mvcc/rc-readview.png" alt="RCReadView"></p><p>在RC隔离级别下每次对数据的读取都会创建一个Read View</p><h3 id="在第一个Read-View生成时"><a href="#在第一个Read-View生成时" class="headerlink" title="在第一个Read View生成时"></a>在第一个Read View生成时</h3><p>事务A已提交，事务B，C，D未提交，所以mids为他们的对应的id {2,3,4}</p><p>最小活跃事务id min_trx_id 为 2</p><p>预分配事务id 为最大活跃事务id:4  +1  所以 max_trx_id 为 5</p><p>创建事务的id creator_trx_id 为 4</p><p><img src="/../img/mvcc/rc-readview-example-1.png" alt="RCReadViewExample01"></p><p>根据上面版本链访问规则</p><p>trx_id&#x3D;3的记录 其对应的事务未提交，不能读，找下一个。</p><p>trx_id&#x3D;2的记录 其对应的事务未提交，不能读，找下一个。</p><p>trx_id&#x3D;1的记录 其对应的事务已提交，可以读。</p><h3 id="在第二个Read-View生成时"><a href="#在第二个Read-View生成时" class="headerlink" title="在第二个Read View生成时"></a>在第二个Read View生成时</h3><p>事务A，B已提交，事务C，D未提交，所以mids为他们的对应的id {3,4}</p><p>最小活跃事务id min_trx_id 为 3</p><p>预分配事务id 为最大活跃事务id:4  +1  所以 max_trx_id 为 5</p><p>创建事务的id creator_trx_id 为 4</p><p><img src="/../img/mvcc/rc-readview-example-2.png" alt="RCReadViewExample01"></p><p>根据上面版本链访问规则</p><p>trx_id&#x3D;3的记录 其对应的事务未提交，不能读，找下一个。</p><p>trx_id&#x3D;2的记录 其对应的事务已提交，可以读。</p><p>同时由此可见RC隔离级别下，不能解决幻读问题</p><h2 id="在RR（Repeatable-Read）隔离级别下的Read-View生成"><a href="#在RR（Repeatable-Read）隔离级别下的Read-View生成" class="headerlink" title="在RR（Repeatable Read）隔离级别下的Read View生成"></a>在RR（Repeatable Read）隔离级别下的Read View生成</h2><p>在RR隔离级别下，Read View只在第一次快照读生成，后续<strong>快照读</strong>复用</p><p><img src="/../img/mvcc/rr-readview.png" alt="RRReadView"></p><p>向上面分析的一样，第一次快照读可以读取到trx_id为1的数据，之后复用此Read View 依然是读取到trx_id为1的数据。</p><p>但是RR隔离级别下MVCC能完全避免幻读吗？</p><p><strong>不完全能</strong></p><h3 id="RR隔离级别下的幻读"><a href="#RR隔离级别下的幻读" class="headerlink" title="RR隔离级别下的幻读"></a>RR隔离级别下的幻读</h3><p>上文中我们提到了当前读与快照读，在RR隔离级别下，当前读<strong>不会复用第一次快照读产生的Read View</strong>，<strong>而是重新生成Read View</strong>。</p><p>所以，当两次快照读之间有当前读时，就有可能产生幻读。因为第二次快照读不回复用第一次快照读产生的Read View，而是使用当前读新生成的Read View。</p><p><img src="/../img/mvcc/rr-readview-example.png" alt="RRReadViewExample"></p><p>我们可以看到，在执行update语句后，事务B重新生成Read View，在次执行select语句就出现了幻读问题。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中线程是如何启动的</title>
    <link href="/2023/08/25/thread-start0/"/>
    <url>/2023/08/25/thread-start0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java中线程是如何启动的"><a href="#Java中线程是如何启动的" class="headerlink" title="Java中线程是如何启动的"></a>Java中线程是如何启动的</h1><h2 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h2><p>在Java中有多种创建新线程的方式</p><h3 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1.继承Thread类"></a>1.继承Thread类</h3><p>通过继承Thread类，并实现其run方法，最后调用start方法执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start();<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;MyThread&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2.实现Runnable接口"></a>2.实现Runnable接口</h3><p>实现Runnable接口，重写run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>());<br>        thread.start();<br>       <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;myRunnable&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可简写为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;my thread&quot;</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3.实现Callable接口"></a>3.实现Callable接口</h3><p>实现Callable接口，传入FutureTask 可获取返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">MyCallable</span> <span class="hljs-variable">myCallable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>        FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(myCallable);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask).start();<br>        System.out.println(futureTask.get());<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4.线程池"></a>4.线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">10</span>, <br>                <span class="hljs-number">10</span>, <br>                <span class="hljs-number">0L</span>, <br>                TimeUnit.MILLISECONDS, <br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>        <br>        <br>        executor.execute(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;ThreadPoolExecutor&quot;</span>);<br>        &#125;);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p>在前三种线程的创建方式中，我们观察到最终都会调用Thread的start方法</p><h3 id="thread-start"><a href="#thread-start" class="headerlink" title="thread.start()"></a>thread.start()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Causes this thread to begin execution; the Java Virtual Machine</span><br><span class="hljs-comment"> * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * The result is that two threads are running concurrently: the</span><br><span class="hljs-comment"> * current thread (which returns from the call to the</span><br><span class="hljs-comment"> * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its</span><br><span class="hljs-comment"> * &lt;code&gt;run&lt;/code&gt; method).</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * It is never legal to start a thread more than once.</span><br><span class="hljs-comment"> * In particular, a thread may not be restarted once it has completed</span><br><span class="hljs-comment"> * execution.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@exception</span>  IllegalThreadStateException  if the thread was already</span><br><span class="hljs-comment"> *               started.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>        #run()</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>        #stop()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method is not invoked for the main method thread or &quot;system&quot;</span><br><span class="hljs-comment">     * group threads created/set up by the VM. Any new functionality added</span><br><span class="hljs-comment">     * to this method in the future may have to also be added to the VM.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * A zero status value corresponds to state &quot;NEW&quot;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br><br>    <span class="hljs-comment">/* Notify the group that this thread is about to be started</span><br><span class="hljs-comment">     * so that it can be added to the group&#x27;s list of threads</span><br><span class="hljs-comment">     * and the group&#x27;s unstarted count can be decremented. */</span><br>    group.add(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//调用 private native void start0();</span><br>        start0();<br>        started = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (!started) &#123;<br>                group.threadStartFailed(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;<br>            <span class="hljs-comment">/* do nothing. If start0 threw a Throwable then</span><br><span class="hljs-comment">              it will be passed up the call stack */</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Thread的start()方法最终调用了 一个本地方法start0</p><h3 id="start0"><a href="#start0" class="headerlink" title="start0"></a>start0</h3><p>start0来到了JVM源码层面，start0所注册的方法在JVM中对应  <strong>JVM_StartThread</strong>  方法</p><p>它首先定义了一个JavaThread对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">JavaThread *native_thread = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>并对对象进行了实例化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">native_thread = new JavaThread(&amp;thread_entry,sz);<br><span class="hljs-comment">//&amp;thread_entry 为线程创建成功后要执行的方法</span><br></code></pre></td></tr></table></figure><p><img src="/../img/thread-start0/JVM_StartThread.png" alt="JVM_StartThread"></p><p>JavaThread的构造方法</p><p><img src="/../img/thread-start0/JavaThread.png" alt="JavaThread"></p><p>它将初始化要执行的方法保存为属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">set_entry_point</span>(entry_point);<br></code></pre></td></tr></table></figure><p>然后调用了os的创建线程方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">os::<span class="hljs-built_in">create_thread</span>(<span class="hljs-keyword">this</span>, thr_type, stack_sz);<br><span class="hljs-comment">//os底层有着不同的平台实现</span><br></code></pre></td></tr></table></figure><p>以linux为例</p><p><img src="/../img/thread-start0/linux-os.png" alt="linux-os"></p><p>它创建了一个OSThread对象，并关联了JavaThread</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Allocate the 0SThread object</span><br><span class="hljs-function">OSThread*osthread <span class="hljs-keyword">new</span> <span class="hljs-title">OSThread</span><span class="hljs-params">(<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>)</span></span>;<br><br><span class="hljs-comment">//....</span><br><br><span class="hljs-comment">//JavaThread关联上OSThread</span><br>thread-&gt;<span class="hljs-built_in">set_osthread</span>(osthread);<br></code></pre></td></tr></table></figure><p><img src="/../img/thread-start0/linux-os2.png" alt="linux-os"></p><p>调用系统的线程创建方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//最中调用Liux创建线程的方法</span><br><span class="hljs-type">int</span> ret pthread_create &amp;tid,&amp;attr,(<span class="hljs-type">void</span>*(*)(<span class="hljs-type">void</span>*))java_start,thread)<br><span class="hljs-comment">//其中java_start为线程创建后要执行的方法 thread为其入参</span><br></code></pre></td></tr></table></figure><p><img src="/../img/thread-start0/linux-os3.png" alt="linux-os"></p><p>父线程会在此处等待子线程初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> ((state osthread-&gt;<span class="hljs-built_in">get_state</span>())==ALLOCATED)&#123;<br>sync_with_child-&gt;<span class="hljs-built_in">wait</span>(Mutex::_no_safepoint_check_flag);<br>&#125;<br></code></pre></td></tr></table></figure><p>子线程初始化</p><p><img src="/../img/thread-start0/linux-os4.png" alt="linux-os"></p><p>子线程会把内核线程和osThread关联起来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//thread id is kernel thread id (similar to Solaris LwP id)</span><br>osthread-&gt;<span class="hljs-built_in">set_thread_id</span>(os::Linux::<span class="hljs-built_in">gettid</span>());<br></code></pre></td></tr></table></figure><p>然后会在此处等待父线程的一些操作</p><p><img src="/../img/thread-start0/linux-os5.png" alt="linux-os"></p><p>然后主线程会帮子线程做一些prepare操作</p><p><img src="/../img/thread-start0/JVM_StartThread2.png" alt="linux-os"></p><p>在prepare方法中父线程把JVM中的JavaThread与上层的线程对象关联起来，并设置了优先级</p><p><img src="/../img/thread-start0/prepare.png" alt="prepare"></p><p>prepare结束后父线程执行Thread::start(native_thread)方法</p><p><img src="/../img/thread-start0/start.png" alt="start"></p><p>调用os::start_thread方法 将线程状态修改为RUNNABLE，然后唤醒子线程</p><p><img src="/../img/thread-start0/set_runnable.png" alt="set_runnable"></p><p>子线程被唤醒后执行thread_main_inner方法</p><p><img src="/../img/thread-start0/inner.png" alt="inner"></p><p>把之前属性里面存的执行方法取出来进行执行</p><p>此处的JavaCalls就是c访问java代码的大门，通过它 执行了 Thread里的run方法，完成线程的创建</p><p><img src="/../img/thread-start0/java_calls.png" alt="inner"></p><h3 id="底层线程的复用"><a href="#底层线程的复用" class="headerlink" title="底层线程的复用"></a>底层线程的复用</h3><p>在底层线程创建完后，让其一直运行， 包装run方法，让其结束后调用下一个run方法，这就是线程池的雏形。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx-rtmp-module直播推流</title>
    <link href="/2023/08/11/nginx-rtmp-module/"/>
    <url>/2023/08/11/nginx-rtmp-module/</url>
    
    <content type="html"><![CDATA[<h1 id="nginx-rtmp-module"><a href="#nginx-rtmp-module" class="headerlink" title="nginx-rtmp-module"></a>nginx-rtmp-module</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>强烈建议直接阅读官方文档：<a href="https://github.com/arut/nginx-rtmp-module/wiki/Directives">https://github.com/arut/nginx-rtmp-module/wiki/Directives</a></strong></p><p>nginx-rtmp-module 是 Nginx 的一个第三方模块，用于添加对 RTMP（实时消息传输协议）流媒体的支持。RTMP 是一种用于通过互联网传输音频、视频和其他数据的协议。</p><p>nginx-rtmp-module 扩展了 Nginx 的功能，通过提供一组指令和功能，专门用于处理 RTMP 流媒体。该模块提供的一些关键功能包括：</p><ol><li>RTMP 流媒体：该模块使得 Nginx 可以作为 RTMP 服务器，接收来自各种源的 RTMP 流，例如实时视频编码器、媒体播放器或其他 RTMP 服务器。</li><li>实时流媒体：它支持实时发布和流式传输视频或音频内容。这对于直播视频广播、视频会议或实时游戏等应用非常有用。</li><li>视频点播：该模块支持点播流媒体，允许您托管预先录制的视频并在客户端请求时提供。这通常用于视频托管平台或内容分发网络（CDN）。</li><li>HLS 支持：该模块包括对 HTTP Live Streaming（HLS）的支持，HLS 是一种广泛用于通过 HTTP 传输多媒体内容的自适应流媒体协议。HLS 支持自适应比特率流式传输，允许客户端根据网络条件调整流媒体的质量。</li><li>录制和回放：您可以配置模块将传入的 RTMP 流记录到磁盘，以便将实时广播保存下来以供以后回放或归档。</li></ol><p>要使用 nginx-rtmp-module，您需要从源代码编译 Nginx，并在编译过程中包含该模块。一旦编译了带有该模块的 Nginx，您可以通过在 Nginx 配置文件中指定适当的指令来配置 Nginx 处理 RTMP 流媒体。</p><p>需要注意的是，nginx-rtmp-module 是一个第三方模块，不受 Nginx 项目的官方支持。因此，在使用该模块时，建议仔细阅读模块的文档并参考社区支持资源。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">//安装git<br>yum -y install git<br><br>//安装wget<br>yum -y install wget<br><br>//安装gcc<br>yum -y install gcc gcc-c++ autoconf make<br><br>//下载源码(也可以自行下载源码，ftp上传到服务器)<br>git <span class="hljs-built_in">clone</span> https://github.com/arut/nginx-rtmp-module.git<br><br>//安装openssl<br>yum -y install openssl openssl-devel<br><br>//下载nginx<br>wget http://nginx.org/download/nginx-1.21.6.tar.gz<br><br>//解压nginx<br>tar -zxvf nginx-1.21.6.tar.gz<br><br><span class="hljs-built_in">cd</span> nginx-1.21.6<br><br>// --prefix=安装目录。<br>./configure --prefix=/usr/local/nginx  --add-module=../nginx-rtmp-module  --with-http_ssl_module<br><br>//编译安装<br>make &amp;&amp; make install<br></code></pre></td></tr></table></figure><h2 id="编辑配置"><a href="#编辑配置" class="headerlink" title="编辑配置"></a>编辑配置</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#user  nobody;</span><br><span class="hljs-attribute">worker_processes</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">#error_log  logs/error.log;</span><br><span class="hljs-comment">#error_log  logs/error.log  notice;</span><br><span class="hljs-comment">#error_log  logs/error.log  info;</span><br><br><span class="hljs-comment">#pid        logs/nginx.pid;</span><br><span class="hljs-section">events</span> &#123;<br>    <span class="hljs-attribute">worker_connections</span> <span class="hljs-number">1024</span>;<br>&#125;<br><br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span> mime.types;<br>    <span class="hljs-attribute">default_type</span> application/octet-stream;<br><br>    <span class="hljs-comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br>    <span class="hljs-comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br>    <span class="hljs-comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><br>    <span class="hljs-comment">#access_log  logs/access.log  main;</span><br>    <span class="hljs-attribute">sendfile</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-comment">#tcp_nopush     on;</span><br><br>    <span class="hljs-comment">#keepalive_timeout  0;</span><br>    <span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">65</span>;<br><br>    <span class="hljs-comment">#gzip  on;</span><br><br>    <span class="hljs-comment">#http服务器</span><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span>;<br>        <span class="hljs-attribute">server_name</span> localhost;<br><br>        <span class="hljs-comment">#charset koi8-r;</span><br><br>        <span class="hljs-comment">#access_log  logs/host.access.log  main;</span><br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">add_header</span> Cache-Control <span class="hljs-literal">no</span>-cache;<br>            <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span> always;<br>            <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Expose-Headers&#x27;</span> <span class="hljs-string">&#x27;Content-Length,Content-Range&#x27;</span>;<br>            <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;Range&#x27;</span>;<br>            <span class="hljs-attribute">root</span> /home/nginx/html;<br>            <span class="hljs-attribute">index</span> index.html index.htm;<br>        &#125;<br><br>        <span class="hljs-comment">#http://ip:8080/stat 为rtmp可视化界面</span><br>        <span class="hljs-section">location</span> /stat &#123;<br>            <span class="hljs-attribute">rtmp_stat</span> all;<br>            <span class="hljs-attribute">rtmp_stat_stylesheet</span> stat.xsl;<br>        &#125;<br>        <span class="hljs-section">location</span> /stat.xsl &#123;<br>            <span class="hljs-comment"># you can move stat.xsl to a different location</span><br>            <span class="hljs-attribute">root</span> /home/nginx/nginx-rtmp-module-<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-comment"># rtmp control 为nginx的控制url</span><br>        <span class="hljs-section">location</span> /control &#123;<br>            <span class="hljs-attribute">rtmp_control</span> all;<br>        &#125;<br><br><br>        <span class="hljs-comment">#error_page  404              /404.html;</span><br>        <span class="hljs-comment"># redirect server error pages to the static page /50x.html</span><br>        <span class="hljs-comment">#</span><br>        <span class="hljs-attribute">error_page</span> <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span> /50x.html;<br>        <span class="hljs-section">location</span> = /50x.html &#123;<br>            <span class="hljs-attribute">root</span> html;<br>        &#125;<br><br>        <span class="hljs-comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br>        <span class="hljs-comment">#</span><br>        <span class="hljs-comment">#location ~ \.php$ &#123;</span><br>        <span class="hljs-comment">#    proxy_pass   http://127.0.0.1;</span><br>        <span class="hljs-comment">#&#125;</span><br><br>        <span class="hljs-comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br>        <span class="hljs-comment">#</span><br>        <span class="hljs-comment">#location ~ \.php$ &#123;</span><br>        <span class="hljs-comment">#    root           html;</span><br>        <span class="hljs-comment">#    fastcgi_pass   127.0.0.1:9000;</span><br>        <span class="hljs-comment">#    fastcgi_index  index.php;</span><br>        <span class="hljs-comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br>        <span class="hljs-comment">#    include        fastcgi_params;</span><br>        <span class="hljs-comment">#&#125;</span><br>        <span class="hljs-comment"># deny access to .htaccess files, if Apache&#x27;s document root</span><br>        <span class="hljs-comment"># concurs with nginx&#x27;s one</span><br>        <span class="hljs-comment">#</span><br>        <span class="hljs-comment">#location ~ /\.ht &#123;</span><br>        <span class="hljs-comment">#    deny  all;</span><br>        <span class="hljs-comment">#&#125;</span><br>    &#125;<br><br><br>    <span class="hljs-comment"># another virtual host using mix of IP-, name-, and port-based configuration</span><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment">#server &#123;</span><br>    <span class="hljs-comment">#    listen       8000;</span><br>    <span class="hljs-comment">#    listen       somename:8080;</span><br>    <span class="hljs-comment">#    server_name  somename  alias  another.alias;</span><br>    <span class="hljs-comment">#    location / &#123;</span><br>    <span class="hljs-comment">#        root   html;</span><br>    <span class="hljs-comment">#        index  index.html index.htm;</span><br>    <span class="hljs-comment">#    &#125;</span><br>    <span class="hljs-comment">#&#125;</span><br>    <span class="hljs-comment"># HTTPS server</span><br>    <span class="hljs-comment">#</span><br>    <span class="hljs-comment">#server &#123;</span><br>    <span class="hljs-comment">#    listen       443 ssl;</span><br>    <span class="hljs-comment">#    server_name  localhost;</span><br>    <span class="hljs-comment">#    ssl_certificate      cert.pem;</span><br>    <span class="hljs-comment">#    ssl_certificate_key  cert.key;</span><br>    <span class="hljs-comment">#    ssl_session_cache    shared:SSL:1m;</span><br>    <span class="hljs-comment">#    ssl_session_timeout  5m;</span><br>    <span class="hljs-comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br>    <span class="hljs-comment">#    ssl_prefer_server_ciphers  on;</span><br>    <span class="hljs-comment">#    location / &#123;</span><br>    <span class="hljs-comment">#        root   html;</span><br>    <span class="hljs-comment">#        index  index.html index.htm;</span><br>    <span class="hljs-comment">#    &#125;</span><br>    <span class="hljs-comment">#&#125;</span><br>&#125;<br><br><br><span class="hljs-section">rtmp</span> &#123;<br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">1935</span>;<br>        <span class="hljs-attribute">chunk_size</span> <span class="hljs-number">4096</span>;<br><br>        <span class="hljs-attribute">application</span> live &#123;<br>            <span class="hljs-attribute">live</span> <span class="hljs-literal">on</span>;<br>            <span class="hljs-attribute">record</span> <span class="hljs-literal">off</span>;<br><br>            <span class="hljs-comment">#开始推流的callback，必须后方地址返回200才能接受推流</span><br>            <span class="hljs-comment">#其中key参数是rtmp携带的param，会POST到callbackUrl，使用@responseBody接受</span><br>            <span class="hljs-attribute">on_publish</span> http://127.0.0.1/on_publish?key=<span class="hljs-variable">$key</span>;<br>            <span class="hljs-comment">#推流结束的回调端口</span><br>            <span class="hljs-attribute">on_publish_done</span> http://127.0.0.1/on_publish_done;<br><br>            <span class="hljs-comment">#开启http live streaming</span><br>            <span class="hljs-attribute">hls</span> <span class="hljs-literal">on</span>;<br>            <span class="hljs-comment">#在hls_path处生成m3u8文件与ts切片</span><br>            <span class="hljs-attribute">hls_path</span> /home/nginx/html/hls;<br>            <span class="hljs-comment">#分片长度</span><br>            <span class="hljs-attribute">hls_fragment</span> <span class="hljs-number">5s</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">cd</span> /path/to/nginx/sbin<br><br>./nginx -t<br><br>./nginx -c /path/to/nginx/conf/nginx.conf<br></code></pre></td></tr></table></figure><h2 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a>配置详解</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><br><span class="hljs-section">rtmp</span> &#123;<br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">1935</span>;<br>        <span class="hljs-attribute">chunk_size</span> <span class="hljs-number">4096</span>;<br><br>        <span class="hljs-attribute">application</span> live &#123;<br><br>            <span class="hljs-comment"># 限制同时连接的客户端数量为 100</span><br>            <span class="hljs-attribute">limit_conn</span> conn_limit <span class="hljs-number">100</span>;<br>            <span class="hljs-attribute">limit_conn_log_level</span> <span class="hljs-literal">error</span>;<br>            <span class="hljs-attribute">limit_conn_status</span> <span class="hljs-number">429</span>;<br><br>            <span class="hljs-attribute">live</span> <span class="hljs-literal">on</span>;<br>            <span class="hljs-comment">#是否开启回放</span><br>            <span class="hljs-attribute">record</span> <span class="hljs-literal">off</span>;<br><br>            <span class="hljs-comment">#开始推流的callback，必须后方地址返回200才能接受推流</span><br>            <span class="hljs-comment">#其中key参数是rtmp携带的param，会POST到callbackUrl</span><br>            <span class="hljs-attribute">on_publish</span> http://127.0.0.1/on_publish?key=<span class="hljs-variable">$key</span>;<br>            <span class="hljs-comment">#推流结束的回调端口</span><br>            <span class="hljs-attribute">on_publish_done</span> http://127.0.0.1/on_publish_done;<br><br>            <span class="hljs-comment">#开启http live streaming</span><br>            <span class="hljs-attribute">hls</span> <span class="hljs-literal">on</span>;<br>            <span class="hljs-comment">#在hls_path处生成m3u8文件与ts切片</span><br>            <span class="hljs-attribute">hls_path</span> /home/nginx/html/hls;<br>            <span class="hljs-comment">#分片长度</span><br>            <span class="hljs-attribute">hls_fragment</span> <span class="hljs-number">5s</span>;<br>            <span class="hljs-comment">#exec 可以执行ffmpeg命令，ffmpeg需要添加到环境变量中，或者你也可以指定ffmpeg目录</span><br>            <span class="hljs-attribute">exec</span> ffmpeg -i rtmp://localhost/live/<span class="hljs-variable">$name</span> -c:v libx264 -preset veryfast -s 1280x720 -b:v <span class="hljs-number">2M</span> -c:a aac -f hls -hls_time <span class="hljs-number">10</span> -hls_list_size <span class="hljs-number">6</span> -hls_flags delete_segments /path/to/hls/directory/<span class="hljs-variable">$name</span>.m3u8;<br>            <span class="hljs-comment">#此处是将推送的流转换分辨率并保存</span><br>            <span class="hljs-comment"># 转发流到另一个 RTMP 服务器，包括 stream 变量</span><br>            <span class="hljs-attribute">push</span> rtmp://another-rtmp-server/app/<span class="hljs-variable">$key</span>;<br><br><br>            <span class="hljs-comment">#播放权限的控制，同使用方法同on_publish</span><br>            <span class="hljs-attribute">on_play</span> http://your-auth-server/check_play;<br><br>            <span class="hljs-comment"># 启用录制</span><br>            <span class="hljs-attribute">record</span> all;<br>            <span class="hljs-attribute">record_path</span> /path/to/recordings;<br>            <span class="hljs-attribute">record_unique</span> <span class="hljs-literal">on</span>;<br>            <span class="hljs-attribute">record_suffix</span> .flv;<br><br><br>            <span class="hljs-comment"># 配置推流超时限制为 30 秒</span><br>            <span class="hljs-attribute">exec_push_timeout</span> <span class="hljs-number">30s</span>;<br><br>            <span class="hljs-comment"># 配置播放超时限制为 60 秒</span><br>            <span class="hljs-attribute">play_timeout</span> <span class="hljs-number">60s</span>;<br><br>            <span class="hljs-comment"># 限制播放带宽为 2 Mbps</span><br>            <span class="hljs-attribute">limit_rate</span> <span class="hljs-number">2M</span>;<br><br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时的推流地址为：<strong>rtmp:&#x2F;&#x2F;ip:1935&#x2F;live&#x2F;{自定义}?key&#x3D;{key}</strong></p><h2 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h2><h3 id="on-connect"><a href="#on-connect" class="headerlink" title="on_connect"></a>on_connect</h3><p>Syntax: <code>on_connect url</code><br>Context: rtmp, server</p><p>Sets HTTP connection callback. When clients issues connect command an HTTP request is issued asynchronously and command processing is suspended until it returns result code. If HTTP 2xx code is returned then RTMP session continues. The code of 3xx makes RTMP redirect to another application whose name is taken from <code>Location</code> HTTP response header. Otherwise connection is dropped.</p><p>Note this directive is not allowed in application scope since application is still unknown at connection stage.</p><p>HTTP request receives a number of arguments. POST method is used with application&#x2F;x-www-form-urlencoded MIME type. The following arguments are passed to caller:</p><ul><li>call&#x3D;connect</li><li>addr - client IP address</li><li>app - application name</li><li>flashVer - client flash version</li><li>swfUrl - client swf url</li><li>tcUrl - tcUrl</li><li>pageUrl - client page url</li></ul><h3 id="on-play"><a href="#on-play" class="headerlink" title="on_play"></a>on_play</h3><p>Syntax: <code>on_play url</code><br>Context: rtmp, server, application</p><p>Sets HTTP play callback. Each time a clients issues play command an HTTP request is issued asynchronously and command processing is suspended until it returns result code. HTTP result code is then analyzed.</p><ul><li>HTTP 2xx code continues RTMP session</li><li>HTTP 3xx redirects RTMP to another stream whose name is taken from <code>Location</code> HTTP response header. If new stream name is started with <code>rtmp://</code> then remote relay is created instead. Relays require that IP address is specified instead of domain name and only work with nginx versions greater than 1.3.10. See also <code>notify_relay_redirect</code>.</li><li>Otherwise RTMP connection is dropped</li></ul><p>正如官方文档所说on_play可以控制播放权限</p><h3 id="on-publish"><a href="#on-publish" class="headerlink" title="on_publish"></a>on_publish</h3><p>语法：on_publish url<br>上下文：rtmp, server, application<br>描述：这个可以设置为一个API接口（GET方式接受所有参数），会给这个API接口返回8个参数</p><p>注意：nginx-rtmp-module-1.1.11 中的on_publish 回调的请求为post请求方式：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$app = $_GET[<span class="hljs-string">&#x27;app&#x27;</span>]<span class="hljs-comment">;</span><br>        $swfurl = $_GET[<span class="hljs-string">&#x27;swfurl&#x27;</span>]<span class="hljs-comment">;</span><br>        $tcurl = $_GET[<span class="hljs-string">&#x27;tcurl&#x27;</span>]<span class="hljs-comment">;</span><br>        $pageurl = $_GET[<span class="hljs-string">&#x27;pageurl&#x27;</span>]<span class="hljs-comment">;</span><br>        $addr = $_GET[<span class="hljs-string">&#x27;addr&#x27;</span>]<span class="hljs-comment">;</span><br>        $clientid = $_GET[<span class="hljs-string">&#x27;clientid&#x27;</span>]<span class="hljs-comment">;</span><br>        $call = $_GET[<span class="hljs-string">&#x27;call&#x27;</span>]<span class="hljs-comment">;</span><br>        $name = $_GET[<span class="hljs-string">&#x27;name&#x27;</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>可以使用on_publish来进行推流的权限控制</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">on_publish http:<span class="hljs-regexp">//</span>example.com/my_auth;<br></code></pre></td></tr></table></figure><h3 id="on-publish-done"><a href="#on-publish-done" class="headerlink" title="on_publish_done"></a>on_publish_done</h3><p>语法：on_publish_done url<br>上下文：rtmp, server, application<br>描述：等同于 on_done 的表现，但只适用于发布结束事件。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autoit">$app = $_GET[<span class="hljs-string">&#x27;app&#x27;</span>]<span class="hljs-comment">;</span><br>        $swfurl = $_GET[<span class="hljs-string">&#x27;swfurl&#x27;</span>]<span class="hljs-comment">;</span><br>        $tcurl = $_GET[<span class="hljs-string">&#x27;tcurl&#x27;</span>]<span class="hljs-comment">;</span><br>        $pageurl = $_GET[<span class="hljs-string">&#x27;pageurl&#x27;</span>]<span class="hljs-comment">;</span><br>        $addr = $_GET[<span class="hljs-string">&#x27;addr&#x27;</span>]<span class="hljs-comment">;</span><br>        $clientid = $_GET[<span class="hljs-string">&#x27;clientid&#x27;</span>]<span class="hljs-comment">;</span><br>        $call = $_GET[<span class="hljs-string">&#x27;call&#x27;</span>]<span class="hljs-comment">;</span><br>        $name = $_GET[<span class="hljs-string">&#x27;name&#x27;</span>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>注意要点：要使用on_publish和on_publish_done 必须的添加 notify_method get; 否则的话OBS推流总是推不上去的，服务器不认哦！！！！</p><h2 id="自带可视化"><a href="#自带可视化" class="headerlink" title="自带可视化"></a>自带可视化</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-attribute">include</span> mime.types;<br>    <span class="hljs-attribute">default_type</span> application/octet-stream;<br><br>    <span class="hljs-comment">#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br>    <span class="hljs-comment">#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br>    <span class="hljs-comment">#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><br>    <span class="hljs-comment">#access_log  logs/access.log  main;</span><br>    <span class="hljs-attribute">sendfile</span> <span class="hljs-literal">on</span>;<br>    <span class="hljs-comment">#tcp_nopush     on;</span><br><br>    <span class="hljs-comment">#keepalive_timeout  0;</span><br>    <span class="hljs-attribute">keepalive_timeout</span> <span class="hljs-number">65</span>;<br><br>    <span class="hljs-comment">#gzip  on;</span><br><br>    <span class="hljs-comment">#http服务器</span><br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">8080</span>;<br>        <span class="hljs-attribute">server_name</span> localhost;<br><br>        <span class="hljs-comment">#charset koi8-r;</span><br><br>        <span class="hljs-comment">#access_log  logs/host.access.log  main;</span><br>        <span class="hljs-section">location</span> / &#123;<br>            <span class="hljs-attribute">add_header</span> Cache-Control <span class="hljs-literal">no</span>-cache;<br>            <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="hljs-string">&#x27;*&#x27;</span> always;<br>            <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Expose-Headers&#x27;</span> <span class="hljs-string">&#x27;Content-Length,Content-Range&#x27;</span>;<br>            <span class="hljs-attribute">add_header</span> <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="hljs-string">&#x27;Range&#x27;</span>;<br>            <span class="hljs-attribute">root</span> /home/nginx/html;<br>            <span class="hljs-attribute">index</span> index.html index.htm;<br>        &#125;<br><br>        <span class="hljs-comment">#http://ip:8080/stat 为rtmp可视化界面</span><br>        <span class="hljs-section">location</span> /stat &#123;<br>            <span class="hljs-attribute">rtmp_stat</span> all;<br>            <span class="hljs-attribute">rtmp_stat_stylesheet</span> stat.xsl;<br>        &#125;<br>        <span class="hljs-section">location</span> /stat.xsl &#123;<br>            <span class="hljs-comment"># you can move stat.xsl to a different location</span><br>            <span class="hljs-attribute">root</span> /home/nginx/nginx-rtmp-module-<span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-comment"># rtmp control 为nginx的控制url</span><br>        <span class="hljs-section">location</span> /control &#123;<br>            <span class="hljs-attribute">rtmp_control</span> all;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面的配置配置了rtmp的控制url和可视化监控</p><p>控制模块详情见：<a href="https://github.com/arut/nginx-rtmp-module/wiki/Control-module">https://github.com/arut/nginx-rtmp-module/wiki/Control-module</a></p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>synchronized锁升级</title>
    <link href="/2023/08/03/lock-escalation/"/>
    <url>/2023/08/03/lock-escalation/</url>
    
    <content type="html"><![CDATA[<h1 id="synchronized锁升级"><a href="#synchronized锁升级" class="headerlink" title="synchronized锁升级"></a>synchronized锁升级</h1><p>在 Java 中，每个<strong>对象中</strong>都隐藏着一把锁，而 synchronized 关键字就是激活这把隐式锁的把手（开关）。</p><p>在 JDK 1.6 之前，使用 synchronized 关键字需要依赖于底层操作系统的 Mutex Lock 实现，<strong>挂起线程和恢复线程都需要转入内核态来完成</strong>，也就是说阻塞或唤醒一个 Java 线程都需要系统去切换 CPU 状态，这种状态的切换需要消耗处理器时间。这也就是为什么 synchronized 属于重量级锁的原因，因为<strong>需要切换 CPU 状态导致效率低下，时间成本相对较高</strong>，特别是当同步代码的内容过于简单时，可能切换的时间还要比代码执行的时间长。</p><p>在 JDK 1.6 之后，引入了偏向锁与轻量锁来减小获取和释放锁所带来的性能消耗，也就是<strong>不再是一上来就需要切换 CPU 状态导致效率低下而是通过锁升级的方式逐步增大性能消耗</strong>，从而避免了一些无需使用重量级锁的情况的性能消耗问题。</p><p>synchronized会经历四个阶段：<code>无锁状态</code>、<code>偏向锁</code>、<code>轻量级锁</code>、<code>重量级锁</code> 依次从耗费资源最少，性能最高，到耗费资源多，性能最差。</p><h2 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h2><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a><strong>偏向锁</strong></h3><p>当一个线程到达<strong>同步代码块</strong>，尝试获取锁对象的时候，会查看对象头中的<code>MarkWord</code>里的线程ID，如果这里没有ID则将自己的保存进去，拿到锁。若是有，则查看是否是当前线程，如果不是，就CAS尝试改，如果是，就已经拿到了锁资源。</p><p>这里详细说说CAS尝试修改的逻辑：它会<strong>检查持有偏向锁的线程状态</strong>。首先<strong>遍历当前JVM的所有存活的线程</strong>，如果<strong>能找到</strong>偏向的线程，则说明偏向的线程<strong>还存活</strong>，此时会<strong>检查线程是否在执行同步代码块中的代码</strong>，如果是，则升级为轻量级锁，去继续进行CAS竞争锁。所以加了偏向锁之后，同时只有一个线程可以拿到锁执行同步代码块中的代码。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a><strong>轻量级锁</strong></h3><p>查看对象头中的<code>MarkWord</code>里的<code>Lock Record</code>指针指向的是否是当前线程的虚拟机栈，如果是，拿锁执行业务，如果不是则进行CAS，尝试修改，若是修改几次都没有成功，再升级到重量级锁。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a><strong>重量级锁</strong></h3><p>查看对象头中的<code>MarkWord</code>里的指向的<code>ObjectMonitor</code>，查看owner是否是当前线程，如果不是，扔到<code>ObjectMonitor</code>里的<code>EntryList</code>中排队，并挂起线程，等待被唤醒。</p><h2 id="JAVA对象结构"><a href="#JAVA对象结构" class="headerlink" title="JAVA对象结构"></a><strong>JAVA对象结构</strong></h2><p><img src="/../img/lock-escalation/MemModel.png" alt="对象结构"></p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>从脑图中可以看出，其由 Mark Word、Class Pointer、数组长度三个字段组成。简单来说：</p><ul><li><strong>Mark Word</strong>：主要用于存储自身运行时数据</li><li><strong>Class Pointer</strong>：是指针，指向方法区中该 class 的对象，JVM 通过此字段来判断当前对象是哪个类的实例</li><li><strong>数组长度</strong>：当且仅当对象是数组时才会有该字段</li></ul><p>Mark Word 所代表的「运行时数据」主要用来表示当前 Java 对象的<strong>线程锁</strong>状态以及 GC 的标志。而<strong>线程锁状态</strong>分别就是无锁、偏向锁、轻量级锁、重量级锁。</p><p>前文提到的这 4 个状态，其实就是 Java 内置锁的<strong>不同状态</strong>。</p><p>随着锁竞争逐渐激烈，其状态会按照「无锁 &#x3D;&#x3D;&gt; 偏向锁 &#x3D;&#x3D;&gt; 轻量级锁 &#x3D;&#x3D;&gt; 重量级锁 」这个方向逐渐升级，并且<strong>不可逆</strong>，只能进行锁升级，而<strong>无法进行锁降级</strong>。</p><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>无锁其实就是不使用 synchronized 关键字，无锁的锁标志位为 01。</p><p><img src="/../img/lock-escalation/noLock.png" alt="无锁"></p><h2 id="偏向锁-1"><a href="#偏向锁-1" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>标记字段中偏向锁状态如下：</p><p><img src="/../img/lock-escalation/pxLock.png" alt="偏向锁"></p><h3 id="为什么引入偏向锁？"><a href="#为什么引入偏向锁？" class="headerlink" title="为什么引入偏向锁？"></a><strong>为什么引入偏向锁？</strong></h3><p>其实在大多数实际应用运行过程中，锁不存在多线程竞争的，而是总被同一个线程持有，很少发生竞争。这样的话就会带来多次非必要的获取释放锁过程，从而带来非必要的性能开销。所以<strong>引入了偏向锁是为了解决只有一个线程执行同步代码时提高性能</strong>。</p><p>偏向锁的作用：当一段同步代码一直被同一个线程多次访问时，由于只有一个线程，该线程后续访问时无需再次获取锁。</p><h3 id="偏向锁的升级过程"><a href="#偏向锁的升级过程" class="headerlink" title="偏向锁的升级过程"></a><strong>偏向锁的升级过程</strong></h3><p>当一个线程进入被 synchronized 关键字修饰的同步代码后，<strong>JVM 会使用 CAS 操作把当前线程 ID 记录到作为锁的对象的 Mark Word 中占用 54 bit 的 ThreadID 字段中</strong>，同时会修改偏向锁位置为 1，表示当前线程获得该锁。此时的锁对象由无锁状态变为偏向锁状态。</p><p>在当前线程再次访问该同步代码时，<strong>JVM 通过锁对象的对象头的 Mark Word 判断 ThreadID 字段是否与当前线程 ID 一致</strong>，一致则说明当前线程还持有该锁对象，可以直接进入同步代码（偏向锁不会在线程执行完同步代码后就释放，也就是线程不会主动释放偏向锁）。</p><p>可以看到通过这种方式无需切换 CPU 状态，也就是不用操作系统接入。<strong>偏向锁其实就是在没有其他线程的竞争下，一直偏向于同一线程，该线程可以一直访问同步代码，而无需重复加锁</strong>。所以使用偏向锁几乎没有额外的开销，性能极高。</p><h3 id="偏向锁的撤销过程"><a href="#偏向锁的撤销过程" class="headerlink" title="偏向锁的撤销过程"></a><strong>偏向锁的撤销过程</strong></h3><p>前面也提到了线程不会主动释放偏向锁，偏向锁的释放时机在：<strong>只有当其他线程竞争该锁时，持有偏向锁的线程才会被撤销，释放该偏向锁</strong>。并且撤销需要等待全局安全点，也就是该时间点没有字节码正在执行。</p><p>同时根据<strong>当前持有偏向锁的线程是否执行完同步代码</strong>分为两种撤销情况：</p><ul><li><p>情况一：线程 A 正在执行同步代码（还没有执行完同步代码）。此时线程 B 抢占该锁，<strong>该偏向锁会被撤销并出现锁升级成轻量级锁</strong>，此时该轻量级锁由原持有偏向锁的线程 A 持有，继续执行其同步代码，而正在竞争的线程 B 会进入自旋等待获得该轻量级锁。</p></li><li><p>情况二：线程 A 执行完同步代码（已经退出同步代码）。此时线程 B 抢占该锁，</p><p>该偏向锁会被撤销并将 ThreadID 置空以及偏向锁位置 0，根据线程 A 是否再次竞争分为：</p><ul><li>如果线程 A 不再继续竞争，那么会将偏向锁重新偏向线程 B，即线程 B 持有该偏向锁；</li><li>如果线程 A 继续竞争，那么会将锁升级到了轻量级锁，通过 CAS 自旋抢占锁；</li></ul></li></ul><h2 id="轻量级锁-1"><a href="#轻量级锁-1" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>标记字段中轻量级锁状态如下：</p><p><img src="/../img/lock-escalation/llock.png" alt="轻量级锁"></p><h3 id="为什么要引入轻量级锁？"><a href="#为什么要引入轻量级锁？" class="headerlink" title="为什么要引入轻量级锁？"></a><strong>为什么要引入轻量级锁？</strong></h3><p>轻量级锁是为了在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统的 Mutex Lock 带来的性能消耗，轻量级锁适用于线程交替执行同步代码的场景。所以<strong>轻量级锁是为了在线程近乎交替执行同步代码时提高性能</strong>。</p><h3 id="轻量级锁的升级和撤销过程"><a href="#轻量级锁的升级和撤销过程" class="headerlink" title="轻量级锁的升级和撤销过程"></a><strong>轻量级锁的升级和撤销过程</strong></h3><p>当线程 A 与 线程 B 同时抢占锁对象时，偏向锁会被撤销并将锁升级为轻量级锁，这个升级过程如下：</p><p>线程 A 在执行同步代码前，JVM 在线程的栈帧中创建用于存储锁记录的空间 Lock Record。当线程 A 抢占锁对象时，JVM 使用 CAS 操作将锁对象的对象头的 Mark Word 拷贝进线程 A 的锁记录 Lock Record 中（这个拷贝 Mark Word 的过程官方称为 <strong>Displaced Mark Word</strong>），并且<strong>将 Mark Word 中指向线程栈中 Lock Record 的指针指向线程 A 的锁空间</strong>。</p><p>如果更新成功，则线程 A 持有该对象锁，并将对象锁的 Mark Word 的锁标志位更新为 00。即此时线程 A 持有轻量级锁会执行同步代码，而线程 B 会自旋等待获取该轻量级锁；如果更新失败，则说明该锁被线程 B 抢占。</p><p>轻量级锁撤销的两种情况：</p><ul><li>当有两个以上的线程同时竞争一个锁时，那么轻量级锁会被撤销并升级为重量级锁，不再通过自旋的方式等待获取锁而是直接阻塞线程；</li><li>当持有轻量级锁的线程执行完同步代码时，同样会释放轻量级锁，<strong>会使用 CAS 操作将锁对象的 Mark Word 中指针指向的锁记录 Lock Record 重新替换回锁对象的 Mark Word</strong>。</li></ul><h2 id="重量级锁-1"><a href="#重量级锁-1" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>标记字段中重量级锁状态如下：</p><p><img src="/../img/lock-escalation/hlock.png" alt="重量级锁"></p><p>当<strong>存在两个以上的线程竞争同一把锁</strong>或<strong>线程竞争轻量级锁自旋多次仍然失败</strong>时，会导致锁升级为重量级锁。重量级锁会直接阻塞持有锁的线程以外的所有线程，防止 CPU 空转，减小 CPU 的开销。</p><p>通过将锁对象的 Mark Word 的锁标志位更新为 10，从而将锁升级为重量级锁。此时可以看到 Mark Word 中有一个指向互斥量的指针，<strong>这个指针其实指向的就是 Monitor 对象的起始地址</strong>，通过 Monitor 对象即可实现互斥访问同步代码，也就是通过阻塞唤醒的方式实现同步。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是 synchronized 的锁升级内容了，JDK 1.6 之后采用锁升级的方式来优化 synchronized 同步锁，提高了程序的运行效率。接下来总结一下偏向锁、轻量级锁、重量级锁三者的优缺点以及使用场景。</p><table><thead><tr><th><strong>锁类型</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td>偏向锁</td><td>只有一个线程访问同步代码时，只在置换ThreadID时进行一次CAS操作，锁的开销低，性能接近于无锁状态。</td><td>线程间存在竞争时，需要频繁暂停持有锁的线程并检查状态和撤销锁，反而带来额外的开销。</td></tr><tr><td>轻量级锁</td><td>线程间存在交替竞争时，竞争的线程不需要阻塞，提高了响应速度。</td><td>当大量线程存在竞争时，线程始终的抢占不到锁，会导致CPU空转消耗CPU性能。</td></tr><tr><td>重量级锁</td><td>通过阻塞唤醒的方式实现同步，防止CPU空转，不会消耗CPU性能。</td><td>线程阻塞导致响应时间变长，频繁切换CPU状态，导致性能消耗增大。</td></tr></tbody></table><p>根据三类锁的优缺点可以知道使用场景：</p><ul><li>偏向锁：<strong>适用于单线程的情况</strong>，在不存在锁竞争的时候进入同步代码可以使用偏向锁。</li><li>轻量级锁：<strong>适用于竞争较不激烈且同步代码执行时间较短的情况</strong>，存在竞争时升级为轻量级锁，轻量级锁采用的是自旋锁，采用轻量级锁虽然会占用cpu资源但是相对比使用重量级锁要更高效。</li><li>重量级锁：<strong>适用于竞争激烈且同步代码执行时间较长的情况</strong>，此时使用轻量级锁自旋带来的性能消耗就比使用重量级锁更严重，这时候就需要升级为重量级锁。</li></ul><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>JDK 1.6之后除了引入偏向锁、轻量级锁等针对于 synchronized 的锁优化之外，还引入了自适应自旋锁、锁消除、锁粗化等锁优化策略，接下来简单补充一下剩下的这三种锁优化策略。</p><h3 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a><strong>自适应自旋锁</strong></h3><p>JDK 1.6之前就已经引入了自旋锁的概念，为了避免阻塞和唤醒线程带来的时间开销，引入了自旋锁的概念，即没有抢占到锁的线程通过自旋的方式，<strong>不放弃 CPU 执行时间</strong>，等待持有锁的线程执行完后，继续抢占。对于锁占用时间很短的场景，采用自旋锁可以展现出很好的性能。</p><p><strong>为什么有了自旋锁还要引入自适应自旋锁呢？</strong></p><p>自旋锁的缺点在于面对锁占用时间长的场景，线程始终占用 CPU 的时间片，会导致浪费 CPU 资源的问题。因此自旋锁需要指定超过限定次数后仍然没有抢占到锁的线程，就应该使用传统方式挂起（阻塞）线程。JDK 1.6之前可以通过 <code>-XX:PreBlockSpin=10</code> 的方式配置自旋上限次数，默认是 10 次。</p><p>JDK 1.6之后引入了自适应自旋锁，也就无需再指定自旋上限次数，自适应自旋锁会通过前一次在同一个锁上的自旋时间及锁的持有者状态来决定。也就是如果在同一锁对象上，自旋等待在尝试几次后抢占到锁，那么 JVM 会认为该锁自旋抢占到锁的几率很大，会自动增大自旋的上限次数；如果自旋等待很少抢占到锁，那么 JVM 可能直接省略自旋过程，直接挂起线程。</p><p>所以也就是 JDK 1.6引入自适应自旋锁后，使得自旋上限次数变得更加准确，减少额外的 CPU 开销。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a><strong>锁消除</strong></h3><p>锁消除是 <strong>JVM 在 JIT 编译期间，通过对运行上下文的扫描，消除不可能存在共享资源竞争的锁</strong>。通过锁消除的优化可以节省非必要的抢占锁时间。</p><p>锁消除的优化依靠于<strong>逃逸分析</strong>的数据支持，JVM 会分析对象作用域，判断对象是否会逃逸，即在堆上的某个对象不会逃逸出去被其他线程访问，则可以把它当作栈上的数据看待，认为该数据是线程私有的，这样就没必要同步加锁了，则进行锁消除。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a><strong>锁粗化</strong></h3><p>锁粗化是<strong>把加锁的范围扩展（粗化）到整个操作序列的外部，这样加锁解锁的频率就会大大降低，从而减少了性能损耗</strong>。如果存在连串的一系列操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能操作，所以需要扩大（粗化）加锁范围使得降低加锁解锁的频率。</p><h1 id="原帖地址"><a href="#原帖地址" class="headerlink" title="原帖地址"></a>原帖地址</h1><p>作者：单程车票<br>链接：<a href="https://juejin.cn/post/7232524757526429756">https://juejin.cn/post/7232524757526429756</a><br>来源：稀土掘金</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中HashMap的长度为什么是2的幂次方</title>
    <link href="/2023/08/01/hashmap-length/"/>
    <url>/2023/08/01/hashmap-length/</url>
    
    <content type="html"><![CDATA[<h1 id="Java中HashMap的长度为什么是2的幂次方"><a href="#Java中HashMap的长度为什么是2的幂次方" class="headerlink" title="Java中HashMap的长度为什么是2的幂次方"></a>Java中HashMap的长度为什么是2的幂次方</h1><h2 id="计算下标"><a href="#计算下标" class="headerlink" title="计算下标"></a>计算下标</h2><p>为了让哈希值更加均匀地分布在哈希表中，Java中的HashMap实现使用了一个叫做“扰动函数”（hashing function）的方法，将输入的键值转换成一个哈希值，然后对这个值对对数组的长度取模运算，得到下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">i = (n - <span class="hljs-number">1</span>) &amp; hash <span class="hljs-comment">//n为hashmap的长度 i为下标</span><br></code></pre></td></tr></table></figure><p>取余(%)操作中如果<strong>除数是 2 的幂次</strong>则等价于<strong>与其除数减一的与(&amp;)操作</strong></p><p>所以如果hashmap的长度为 2 的幂次则上述代码等价于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">i = hash % n<br></code></pre></td></tr></table></figure><p>因为计算机中<strong>位运算非常快</strong>，所以让hashmap的大小为2的幂次方，可以用位运算代替取模操作，加快下标的计算速度</p><h2 id="为什么取余-操作中如果除数是-2-的幂次则等价于与其除数减一的与-amp-操作？"><a href="#为什么取余-操作中如果除数是-2-的幂次则等价于与其除数减一的与-amp-操作？" class="headerlink" title="为什么取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作？"></a>为什么取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作？</h2><p>2 的幂次-1可以表示为二进制中所有位数都是1的数</p><p>16-1 —&gt; 1111</p><p>8-1   —&gt;  111</p><p>取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作的原理就是将高位抛弃，低位留下。</p><p>以19 % 8 为例</p><p>19 —&gt; 10101</p><p>8-1 &#x3D; 7 —&gt; 111</p><p>10101</p><p>00111</p><p>与操作得 101 —&gt; 3          19 % 8 &#x3D; 3</p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AQS详解</title>
    <link href="/2023/07/27/AQS/"/>
    <url>/2023/07/27/AQS/</url>
    
    <content type="html"><![CDATA[<h1 id="AQS（AbstractQueuedSynchronizer）详解"><a href="#AQS（AbstractQueuedSynchronizer）详解" class="headerlink" title="AQS（AbstractQueuedSynchronizer）详解"></a>AQS（AbstractQueuedSynchronizer）详解</h1><p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。</p><h3 id="AQS-核心思想"><a href="#AQS-核心思想" class="headerlink" title="AQS 核心思想"></a>AQS 核心思想</h3><p>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><p><img src="/../img/AQS/AQS01.png" alt="AQS核心"></p><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。</p><p>先进先出队列存储的载体叫做Node节点，该节点标识着当前的状态值、是独占还是共享模式以及它的前驱和后继节点等等信息</p><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<span class="hljs-comment">//共享变量，使用volatile修饰保证线程可见性</span><br></code></pre></td></tr></table></figure><p>状态信息通过procted类型的getState，setState，compareAndSetState进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回同步状态的当前值</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> state;<br>&#125;<br> <span class="hljs-comment">// 设置同步状态的值</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> newState)</span> &#123; <br>        state = newState;<br>&#125;<br><span class="hljs-comment">//原子地(CAS操作)将同步状态值设置为给定值update如果当前同步状态的值等于expect(期望值)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>        <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h3><p>AQS定义两种资源共享方式</p><ul><li>Exclusive(独占)：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁： <ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li>Share(共享)：多个线程可同时执行，如Semaphore&#x2F;CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li></ul><p>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p><h3 id="AQS底层使用了模板方法模式"><a href="#AQS底层使用了模板方法模式" class="headerlink" title="AQS底层使用了模板方法模式"></a>AQS底层使用了模板方法模式</h3><p>使用者继承AbstractQueuedSynchronizer并重写指定的方法。(这些重写方法很简单，无非是对于共享资源state的获取和释放) 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</p><p>自定义同步器时需要重写下面几个AQS提供的模板方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">isHeldExclusively()<span class="hljs-comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br>tryAcquire(<span class="hljs-type">int</span>)<span class="hljs-comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br>tryRelease(<span class="hljs-type">int</span>)<span class="hljs-comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br>tryAcquireShared(<span class="hljs-type">int</span>)<span class="hljs-comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br>tryReleaseShared(<span class="hljs-type">int</span>)<span class="hljs-comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span><br></code></pre></td></tr></table></figure><p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0(即释放锁)为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的(state会累加)，这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><h2 id="AbstractQueuedSynchronizer数据结构"><a href="#AbstractQueuedSynchronizer数据结构" class="headerlink" title="AbstractQueuedSynchronizer数据结构"></a>AbstractQueuedSynchronizer数据结构</h2><p>AbstractQueuedSynchronizer类底层的数据结构是使用<code>CLH(Craig,Landin,and Hagersten)队列</code>是一个虚拟的双向队列(虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。其中Sync queue，即同步队列，是双向链表，包括head结点和tail结点，head结点主要用作后续的调度。而Condition queue不是必须的，其是一个单向链表，只有当使用Condition时，才会存在此单向链表。并且可能会有多个Condition queue。</p><p><img src="/../img/AQS/AQS02.png" alt="AQS-CLH"></p><h2 id="以ReentrantLock来讲讲加锁和解锁的过程"><a href="#以ReentrantLock来讲讲加锁和解锁的过程" class="headerlink" title="以ReentrantLock来讲讲加锁和解锁的过程"></a><strong>以ReentrantLock来讲讲加锁和解锁的过程</strong></h2><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><ol><li><p>CAS尝试获取锁，获取成功则可以执行同步代码</p></li><li><p>CAS获取失败，则调用acquire方法，acquire方法实际上就是AQS的模板方法</p></li><li><p>acquire首先会调用子类的tryAcquire方法（又回到了ReentrantLock中）</p></li><li><p>tryAcquire方法实际上会判断当前的state是否等于0，等于0说明没有线程持有锁，则又尝试CAS直接获取锁</p></li><li><p>如果CAS获取成功，则可以执行同步代码</p></li><li><p>如果CAS获取失败，那判断当前线程是否就持有锁，如果是持有的锁，那更新state的值，获取得到锁（这里其实就是处理可重入的逻辑）</p></li><li><p>CAS失败&amp;&amp;非重入的情况，则回到tryAcquire方法执行「入队列」的操作</p></li><li><p>将节点入队列之后，会判断「前驱节点」是不是头节点，如果是头结点又会用CAS尝试获取锁</p></li><li><p>如果是「前驱节点」是头节点并获取得到锁，则把当前节点设置为头结点，并且将前驱节点置空（实际上就是原有的头节点已经释放锁了）</p></li><li><p>没获取得到锁，则判断前驱节点的状态是否为SIGNAL，如果不是，则找到合法的前驱节点，并使用CAS将状态设置为SIGNAL</p></li><li><p>最后调用park将当前线程挂起</p></li></ol><p><img src="/../img/AQS/AQS03.jpg" alt="加锁"></p><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><ol><li>外界调用unlock方法时，实际上会调用AQS的release方法，而release方法会调用子类tryRelease方法（又回到了ReentrantLock中）</li><li>tryRelease会把state一直减（锁重入可使state&gt;1），直至到0，当前线程说明已经把锁释放了</li><li>随后从队尾往前找节点状态需要 &lt; 0，并离头节点最近的节点进行唤醒</li><li>唤醒之后，被唤醒的线程则尝试使用CAS获取锁，假设获取锁得到则把头节点给干掉，把自己设置为头节点</li></ol><p>解锁的逻辑非常简单，把state置0，唤醒头结点下一个合法的节点，被唤醒的节点线程自然就会去获取锁</p><p>为什么要设置前驱节点为SIGNAL状态？</p><p>Node 中节点的状态有4种，分别是：CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)和0</p><p>在ReentrantLock解锁的时候，会判断节点的状态是否小于0，小于等于0才说明需要被唤醒</p><p><img src="/../img/AQS/AQS04.jpg" alt="加锁解锁"></p><h2 id="AbstractQueuedSynchronizer源码分析"><a href="#AbstractQueuedSynchronizer源码分析" class="headerlink" title="AbstractQueuedSynchronizer源码分析"></a>AbstractQueuedSynchronizer源码分析</h2><p>AbstractQueuedSynchronizer继承自AbstractOwnableSynchronizer抽象类，并且实现了Serializable接口，可以进行序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable<br></code></pre></td></tr></table></figure><p>其中AbstractOwnableSynchronizer抽象类的源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;<br>    <br>    <span class="hljs-comment">// 版本序列号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">3737899427754241961L</span>;<br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractOwnableSynchronizer</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-comment">// 独占模式下的线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread;<br>    <br>    <span class="hljs-comment">// 设置独占线程 </span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setExclusiveOwnerThread</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        exclusiveOwnerThread = thread;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 获取独占线程 </span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Thread <span class="hljs-title function_">getExclusiveOwnerThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> exclusiveOwnerThread;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractOwnableSynchronizer抽象类中，可以设置独占资源线程和获取独占资源线程。分别为setExclusiveOwnerThread与getExclusiveOwnerThread方法，这两个方法会被子类调用。</p><p>AbstractQueuedSynchronizer类有两个内部类，分别为Node类与ConditionObject类。</p><h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-comment">// 模式，分为共享与独占</span><br>    <span class="hljs-comment">// 共享模式</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>    <span class="hljs-comment">// 独占模式</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;        <br>    <span class="hljs-comment">// 结点状态</span><br>    <span class="hljs-comment">// CANCELLED，值为1，表示当前的线程被取消</span><br>    <span class="hljs-comment">// SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark</span><br>    <span class="hljs-comment">// CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中</span><br>    <span class="hljs-comment">// PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行</span><br>    <span class="hljs-comment">// 值为0，表示当前节点在sync队列中，等待着获取锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;        <br><br>    <span class="hljs-comment">// 结点状态</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;        <br>    <span class="hljs-comment">// 前驱结点</span><br>    <span class="hljs-keyword">volatile</span> Node prev;    <br>    <span class="hljs-comment">// 后继结点</span><br>    <span class="hljs-keyword">volatile</span> Node next;        <br>    <span class="hljs-comment">// 结点所对应的线程</span><br>    <span class="hljs-keyword">volatile</span> Thread thread;        <br>    <span class="hljs-comment">// 下一个等待者</span><br>    Node nextWaiter;<br>    <br>    <span class="hljs-comment">// 结点是否在共享模式下等待</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShared</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> nextWaiter == SHARED;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 获取前驱结点，若前驱结点为空，抛出异常</span><br>    <span class="hljs-keyword">final</span> Node <span class="hljs-title function_">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException &#123;<br>        <span class="hljs-comment">// 保存前驱结点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> prev; <br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span>) <span class="hljs-comment">// 前驱结点为空，抛出异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 前驱结点不为空，返回</span><br>            <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 无参构造方法</span><br>    Node() &#123;    <span class="hljs-comment">// Used to establish initial head or SHARED marker</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 构造方法</span><br>        Node(Thread thread, Node mode) &#123;    <span class="hljs-comment">// Used by addWaiter</span><br>        <span class="hljs-built_in">this</span>.nextWaiter = mode;<br>        <span class="hljs-built_in">this</span>.thread = thread;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 构造方法</span><br>    Node(Thread thread, <span class="hljs-type">int</span> waitStatus) &#123; <span class="hljs-comment">// Used by Condition</span><br>        <span class="hljs-built_in">this</span>.waitStatus = waitStatus;<br>        <span class="hljs-built_in">this</span>.thread = thread;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个线程被阻塞的线程都会被封装成一个Node结点，放入队列。每个节点包含了一个Thread类型的引用，并且每个节点都存在一个状态，具体状态如下。</p><ul><li><code>CANCELLED</code>，值为1，表示当前的线程被取消。</li><li><code>SIGNAL</code>，值为-1，表示当前节点的后继节点包含的线程需要运行，需要进行unpark操作。</li><li><code>CONDITION</code>，值为-2，表示当前节点在等待condition，也就是在condition queue中。</li><li><code>PROPAGATE</code>，值为-3，表示当前场景下后续的acquireShared能够得以执行。</li><li>值为0，表示当前节点在sync queue中，等待着获取锁。</li></ul><h3 id="类的属性"><a href="#类的属性" class="headerlink" title="类的属性"></a>类的属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable &#123;    <br>    <span class="hljs-comment">// 版本号</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">7373984972572414691L</span>;    <br>    <span class="hljs-comment">// 头节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;    <br>    <span class="hljs-comment">// 尾结点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;    <br>    <span class="hljs-comment">// 状态</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;    <br>    <span class="hljs-comment">// 自旋时间</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">spinForTimeoutThreshold</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000L</span>;<br>    <br>    <span class="hljs-comment">// Unsafe类实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br>    <span class="hljs-comment">// state内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> stateOffset;<br>    <span class="hljs-comment">// head内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> headOffset;<br>    <span class="hljs-comment">// state内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> tailOffset;<br>    <span class="hljs-comment">// tail内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> waitStatusOffset;<br>    <span class="hljs-comment">// next内存偏移地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> nextOffset;<br>    <span class="hljs-comment">// 静态初始化块</span><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            stateOffset = unsafe.objectFieldOffset<br>                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;state&quot;</span>));<br>            headOffset = unsafe.objectFieldOffset<br>                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;head&quot;</span>));<br>            tailOffset = unsafe.objectFieldOffset<br>                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;tail&quot;</span>));<br>            waitStatusOffset = unsafe.objectFieldOffset<br>                (Node.class.getDeclaredField(<span class="hljs-string">&quot;waitStatus&quot;</span>));<br>            nextOffset = unsafe.objectFieldOffset<br>                (Node.class.getDeclaredField(<span class="hljs-string">&quot;next&quot;</span>));<br><br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(ex); &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类的核心方法-acquire方法"><a href="#类的核心方法-acquire方法" class="headerlink" title="类的核心方法 - acquire方法"></a>类的核心方法 - acquire方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/AQS/AQS05.png" alt="acquire"></p><p>首先调用tryAcquire方法，调用此方法的线程会试图在独占模式下获取对象状态。此方法应该查询是否允许它在独占模式下获取对象状态，如果允许，则获取它。在AbstractQueuedSynchronizer源码中默认会抛出一个异常，即需要子类去重写此方法完成自己的逻辑。之后会进行分析。</p><p>若tryAcquire失败，则调用addWaiter方法，addWaiter方法完成的功能是将调用此方法的线程封装成为一个结点并放入Sync queue。</p><p>调用acquireQueued方法，此方法完成的功能是Sync queue中的结点不断尝试获取资源，若成功，则返回true，否则，返回false。</p><p>由于tryAcquire默认实现是抛出异常，所以此时，不进行分析，之后会结合一个例子进行分析。</p><h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">// 新生成一个结点，默认为独占模式</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    <span class="hljs-comment">// 保存尾结点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 尾结点不为空，即已经被初始化</span><br>        <span class="hljs-comment">// 将node结点的prev域连接到尾结点</span><br>        node.prev = pred; <br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="hljs-comment">// 比较pred是否为尾结点，是则将尾结点设置为node </span><br>            <span class="hljs-comment">// 设置尾结点的next域为node</span><br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node; <span class="hljs-comment">// 返回新生成的结点</span><br>        &#125;<br>    &#125;<br>    enq(node); <span class="hljs-comment">// 尾结点为空(即还没有被初始化过)，或者是compareAndSetTail操作失败，则入队列</span><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><p>addWaiter方法使用快速添加的方式往sync queue尾部添加结点，如果sync queue队列还没有初始化，则会使用enq插入队列中，enq方法源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 无限循环，确保结点能够成功入队列</span><br>        <span class="hljs-comment">// 保存尾结点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// 尾结点为空，即还没被初始化</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>())) <span class="hljs-comment">// 头节点为空，并设置头节点为新生成的结点</span><br>                tail = head; <span class="hljs-comment">// 头节点与尾结点都指向同一个新生结点</span><br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 尾结点不为空，即已经被初始化过</span><br>            <span class="hljs-comment">// 将node结点的prev域连接到尾结点</span><br>            node.prev = t; <br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="hljs-comment">// 比较结点t是否为尾结点，若是则将尾结点设置为node</span><br>                <span class="hljs-comment">// 设置尾结点的next域为node</span><br>                t.next = node; <br>                <span class="hljs-keyword">return</span> t; <span class="hljs-comment">// 返回尾结点</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>enq方法会使用无限循环来确保节点的成功插入。</p><h4 id="acquireQueue"><a href="#acquireQueue" class="headerlink" title="acquireQueue"></a>acquireQueue</h4><p>现在，分析acquireQueue方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sync队列中的结点在独占且忽略中断的模式下获取(资源)</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 标志</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 中断标志</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123; <span class="hljs-comment">// 无限循环</span><br>            <span class="hljs-comment">// 获取node节点的前驱结点</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor(); <br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="hljs-comment">// 前驱为头节点并且成功获得锁</span><br>                setHead(node); <span class="hljs-comment">// 设置头节点</span><br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 设置标志</span><br>                <span class="hljs-keyword">return</span> interrupted; <br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先获取当前节点的前驱节点，如果前驱节点是头节点并且能够获取(资源)，代表该当前节点能够占有锁，设置头节点为当前节点，返回。否则，调用shouldParkAfterFailedAcquire和parkAndCheckInterrupt方法，首先，我们看shouldParkAfterFailedAcquire方法，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当获取(资源)失败后，检查并且更新结点状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-comment">// 获取前驱结点的状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) <span class="hljs-comment">// 状态为SIGNAL，为-1</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            * This node has already set status asking a release</span><br><span class="hljs-comment">            * to signal it, so it can safely park.</span><br><span class="hljs-comment">            */</span><br>        <span class="hljs-comment">// 可以进行park操作</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 表示状态为CANCELLED，为1</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            * Predecessor was cancelled. Skip over predecessors and</span><br><span class="hljs-comment">            * indicate retry.</span><br><span class="hljs-comment">            */</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>); <span class="hljs-comment">// 找到pred结点前面最近的一个状态不为CANCELLED的结点</span><br>        <span class="hljs-comment">// 赋值pred结点的next域</span><br>        pred.next = node; <br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 为PROPAGATE -3 或者是0 表示无状态,(为CONDITION -2时，表示此节点在condition queue中) </span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="hljs-comment">            * need a signal, but don&#x27;t park yet.  Caller will need to</span><br><span class="hljs-comment">            * retry to make sure it cannot acquire before parking.</span><br><span class="hljs-comment">            */</span><br>        <span class="hljs-comment">// 比较并设置前驱结点的状态为SIGNAL</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <br>    &#125;<br>    <span class="hljs-comment">// 不能进行park操作</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>只有当该节点的前驱结点的状态为SIGNAL时，才可以对该结点所封装的线程进行park操作。否则，将不能进行park操作。再看parkAndCheckInterrupt方法，源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 进行park操作并且返回该线程是否被中断</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 在许可可用之前禁用当前线程，并且设置了blocker</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> Thread.interrupted(); <span class="hljs-comment">// 当前线程是否已被中断，并清除中断标记位</span><br>&#125;<br></code></pre></td></tr></table></figure><p>parkAndCheckInterrupt方法里的逻辑是首先执行park操作，即禁用当前线程，然后返回该线程是否已经被中断。再看final块中的cancelAcquire方法，其源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 取消继续获取(资源)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelAcquire</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// Ignore if node doesn&#x27;t exist</span><br>    <span class="hljs-comment">// node为空，返回</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 设置node结点的thread为空</span><br>    node.thread = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// Skip cancelled predecessors</span><br>    <span class="hljs-comment">// 保存node的前驱结点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> node.prev;<br>    <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 找到node前驱结点中第一个状态小于0的结点，即不为CANCELLED状态的结点</span><br>        node.prev = pred = pred.prev;<br><br>    <span class="hljs-comment">// predNext is the apparent node to unsplice. CASes below will</span><br>    <span class="hljs-comment">// fail if not, in which case, we lost race vs another cancel</span><br>    <span class="hljs-comment">// or signal, so no further action is necessary.</span><br>    <span class="hljs-comment">// 获取pred结点的下一个结点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">predNext</span> <span class="hljs-operator">=</span> pred.next;<br><br>    <span class="hljs-comment">// Can use unconditional write instead of CAS here.</span><br>    <span class="hljs-comment">// After this atomic step, other Nodes can skip past us.</span><br>    <span class="hljs-comment">// Before, we are free of interference from other threads.</span><br>    <span class="hljs-comment">// 设置node结点的状态为CANCELLED</span><br>    node.waitStatus = Node.CANCELLED;<br><br>    <span class="hljs-comment">// If we are the tail, remove ourselves.</span><br>    <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; <span class="hljs-comment">// node结点为尾结点，则设置尾结点为pred结点</span><br>        <span class="hljs-comment">// 比较并设置pred结点的next节点为null</span><br>        compareAndSetNext(pred, predNext, <span class="hljs-literal">null</span>); <br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// node结点不为尾结点，或者比较设置不成功</span><br>        <span class="hljs-comment">// If successor needs signal, try to set pred&#x27;s next-link</span><br>        <span class="hljs-comment">// so it will get one. Otherwise wake it up to propagate.</span><br>        <span class="hljs-type">int</span> ws;<br>        <span class="hljs-keyword">if</span> (pred != head &amp;&amp;<br>            ((ws = pred.waitStatus) == Node.SIGNAL ||<br>                (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;<br>            pred.thread != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// (pred结点不为头节点，并且pred结点的状态为SIGNAL)或者 </span><br>                                <span class="hljs-comment">// pred结点状态小于等于0，并且比较并设置等待状态为SIGNAL成功，并且pred结点所封装的线程不为空</span><br>            <span class="hljs-comment">// 保存结点的后继</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;<br>            <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>) <span class="hljs-comment">// 后继不为空并且后继的状态小于等于0</span><br>                compareAndSetNext(pred, predNext, next); <span class="hljs-comment">// 比较并设置pred.next = next;</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            unparkSuccessor(node); <span class="hljs-comment">// 释放node的前一个结点</span><br>        &#125;<br><br>        node.next = node; <span class="hljs-comment">// help GC</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法完成的功能就是取消当前线程对资源的获取，即设置该结点的状态为CANCELLED，接着我们再看unparkSuccessor方法，源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 释放后继结点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * If status is negative (i.e., possibly needing signal) try</span><br><span class="hljs-comment">        * to clear in anticipation of signalling.  It is OK if this</span><br><span class="hljs-comment">        * fails or if status is changed by waiting thread.</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-comment">// 获取node结点的等待状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 状态值小于0，为SIGNAL -1 或 CONDITION -2 或 PROPAGATE -3</span><br>        <span class="hljs-comment">// 比较并且设置结点等待状态，设置为0</span><br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        * Thread to unpark is held in successor, which is normally</span><br><span class="hljs-comment">        * just the next node.  But if cancelled or apparently null,</span><br><span class="hljs-comment">        * traverse backwards from tail to find the actual</span><br><span class="hljs-comment">        * non-cancelled successor.</span><br><span class="hljs-comment">        */</span><br>    <span class="hljs-comment">// 获取node节点的下一个结点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 下一个结点为空或者下一个节点的等待状态大于0，即为CANCELLED</span><br>        <span class="hljs-comment">// s赋值为空</span><br>        s = <span class="hljs-literal">null</span>; <br>        <span class="hljs-comment">// 从尾结点开始从后往前开始遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>) <span class="hljs-comment">// 找到等待状态小于等于0的结点，找到最前的状态小于等于0的结点</span><br>                <span class="hljs-comment">// 保存结点</span><br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>) <span class="hljs-comment">// 该结点不为为空，释放许可</span><br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法的作用就是为了释放node节点的后继结点。</p><p>acquireQueued方法的整个的如下</p><ul><li>判断结点的前驱是否为head并且是否成功获取(资源)。</li><li>若步骤1均满足，则设置结点为head，之后会判断是否finally模块，然后返回。</li><li>若步骤2不满足，则判断是否需要park当前线程，是否需要park当前线程的逻辑是判断结点的前驱结点的状态是否为SIGNAL，若是，则park当前结点，否则，不进行park操作。</li><li>若park了当前线程，之后某个线程对本线程unpark后，并且本线程也获得机会运行。那么，将会继续进行步骤①的判断。</li></ul><h3 id="release方法"><a href="#release方法" class="headerlink" title="release方法"></a>release方法</h3><p>以独占模式释放对象，其源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123; <span class="hljs-comment">// 释放成功</span><br>        <span class="hljs-comment">// 保存头节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>) <span class="hljs-comment">// 头节点不为空并且头节点状态不为0</span><br>            unparkSuccessor(h); <span class="hljs-comment">//释放头节点的后继结点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，tryRelease的默认实现是抛出异常，需要具体的子类实现，如果tryRelease成功，那么如果头节点不为空并且头节点的状态不为0，则释放头节点的后继结点，unparkSuccessor方法已经分析过，不再累赘。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html">https://www.pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>负载均衡算法</title>
    <link href="/2023/07/26/load-balance/"/>
    <url>/2023/07/26/load-balance/</url>
    
    <content type="html"><![CDATA[<h1 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h1><p>目前负载均衡算法主要分为两类：</p><ul><li><strong>静态负载均衡算法</strong>：以固定的概率分配任务，不考虑服务器的状态信息，如：轮询法、加权轮询法、随机法、加权随机法等。</li><li><strong>动态负载均衡算法</strong>：以服务器的实时负载状态信息来决定任务的分配，如：最小连接法、加权最小连接数法等。</li></ul><h2 id="1-轮询（Round-Robin）法"><a href="#1-轮询（Round-Robin）法" class="headerlink" title="1. 轮询（Round Robin）法"></a>1. 轮询（Round Robin）法</h2><p>轮询法，就是将用户的请求轮流分配给服务器，比如有10台服务器，从第1台开始分配，每次有请求进来，就分配到下一台服务器。这种算法比较简单，具有绝对均衡的优点，但是也正是因为绝对均衡，因此它无法保证分配任务的合理性，无法根据服务器承受能力来分配任务。</p><p>轮询法适用于机器性能都在同一水平的服务，一旦某台机器性能不好，极有可能产生木桶效应，性能差的机器扛不住更多的流量。</p><h2 id="2-随机（Random）法"><a href="#2-随机（Random）法" class="headerlink" title="2. 随机（Random）法"></a>2. 随机（Random）法</h2><p>随机法，是随机选择一台服务器来分配任务。它保证了请求的分散性达到了均衡的目的。同时它是没有状态的不需要维持上次的选择状态和均衡因子。但是随着任务量的增大，它的效果趋向轮询后也会具有轮询算法的部分缺点。</p><p>同样地，它也不适用于机器性能有差异的分布式系统。</p><h2 id="3-加权轮询（Weight-Round-Robin）法"><a href="#3-加权轮询（Weight-Round-Robin）法" class="headerlink" title="3. 加权轮询（Weight Round Robin）法"></a>3. 加权轮询（Weight Round Robin）法</h2><p>不同的后台服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不一样。跟配置高、负载低的机器分配更高的权重，使其能处理更多的请求，而配置低、负载高的机器，则给其分配较低的权重，降低其系统负载，加权轮询很好的处理了这一问题，并将请求按照顺序且根据权重分配给后端。Nginx的负载均衡默认算法是加权轮询算法。</p><p>有三个节点{a, b, c}，他们的权重分别是{a&#x3D;5, b&#x3D;1, c&#x3D;1}。发送7次请求，a会被分配5次，b会被分配1次，c会被分配1次。</p><h3 id="一般算法"><a href="#一般算法" class="headerlink" title="一般算法"></a>一般算法</h3><p>1、轮训所有节点，找到一个最大权重节点；<br>2、选中的节点权重-1；<br>3、直到减到0，恢复该节点原始权重，继续轮询；</p><p>这样的算法看起来简单，最终效果是：{a, a, a, a, a, b, c}，即前5次可能选中的都是a，这可能造成权重大的服务器造成过大压力的同时，小权重服务器还很闲。<br>Nginx的加权轮询算法将保持选择的平滑性，希望达到的效果可能是{a, b, a, a, c, a, a}，即尽可能均匀的分摊节点，节点分配不再是连续的。</p><h3 id="Nginx加权轮询"><a href="#Nginx加权轮询" class="headerlink" title="Nginx加权轮询"></a>Nginx加权轮询</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>weight: 约定权重，即在配置文件或初始化时约定好的每个节点的权重。</p><p>effectiveWeight: 有效权重，初始化为weight。在通讯过程中发现节点异常，则-1；之后再次选取本节点，调用成功一次则+1，直到恢复到weight；此变量的作用主要是节点异常，降低其权重。</p><p>currentWeight: 节点当前权重，初始化为0。</p><h4 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h4><ol><li>轮询所有节点，计算当前状态下所有节点的effectiveWeight之和totalWeight；</li><li>currentWeight &#x3D; currentWeight + effectiveWeight; 选出所有节点中currentWeight中最大的一个节点作为选中节点；</li><li>选中节点的currentWeight &#x3D; currentWeight - totalWeight；</li></ol><p>这时有三个节点{a, b, c}，权重分别是{a&#x3D;4, b&#x3D;2, c&#x3D;1}，共7次请求，初始currentWeight值为{0, 0, 0}, totalWeight &#x3D; 7，每次分配后的结果如下</p><table><thead><tr><th>序号</th><th>请求前currentWeight</th><th>选中节点</th><th>请求后currentWeight</th></tr></thead><tbody><tr><td>1</td><td>{a &#x3D; 4, b &#x3D;2 , c &#x3D; 1}</td><td>a</td><td>{a &#x3D; -3, b &#x3D; 2, c &#x3D; 1}</td></tr><tr><td>2</td><td>{a &#x3D; 1, b &#x3D; 4, c &#x3D; 2}</td><td>b</td><td>{a &#x3D; 1, b &#x3D; -3, c &#x3D; 2}</td></tr><tr><td>3</td><td>{a &#x3D;5, b &#x3D; -1, c &#x3D; 3}</td><td>a</td><td>{a &#x3D; -2, b &#x3D; -1, c &#x3D; 3}</td></tr><tr><td>4</td><td>{a &#x3D; 2, b &#x3D; 1, c &#x3D; 4}</td><td>c</td><td>{a &#x3D; 2, b &#x3D; 1, c &#x3D; -3}</td></tr><tr><td>5</td><td>{a &#x3D; 6, b &#x3D; 3, c &#x3D; -2}</td><td>a</td><td>{a &#x3D; -1, b &#x3D; 3, c &#x3D; -2}</td></tr><tr><td>6</td><td>{a &#x3D; 3, b &#x3D; 5, c &#x3D; -1}</td><td>b</td><td>{a &#x3D; 3, b &#x3D; -2, c &#x3D; -1}</td></tr><tr><td>7</td><td>{a &#x3D; 7, b &#x3D; 0, c &#x3D; 0}</td><td>a</td><td>{a &#x3D; 0, b &#x3D; 0, c &#x3D; 0}</td></tr></tbody></table><p>观察到七次调用选中的节点顺序为{a, b, a, c, a, b, a}，a节点选中4次，b节点选中2次，c节点选中1次，算法保持了currentWeight值从初始值{c&#x3D;0,b&#x3D;0,a&#x3D;0}到7次调用后又回到{c&#x3D;0,b&#x3D;0,a&#x3D;0}。</p><h2 id="4-加权随机（Weight-Random）法"><a href="#4-加权随机（Weight-Random）法" class="headerlink" title="4.加权随机（Weight Random）法"></a>4.加权随机（Weight Random）法</h2><p>加权随机法跟加权轮询法类似，根据后台服务器不同的配置和负载情况，配置不同的权重。不同的是，它是按照权重来随机选取服务器的，而非顺序。</p><h2 id="5-最小连接数法"><a href="#5-最小连接数法" class="headerlink" title="5.最小连接数法"></a>5.最小连接数法</h2><p>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。</p><h2 id="6-源地址哈希法"><a href="#6-源地址哈希法" class="headerlink" title="6.源地址哈希法"></a>6.源地址哈希法</h2><p>源地址哈希法的思想是根据服务消费者请求客户端的IP地址，通过哈希函数计算得到一个哈希值，将此哈希值和服务器列表的大小进行取模运算，得到的结果便是要访问的服务器地址的序号。采用源地址哈希法进行负载均衡，相同的IP客户端，如果服务器列表不变，将映射到同一个后台服务器进行访问。该方法适合访问缓存系统，如果为了增强缓存的命中率和单调性，可以用一致性哈希算法</p>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Bean的生命周期</title>
    <link href="/2023/07/25/bean-lifecycle/"/>
    <url>/2023/07/25/bean-lifecycle/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h1><h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><p>bean的生命周期大致分为以下阶段</p><ol><li>构造函数</li><li>依赖注入</li><li>调用Aware接口</li><li>前置处理postProcessBeforeInitialzation</li><li>自定义初始化方法 init-method</li><li>后置处理postProcessAfterInitialization</li><li>销毁destory-method</li></ol><h2 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h2><p><img src="/../img/bean-lifecycle/bean-lifecycle.png" alt="bean的生命周期"></p><ul><li><p>如果 BeanFactoryPostProcessor 和 Bean 关联, 则调用postProcessBeanFactory方法.(即首<strong>先尝试从Bean工厂中获取Bean</strong>)</p></li><li><p>如果 InstantiationAwareBeanPostProcessor 和 Bean 关联，则调用postProcessBeforeInstantiation方法</p></li><li><p>根据配置情况调用 Bean 构造方法<strong>实例化 Bean</strong>。</p></li><li><p>利用依赖注入完成 Bean 中所有<strong>属性值的配置注入</strong>。</p></li><li><p>如果 InstantiationAwareBeanPostProcessor 和 Bean 关联，则调用postProcessAfterInstantiation方法和postProcessProperties</p></li><li><p><strong>调用xxxAware接口</strong>(如果Bean 实现了接口)</p></li><li><p>如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的预初始化方法 postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。</p></li><li><p>如果 Bean 实现了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet() 方法。(或者有执行@PostConstruct注解的方法)</p></li><li><p>如果在配置文件中通过 <strong>init-method</strong> 属性指定了初始化方法，则调用该初始化方法。</p></li><li><p>如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法 postProcessAfterInitialization()。此时，Bean 已经可以被应用系统使用了。</p></li><li><p>如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory() 方法将 Spring 中的 Bean 销毁；(或者有执行@PreDestroy注解的方法)</p></li><li><p>如果在配置文件中通过 <strong>destory-method</strong> 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot启动流程</title>
    <link href="/2023/07/20/SpringBoot-boot/"/>
    <url>/2023/07/20/SpringBoot-boot/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot的启动流程"><a href="#SpringBoot的启动流程" class="headerlink" title="SpringBoot的启动流程"></a>SpringBoot的启动流程</h1><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>首先，Spring Boot项目创建完成会默认生成一个名为 **Application 的入口类，我们是通过该类的main方法启动Spring Boot项目的。在main方法中，通过SpringApplication的静态方法，即run方法进行SpringApplication类的实例化操作，然后再针对实例化对象调用另外一个run方法来完成整个项目的初始化和启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PlaygroundApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(PlaygroundApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;<br><span class="hljs-keyword">return</span> run(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[] &#123; primarySource &#125;, args);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplication</span>(primarySources).run(args);<br>&#125;<br></code></pre></td></tr></table></figure><p>run方法里主要干了两件事：</p><ol><li>构造SpringApplection的实例</li><li>调用实例的run方法</li></ol><h3 id="构造SpringApplication的实例"><a href="#构造SpringApplication的实例" class="headerlink" title="构造SpringApplication的实例"></a>构造SpringApplication的实例</h3><p>构造SpringApplication的实例过程主要干了下面几件事：</p><p>把参数sources设置到SpringApplication属性中，这个sources可以是任何类型的参数<br>获取应用类型，判断是否是web程序，并设置到webEnvironment的boolean属性中<br>创建并初始化ApplicationInitializer（初始化器），设置到initializers属性中<br>创建并初始化ApplicationListener（监听器），设置到listeners属性中<br>初始化主类mainApplectionClass，定位main方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">SpringApplication</span><span class="hljs-params">(Class&lt;?&gt;... primarySources)</span> &#123;<br><span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>, primarySources);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;<br>   <span class="hljs-comment">//resourceLoader赋值为Null</span><br>   <span class="hljs-built_in">this</span>.resourceLoader = resourceLoader;<br>   <span class="hljs-comment">//primarySources不为空，继续向下执行。为空抛异常</span><br>   Assert.notNull(primarySources, <span class="hljs-string">&quot;PrimarySources must not be null&quot;</span>);<br>   <span class="hljs-comment">//将SpringbootdemoApplication（启动类）赋值给primarySources </span><br>   <span class="hljs-built_in">this</span>.primarySources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));<br>   <span class="hljs-comment">//从classpath类路径推断Web应用类型，有三种Web应用类型，分别是</span><br>   <span class="hljs-comment">//NONE: 该应用程序不应作为 Web 应用程序运行，也不应启动嵌入式 Web 服务器</span><br>   <span class="hljs-comment">//SERVLET: 该应用程序应作为基于 servlet 的 Web 应用程序运行，并应启动嵌入式 servlet Web 服务器。</span><br>   <span class="hljs-comment">//REACTIVE: 该应用程序应作为响应式 Web 应用程序运行，并应启动嵌入式响应式 Web 服务器</span><br>   <span class="hljs-built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();<br>   <span class="hljs-comment">//初始化bootstrapRegistryInitializers，通过getSpringFactoriesInstances（）获取工厂实例，</span><br>   <span class="hljs-comment">//底层使用的是反射Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader)动态加载实例对象。</span><br>   <span class="hljs-built_in">this</span>.bootstrapRegistryInitializers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<br>         getSpringFactoriesInstances(BootstrapRegistryInitializer.class));<br>   <span class="hljs-comment">//初始化ApplicationContextInitializer集合</span><br>   setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));<br>   <span class="hljs-comment">//初始化ApplicationListener</span><br>   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));<br>   <span class="hljs-comment">//获取StackTraceElement数组遍历，通过反射获取堆栈中有main方法的类。</span><br>   <span class="hljs-built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>创建了SpringApplication实例之后，就完成了SpringApplication类的初始化工作，这个实例里包括监听器、初始化器，项目应用类型，启动类集合，类加载器。</p><h3 id="创建ApplicationContext"><a href="#创建ApplicationContext" class="headerlink" title="创建ApplicationContext"></a>创建ApplicationContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> &#123;<br>   <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.nanoTime();<br>   <span class="hljs-comment">//通过BootstrapRegistryInitializer来initialize默认的DefaultBootstrapContext</span><br>   <span class="hljs-type">DefaultBootstrapContext</span> <span class="hljs-variable">bootstrapContext</span> <span class="hljs-operator">=</span> createBootstrapContext();<br>   <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   <span class="hljs-comment">//配置java.awt.headless属性</span><br>   configureHeadlessProperty();<br>   <span class="hljs-comment">//获取SpringApplicationRunListeners监听器</span><br>   <span class="hljs-type">SpringApplicationRunListeners</span> <span class="hljs-variable">listeners</span> <span class="hljs-operator">=</span> getRunListeners(args);<br>   <span class="hljs-comment">//启动SpringApplicationRunListeners监听，表示SpringApplication启动（触发ApplicationStartingEvent事件）</span><br>   listeners.starting(bootstrapContext, <span class="hljs-built_in">this</span>.mainApplicationClass);<br>   <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//创建ApplicationArguments对象，封装了args参数</span><br>      <span class="hljs-type">ApplicationArguments</span> <span class="hljs-variable">applicationArguments</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultApplicationArguments</span>(args);<br>      <span class="hljs-comment">//做相关环境准备，绑定到SpringApplication,返回可配置环境对象ConfigurableEnvironment </span><br>      <span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> prepareEnvironment(listeners, bootstrapContext, applicationArguments);<br>      <span class="hljs-comment">//配置spring.beaninfo.ignore，设置为true.即跳过搜索Bean信息</span><br>      configureIgnoreBeanInfo(environment);<br>      <span class="hljs-comment">//控制台打印SpringBoot的Banner（横幅）标志</span><br>      <span class="hljs-type">Banner</span> <span class="hljs-variable">printedBanner</span> <span class="hljs-operator">=</span> printBanner(environment);<br>      <span class="hljs-comment">//根据WebApplicationType从ApplicationContextFactory工厂创建ConfigurableApplicationContext</span><br>      context = createApplicationContext();<br>      <span class="hljs-comment">//设置ConfigurableApplicationContext中的ApplicationStartup为DefaultApplicationStartup</span><br>      context.setApplicationStartup(<span class="hljs-built_in">this</span>.applicationStartup);<br>      <span class="hljs-comment">//应用所有的ApplicationContextInitializer容器初始化器初始化context,触发ApplicationContextInitializedEvent事件监听，打印启动日志信息，启动Profile日志信息。</span><br>      <span class="hljs-comment">//ConfigurableListableBeanFactory中注册单例Bean（springApplicationArguments）,并为该BeanFactory中的部分属性赋值。</span><br>      <span class="hljs-comment">//加载所有的source.并将Bean加载到ConfigurableApplicationContext，触发ApplicationPreparedEvent事件监听</span><br>      prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);<br>      <span class="hljs-comment">//刷新容器（在方法中集成了Web容器具体请看 https://editor.csdn.net/md/?articleId=123136262）</span><br>      refreshContext(context);<br>      <span class="hljs-comment">//刷新容器的后置处理（空方法）</span><br>      afterRefresh(context, applicationArguments);<br>      <span class="hljs-comment">//启动花费的时间</span><br>      <span class="hljs-type">Duration</span> <span class="hljs-variable">timeTakenToStartup</span> <span class="hljs-operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logStartupInfo) &#123;<br>         <span class="hljs-comment">//打印日志Started xxx in xxx seconds (JVM running for xxxx)</span><br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">StartupInfoLogger</span>(<span class="hljs-built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), timeTakenToStartup);<br>      &#125;<br>      <span class="hljs-comment">//触发ApplicationStartedEvent事件监听。上下文已刷新，应用程序已启动。</span><br>      listeners.started(context, timeTakenToStartup);<br>      <span class="hljs-comment">//调用ApplicationRunner和CommandLineRunner</span><br>      callRunners(context, applicationArguments);<br>   &#125;<br>   <span class="hljs-comment">//处理运行时发生的异常，触发ApplicationFailedEvent事件监听</span><br>   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      handleRunFailure(context, ex, listeners);<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(ex);<br>   &#125;<br>   <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">//启动准备消耗的时间</span><br>      <span class="hljs-type">Duration</span> <span class="hljs-variable">timeTakenToReady</span> <span class="hljs-operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);<br>      <span class="hljs-comment">//在run方法完成前立即触发ApplicationReadyEvent事件监听,表示应用上下文已刷新，并且CommandLineRunners和ApplicationRunners已被调用。</span><br>      listeners.ready(context, timeTakenToReady);<br>   &#125;<br>   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      handleRunFailure(context, ex, <span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(ex);<br>   &#125;<br>   <span class="hljs-keyword">return</span> context;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>SpringBoot的启动类上总是有@SpringbootApplication这个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@SpringBootConfiguration</span><br><span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-meta">@ComponentScan(</span><br><span class="hljs-meta">    excludeFilters = &#123;@Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="hljs-meta">), @Filter(</span><br><span class="hljs-meta">    type = FilterType.CUSTOM,</span><br><span class="hljs-meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="hljs-meta">)&#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br>   ......<br>&#125;<br></code></pre></td></tr></table></figure><p>@SpringBootApplication注解是一个组合注解，由@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan注解组成。<br>@SpringBootConfiguration其实就是一个@Configuration，表明这是一个配置类，可以向容器注入组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Indexed</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration &#123;<br> ......<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>@EnableAutoConfiguration由@AutoConfigurationPackage和@Import({AutoConfigurationImportSelector.class})注解组成。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>   ......<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>@AutoConfigurationPackage内部用到了@Import导入Registrar</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Import(&#123;Registrar.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;<br>  ......<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Registrar实现了ImportBeanDefinitionRegistrar接口，因此可将组件都扫描注冊到 spring 容器中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Registrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span>, DeterminableImports &#123;<br>       Registrar() &#123;<br>       &#125;<br><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;<br>           AutoConfigurationPackages.register(registry, (String[])(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoConfigurationPackages</span>.PackageImports(metadata)).getPackageNames().toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]));<br>       &#125;<br><br>       <span class="hljs-keyword">public</span> Set&lt;Object&gt; <span class="hljs-title function_">determineImports</span><span class="hljs-params">(AnnotationMetadata metadata)</span> &#123;<br>           <span class="hljs-keyword">return</span> Collections.singleton(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoConfigurationPackages</span>.PackageImports(metadata));<br>       &#125;<br>   &#125;<br><br></code></pre></td></tr></table></figure><p>@AutoConfigurationPackage将主配置类（@SpringBootApplication标注的类）所在包下的所有组件都扫描注册到Spring容器中。</p><p><strong>@Import({AutoConfigurationImportSelector.class}) 将AutoConfigurationImportSelector（自动配置导入选择器）导入容器中</strong></p><p><strong>AutoConfigurationImportSelector类中的selectImports（）方法的作用是选择导入过滤后的自动配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>       <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isEnabled(annotationMetadata)) &#123;<br>           <span class="hljs-keyword">return</span> NO_IMPORTS;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           AutoConfigurationImportSelector.<span class="hljs-type">AutoConfigurationEntry</span> <span class="hljs-variable">autoConfigurationEntry</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getAutoConfigurationEntry(annotationMetadata);<br>           <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>getAutoConfigurationEntry(AnnotationMetadata annotationMetadata)根据annotationMetadata（即我们的启动类SpringbootdemoApplication）获取AutoConfigurationEntry</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> AutoConfigurationImportSelector.AutoConfigurationEntry <span class="hljs-title function_">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isEnabled(annotationMetadata)) &#123;<br>            <span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//获取注解属性</span><br>            <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getAttributes(annotationMetadata);<br>            <span class="hljs-comment">//从META-INF/spring.factories中获取候选配置。</span><br>            List&lt;String&gt; configurations = <span class="hljs-built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);<br>            <span class="hljs-comment">//去除重复配置</span><br>            configurations = <span class="hljs-built_in">this</span>.removeDuplicates(configurations);<br>            <span class="hljs-comment">//获取注解中的排除项</span><br>            Set&lt;String&gt; exclusions = <span class="hljs-built_in">this</span>.getExclusions(annotationMetadata, attributes);<br>            <span class="hljs-comment">//检查排除类</span><br>            <span class="hljs-built_in">this</span>.checkExcludedClasses(configurations, exclusions);<br>            <span class="hljs-comment">//从上面的候选配置中移除所有排除的配置类</span><br>            configurations.removeAll(exclusions);<br>            <span class="hljs-comment">//通过ConfigurationClassFilter筛选配置</span><br>            configurations = <span class="hljs-built_in">this</span>.getConfigurationClassFilter().filter(configurations);<br>            <span class="hljs-comment">//触发自动配置导入事件</span><br>            <span class="hljs-built_in">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);<br>            <span class="hljs-comment">//返回排除后的自动配置Entry</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoConfigurationImportSelector</span>.AutoConfigurationEntry(configurations, exclusions);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO详解</title>
    <link href="/2023/07/18/IO-detail/"/>
    <url>/2023/07/18/IO-detail/</url>
    
    <content type="html"><![CDATA[<h1 id="IO详解"><a href="#IO详解" class="headerlink" title="IO详解"></a>IO详解</h1><p><strong>Java中NIO的全称为NewIO 与 Non-BlockingIO 的概念不同</strong></p><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>同步阻塞I&#x2F;O模式，数据的读取写入必须阻塞在一个线程内等待其完成。</p><p><img src="/../img/IO/BIO.png" alt="BIO"></p><p>一般情况下，服务端会为每个客户端连接配套一条独立的线程，或者说一条线程维护一个连接成功的IO流的读写。在并发量小的情况下，这个没有什么问题。但是，当在高并发的场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大。因此，基本上，BIO模型在高并发场景下是不可用的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="1、客户端"><a href="#1、客户端" class="headerlink" title="1、客户端"></a>1、客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BioClient</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9099</span>);<br>    <span class="hljs-comment">// 向服务端发送数据</span><br>    socket.getOutputStream().write(<span class="hljs-string">&quot;Hello BioServer&quot;</span>.getBytes());<br>    socket.getOutputStream().flush();<br>    log.info(<span class="hljs-string">&quot;向服务端发送数据结束&quot;</span>);<br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>    <span class="hljs-comment">//接收服务端回传的数据</span><br>    socket.getInputStream().read(bytes);<br>    log.info(<span class="hljs-string">&quot;接收到服务端返回的数据：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes));<br>    socket.close();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、服务端"><a href="#2、服务端" class="headerlink" title="2、服务端"></a>2、服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BioServer</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">9099</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      log.info(<span class="hljs-string">&quot;等待客户端连接&quot;</span>);<br>      <span class="hljs-comment">//阻塞方法</span><br>      <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>      log.info(<span class="hljs-string">&quot;客户端连接成功&quot;</span>);<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          handler(socket);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>          log.error(e.getMessage(), e);<br>        &#125;<br>      &#125;).start();<br><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handler</span><span class="hljs-params">(Socket socket)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><br>    log.info(<span class="hljs-string">&quot;开始读取数据&quot;</span>);<br>    <span class="hljs-comment">// 接收客户端的数据，阻塞方法，没有数据可读时就阻塞</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> socket.getInputStream().read(bytes);<br>    log.info(<span class="hljs-string">&quot;读取数据完毕&quot;</span>);<br>    <span class="hljs-keyword">if</span> (read != -<span class="hljs-number">1</span>) &#123;<br>      log.info(<span class="hljs-string">&quot;接收到客户端的数据：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, <span class="hljs-number">0</span>, read));<br>    &#125;<br>    <span class="hljs-comment">// 向outputStream中回写数据</span><br>    socket.getOutputStream().write(<span class="hljs-string">&quot;Hello BioClient&quot;</span>.getBytes());<br>    socket.getOutputStream().flush();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>（注意这里说的NIO和Java库的NIO是有区别的，Java的NIO库表示的是New IO的意思。这里我们说的NIO是同步非阻塞IO）</p><p>与BIO不同的是调用read后如果内核数据没有准备好，NIO不会阻塞在当前位置，而是需要不断地发起IO系统调用查询内核数据的状态，如果未就绪返回-1，当内核数据到达后，用户线程发起系统调用，用户线程阻塞。内核开始复制数据。它就会将数据从kernel内核缓冲区，拷贝到用户缓冲区（用户内存），然后kernel返回结果。</p><p>NIO 模型中应用程序在一旦开始IO系统调用，会出现以下两种情况：<br>（1）在内核缓冲区没有数据的情况下，系统调用会立即返回，返回一个调用失败的信息。<br>（2）在内核缓冲区有数据的情况下，是阻塞的，直到数据从内核缓冲复制到用户进程缓冲。复制完成后，系统调用返回成功，应用进程开始处理用户空间的缓存数据。</p><p><img src="/../img/IO/NIO.png" alt="NIO"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="1、客户端-1"><a href="#1、客户端-1" class="headerlink" title="1、客户端"></a>1、客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NioClient</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br><br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> SocketChannel.open();<br>    sc.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8099</span>));<br><br>    sc.write(Charset.defaultCharset().encode(<span class="hljs-string">&quot;Hello NioServer&quot;</span>));<br>    log.info(<span class="hljs-string">&quot;发送数据成功&quot;</span>);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> sc.read(buffer);<br>    <span class="hljs-keyword">if</span> (read &gt; <span class="hljs-number">0</span>) &#123;<br>      log.info(<span class="hljs-string">&quot;读取到服务端返回的 &#123;&#125; 长度的数据&quot;</span>, read);<br>    &#125;<br><br>    sc.write(Charset.defaultCharset().encode(<span class="hljs-string">&quot;Hello NioServer2&quot;</span>));<br>    log.info(<span class="hljs-string">&quot;再次发送数据成功&quot;</span>);<br><br>    System.in.read(); <span class="hljs-comment">// 阻塞线程</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、服务端-1"><a href="#2、服务端-1" class="headerlink" title="2、服务端"></a>2、服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NioServer</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">16</span>);<br>    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssc</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>    ssc.configureBlocking(<span class="hljs-literal">false</span>);<span class="hljs-comment">// accept不会阻塞</span><br>    ssc.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8099</span>));<br>    List&lt;SocketChannel&gt; channelList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      log.info(<span class="hljs-string">&quot;开始接收请求&quot;</span>);<br>      <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">accept</span> <span class="hljs-operator">=</span> ssc.accept();<br>      <span class="hljs-keyword">if</span> (accept != <span class="hljs-literal">null</span>) &#123;<br>        log.info(<span class="hljs-string">&quot;获取到对应的连接&quot;</span> + accept);<br>        accept.configureBlocking(<span class="hljs-literal">false</span>); <span class="hljs-comment">// read不会阻塞</span><br>        channelList.add(accept);<br>      &#125;<br><br>      <span class="hljs-keyword">for</span> (SocketChannel channel : channelList) &#123;<br>        log.info(<span class="hljs-string">&quot;开始读取客户端的数据&quot;</span>, channel);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">read</span> <span class="hljs-operator">=</span> channel.read(buffer);<br>        <span class="hljs-keyword">if</span> (read &gt; <span class="hljs-number">0</span>) &#123;<br>          buffer.flip();<br>          log.info(<span class="hljs-string">&quot;读取到 &#123;&#125; 长度的数据&quot;</span>, read);<br>          <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">retBuf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-string">&quot;Hi NioClient&quot;</span>.getBytes());<br>          TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>); <span class="hljs-comment">// 阻塞线程，便于观察控制台</span><br>          channel.write(retBuf);<br>          buffer.clear();<br>          log.info(<span class="hljs-string">&quot;数据读取完成&quot;</span>, channel);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>异步非阻塞I&#x2F;O模型</p><p>异步非阻塞无需一个线程去轮询所有IO操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理</p><pre><code class="hljs"> 1. 当用户线程调用了read系统调用，立刻就可以开始去做其它的事，用户线程不阻塞。 2. 内核（kernel）就开始了IO的第一个阶段：准备数据。当kernel一直等到数据准备好了，它就会将数据从kernel内核缓冲区，拷贝到用户缓冲区（用户内存）。 3. kernel会给用户线程发送一个信号（signal），或者回调用户线程注册的回调接口，告诉用户线程read操作完成了。 4. 用户线程读取用户缓冲区的数据，完成后续的业务操作。</code></pre><p><img src="/../img/IO/AIO.png" alt="AIO"></p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>IO复用模型指的就是：通过一个进程监听多个文件描述符，一旦某个文件描述符准备就绪，就去通知程序做相对应的处理</p><p>这种以通知的方式，优势并不是对于单个连接能处理得更快，而是在于它能处理更多的连接。</p><p><strong>在Linux下IO复用模型用的函数有select&#x2F;poll和epoll</strong></p><h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>select函数它支持最大的连接数是1024或2048，因为在select函数下要传入fd_set参数，这个fd_set的大小要么1024或2048</p><p>fd_set就是bitmap的数据结构，可以简单理解为只要位为0，那说明还没数据到缓冲区，只要位为1，那说明数据已经到缓冲区</p><p>select函数每次将fd_set遍历，判断标志位有没有发现变化，如果有变化则通知程序做中断处理。</p><p><img src="/../img/IO/IO-Multiplexing.png" alt="IO-Multiplexing"></p><h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><p>在Java NIO有三个核心部分组成。分别是Buffer（缓冲区）、Channel（管道）以及Selector（选择器）</p><p>Buffer是存储数据的地方，Channel是运输数据的载体，而Selector用于检查多个Channel的状态变更情况，</p><p><strong>Buffer(缓冲区)</strong></p><p>​    缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。相比较直接对数组的操作，Buffer APl更加容易操作和管理。</p><p><strong>Channel(通道)</strong></p><p>​    Java NIO的通道类似流，但又有些不同:既可以从通道中读取数据，又可以写数据到通道。但流的(input或output)读写通常是单向的。通道可以非阻塞读取和写入通道，通道可以支持读取或写入缓冲区，也支持异步地读写。</p><p><strong>Selector(选择器)</strong></p><p>​    Selector是一个ava NIO组件，可以能够检查一个或多个NIO通道，并确定哪些通道已经准备好进行读取或写入。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接，提高效率</p><p><img src="/../img/IO/Java-NIO.png" alt="Java-NIO"></p><ul><li>每个channel都会对应一个 Buffer</li><li>一个线程对应Selector ,一个Selector对应多个channel(连接)程序</li><li>切换到哪个channel是由事件决定的</li><li>Selector 会根据不同的事件，在各个通道上切换</li><li>Buffer 就是一个内存块，底层是一个数组</li><li>数据的读取写入是通过 Buffer完成的，BlO中要么是输入流，或者是输出流,不能双向，但是NIO的Buffer是可以读也可以写。</li><li>Java NIO系统的核心在于:通道(Channel)和缓冲区(Buffer)。通道表示打开到lO设备(例如:文件、套接字)的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。简而言之，Channel负责传输，Buffer负责存取数据</li></ul><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p><strong>缓冲区（Buffer）</strong>一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区 都是 Buffer 抽象类的子类.。Java NIO 中的 <strong>Buffer 主要用于与 NIO 通道进行 交互</strong>，<strong>数据是从通道读入缓冲区，从缓冲区写入通道</strong>中的</p><p>缓冲区的基本属性 Buffer 中的重要概念：</p><p><strong>容量 (capacity) ：</strong>作为一个内存块，Buffer具有一定的固定大小， 也称为”容量”，缓冲区容量不能为负，并且创建后不能更改。</p><p><strong>限制 (limit)：</strong>表示缓冲区中可以操作数据的大小 （limit 后数据不能进行读写）。缓冲区的限制不能 为负，并且不能大于其容量。 写入模式，限制等于 buffer的容量。读取模式下，limit等于写入的数据量。</p><p><strong>位置 (position)：</strong>下一个要读取或写入的数据的索引。 缓冲区的位置不能为 负，并且不能大于其限制</p><p><strong>标记 (mark)与重置 (reset)：</strong>标记是一个索引， 通过 Buffer 中的 mark() 方法 指定 Buffer 中一个 特定的 position，之后可以通过调用 reset() 方法恢 复到这 个 position.</p><p>标记、位置、限制、容量遵守以下不变式： <strong>0 &lt;&#x3D; mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</strong></p><p><strong>使用Buffer读写数据一般遵循以下四个步骤：</strong></p><ol><li>写入数据到Buffer</li><li>调用flip()方法，转换为读取模式</li><li>从Buffer中读取数据</li><li>调用buffer.clear()方法或者buffer.compact()方 法清除缓冲区</li></ol><p><img src="/../img/IO/NIO-Buffer.png" alt="Buffer"></p><h3 id="通道-Channel"><a href="#通道-Channel" class="headerlink" title="通道(Channel)"></a>通道(Channel)</h3><p>通道（Channel）：由 java.nio.channels 包定义 的。Channel 表示 IO 源与目标打开的连接。 Channel 类似于传统的“流”。只不过 Channel <strong>本身不能直接访问数据</strong>，Channel 只能与 Buffer 进行交互。</p><h4 id="NIO-的通道类似于流，但有些区别如下："><a href="#NIO-的通道类似于流，但有些区别如下：" class="headerlink" title="NIO 的通道类似于流，但有些区别如下："></a>NIO 的通道类似于流，但有些<strong>区别</strong>如下：</h4><ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读数据，也可以写数据到缓冲:</li></ul><h4 id="常用的Channel实现类"><a href="#常用的Channel实现类" class="headerlink" title="常用的Channel实现类"></a>常用的Channel实现类</h4><ul><li>FileChannel：用于读取、写入、映射和操作文件的通道。</li><li>DatagramChannel：通过 UDP 读写网络中的数据通道。</li><li>SocketChannel：通过 TCP 读写网络中的数据。</li><li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</li></ul><h4 id="案例1-本地文件写数据"><a href="#案例1-本地文件写数据" class="headerlink" title="案例1-本地文件写数据"></a>案例1-本地文件写数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.kgf.kgfjavalearning2021.io.nio;<br> <br><span class="hljs-keyword">import</span> org.junit.Test;<br> <br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.nio.channels.FileChannel;<br> <br><span class="hljs-comment">/***</span><br><span class="hljs-comment"> * 需求：使用前面学习后的 ByteBuffer(缓冲)和 FileChannel(通道)， 将数据写入到 data.txt 中.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelTest</span> &#123;<br> <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1、字节输出流通向目标文件</span><br>            <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;E:\\test\\data01.txt&quot;</span>);<br>            <span class="hljs-comment">// 2、得到字节输出流对应的通道Channel</span><br>            <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> fos.getChannel();<br>            <span class="hljs-comment">// 3、分配缓冲区</span><br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                buffer.clear();<span class="hljs-comment">//清空缓冲区</span><br>                buffer.put((<span class="hljs-string">&quot;hello,使用Buffer和channel实现写数据到文件中&quot;</span>+i+<span class="hljs-string">&quot;\r\n&quot;</span>).getBytes());<br>                <span class="hljs-comment">// 4、把缓冲区切换成写出模式</span><br>                buffer.flip();<br>                channel.write(buffer);<span class="hljs-comment">//将缓冲区的数据写入到文件通道</span><br>            &#125;<br>            channel.close();<br>            System.out.println(<span class="hljs-string">&quot;写数据到文件中！&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="案例2-本地文件读数据"><a href="#案例2-本地文件读数据" class="headerlink" title="案例2-本地文件读数据"></a>案例2-本地文件读数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/***</span><br><span class="hljs-comment">    * 设置两个缓冲区，一大一小，大的缓冲区为每次读取的量，小的缓冲区存放每行的数据（确保大小可存放文本中最长的那行）。读取的时候判断是不是换行符13，是的话则返回一行数据，不是的话继续读取，直到读完文件。</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-comment">// 1、定义一个文件字节输入流与源文件接通</span><br>       <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;E:\\test\\data01.txt&quot;</span>);<br>       <span class="hljs-comment">// 2、需要得到文件字节输入流的文件通道</span><br>       <span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> is.getChannel();<br>       <span class="hljs-comment">// 3、定义一个缓冲区</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">bufferSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;  <span class="hljs-comment">// 每一块的大小</span><br>       <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(bufferSize);<br><br>       <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>       <span class="hljs-comment">// 4、读取数据到缓冲区</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">bytesRead</span> <span class="hljs-operator">=</span> channel.read(buffer);<br>       <span class="hljs-keyword">while</span> (bytesRead != -<span class="hljs-number">1</span>) &#123;<br>           buffer.flip();<span class="hljs-comment">// 切换模式，写-&gt;读</span><br>           <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<span class="hljs-comment">//返回 position 和 limit 之间的元素个数</span><br>                   <span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> buffer.get();<br>                   <span class="hljs-keyword">if</span> (b == <span class="hljs-number">10</span> || b == <span class="hljs-number">13</span>) &#123; <span class="hljs-comment">// 换行或回车</span><br>                       bb.flip();<br>                       <span class="hljs-comment">// 这里就是一个行</span><br>                       <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;utf-8&quot;</span>).decode(bb).toString();<br>                       System.out.println(line);<span class="hljs-comment">// 解码已经读到的一行所对应的字节</span><br>                       bb.clear();<br>                   &#125; <span class="hljs-keyword">else</span> &#123;<br>                       <span class="hljs-keyword">if</span> (bb.hasRemaining())<br>                           bb.put(b);<br>                       <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 空间不够扩容</span><br>                           bb = reAllocate(bb);<br>                           bb.put(b);<br>                       &#125;<br>                   &#125;<br>           &#125;<br>           buffer.clear();<span class="hljs-comment">// 清空,position位置为0，limit=capacity</span><br>           <span class="hljs-comment">//  继续往buffer中写</span><br>           bytesRead = channel.read(buffer);<br>       &#125;<br>       channel.close();<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="选择器-Selector"><a href="#选择器-Selector" class="headerlink" title="选择器(Selector)"></a>选择器(Selector)</h3><p>选择器（Selector)是<strong>SelectableChannle对象</strong>的<strong>多路复用器</strong>，Selector可以<strong>同时监控多个</strong>SelectableChannel的IO状况，也就是说，利用Selector可使<strong>一个单独的线程管理多个Channel</strong>。Selector是非阻塞IO的核心。</p><ul><li>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到 Selector(选择器)</li><li>Selector 能够检测多个注册的通道上是否有事件发生(注意:多个 Channel 以事件的方式可以注册到同一个(Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管</li><li>理多个通道，也就是管理多个连接和请求。</li><li>只有在连接&#x2F;通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</li><li>避免了多线程之间的上下文切换导致的开销</li></ul><h4 id="创建-Selector"><a href="#创建-Selector" class="headerlink" title="创建 Selector"></a>创建 Selector</h4><p>通过调用 Selector.open() 方法创建一个 Selector。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br></code></pre></td></tr></table></figure><h4 id="向选择器注册通道"><a href="#向选择器注册通道" class="headerlink" title="向选择器注册通道"></a>向选择器注册通道</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 获取通道</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">ssChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br><span class="hljs-comment">//2. 切换非阻塞模式</span><br>ssChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//3. 绑定连接</span><br>ssChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">9898</span>));<br><span class="hljs-comment">//4. 获取选择器</span><br><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><span class="hljs-comment">//5. 将通道注册到选择器上, 并且指定“监听接收事件”</span><br>ssChannel.register(selector, SelectionKey.OP_ACCEPT);<br></code></pre></td></tr></table></figure><p>当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定。可以监听的事件类型（用 可使用 SelectionKey 的四个常量 表示）：</p><ul><li><strong>读 : SelectionKey.OP_READ （1）</strong></li><li><strong>写 : SelectionKey.OP_WRITE （4）</strong></li><li><strong>连接 : SelectionKey.OP_CONNECT （8）</strong></li><li><strong>接收 : SelectionKey.OP_ACCEPT （16）</strong></li></ul><p>若注册时不止监听一个事件，则可以使用“位或”操作符连接。<br><strong>int interestSet &#x3D; SelectionKey.OP_READ|SelectionKey.OP_WRITE</strong></p><h3 id="NIO-Server"><a href="#NIO-Server" class="headerlink" title="NIO Server"></a>NIO Server</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoBlockServer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">// 1.获取通道</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br><br>        <span class="hljs-comment">// 2.切换成非阻塞模式</span><br>        server.configureBlocking(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-comment">// 3. 绑定连接</span><br>        server.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">6666</span>));<br><br>        <span class="hljs-comment">// 4. 获取选择器</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><br>        <span class="hljs-comment">// 4.1将通道注册到选择器上，指定接收“监听通道”事件</span><br>        server.register(selector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-comment">// 5. 轮训地获取选择器上已“就绪”的事件---&gt;只要select()&gt;0，说明已就绪</span><br>        <span class="hljs-keyword">while</span> (selector.select() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件)</span><br>            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br><br>            <span class="hljs-comment">// 7. 获取已“就绪”的事件，(不同的事件做不同的事)</span><br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br><br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> iterator.next();<br><br>                <span class="hljs-comment">// 接收事件就绪</span><br>                <span class="hljs-keyword">if</span> (selectionKey.isAcceptable()) &#123;<br><br>                    <span class="hljs-comment">// 8. 获取客户端的链接</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> server.accept();<br><br>                    <span class="hljs-comment">// 8.1 切换成非阻塞状态</span><br>                    client.configureBlocking(<span class="hljs-literal">false</span>);<br><br>                    <span class="hljs-comment">// 8.2 注册到选择器上--&gt;拿到客户端的连接为了读取通道的数据(监听读就绪事件)</span><br>                    client.register(selector, SelectionKey.OP_READ);<br><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectionKey.isReadable()) &#123; <span class="hljs-comment">// 读事件就绪</span><br><br>                    <span class="hljs-comment">// 9. 获取当前选择器读就绪状态的通道</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> (SocketChannel) selectionKey.channel();<br><br>                    <span class="hljs-comment">// 9.1读取数据</span><br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>                    <span class="hljs-comment">// 9.2得到文件通道，将客户端传递过来的图片写到本地项目下(写模式、没有则创建)</span><br>                    <span class="hljs-type">FileChannel</span> <span class="hljs-variable">outChannel</span> <span class="hljs-operator">=</span> FileChannel.open(Paths.get(<span class="hljs-string">&quot;2.png&quot;</span>), StandardOpenOption.WRITE, StandardOpenOption.CREATE);<br><br>                    <span class="hljs-keyword">while</span> (client.read(buffer) &gt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 在读之前都要切换成读模式</span><br>                        buffer.flip();<br><br>                        outChannel.write(buffer);<br><br>                        <span class="hljs-comment">// 读完切换成写模式，能让管道继续读取文件的数据</span><br>                        buffer.clear();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 10. 取消选择键(已经处理过的事件，就应该取消掉了)</span><br>                iterator.remove();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NIO-Client"><a href="#NIO-Client" class="headerlink" title="NIO Client"></a>NIO Client</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NoBlockClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>        <span class="hljs-comment">// 1. 获取通道</span><br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> SocketChannel.open(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>));<br><br>        <span class="hljs-comment">// 1.1切换成非阻塞模式</span><br>        socketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><br>        <span class="hljs-comment">// 1.2获取选择器</span><br>        <span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><br>        <span class="hljs-comment">// 1.3将通道注册到选择器中，获取服务端返回的数据</span><br>        socketChannel.register(selector, SelectionKey.OP_READ);<br><br>        <span class="hljs-comment">// 2. 发送一张图片给服务端吧</span><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel</span> <span class="hljs-operator">=</span> FileChannel.open(Paths.get(<span class="hljs-string">&quot;X:\Users\ozc\Desktop\面试造火箭\1.png&quot;</span>), StandardOpenOption.READ);<br><br>        <span class="hljs-comment">// 3.要使用NIO，有了Channel，就必然要有Buffer，Buffer是与数据打交道的呢</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>        <span class="hljs-comment">// 4.读取本地文件(图片)，发送到服务器</span><br>        <span class="hljs-keyword">while</span> (fileChannel.read(buffer) != -<span class="hljs-number">1</span>) &#123;<br><br>            <span class="hljs-comment">// 在读之前都要切换成读模式</span><br>            buffer.flip();<br><br>            socketChannel.write(buffer);<br><br>            <span class="hljs-comment">// 读完切换成写模式，能让管道继续读取文件的数据</span><br>            buffer.clear();<br>        &#125;<br><br><br>        <span class="hljs-comment">// 5. 轮训地获取选择器上已“就绪”的事件---&gt;只要select()&gt;0，说明已就绪</span><br>        <span class="hljs-keyword">while</span> (selector.select() &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件)</span><br>            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();<br><br>            <span class="hljs-comment">// 7. 获取已“就绪”的事件，(不同的事件做不同的事)</span><br>            <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br><br>                <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> iterator.next();<br><br>                <span class="hljs-comment">// 8. 读事件就绪</span><br>                <span class="hljs-keyword">if</span> (selectionKey.isReadable()) &#123;<br><br>                    <span class="hljs-comment">// 8.1得到对应的通道</span><br>                    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> (SocketChannel) selectionKey.channel();<br><br>                    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">responseBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br><br>                    <span class="hljs-comment">// 9. 知道服务端要返回响应的数据给客户端，客户端在这里接收</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">readBytes</span> <span class="hljs-operator">=</span> channel.read(responseBuffer);<br><br>                    <span class="hljs-keyword">if</span> (readBytes &gt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 切换读模式</span><br>                        responseBuffer.flip();<br>                        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(responseBuffer.array(), <span class="hljs-number">0</span>, readBytes));<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// 10. 取消选择键(已经处理过的事件，就应该取消掉了)</span><br>                iterator.remove();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面经2023-07-10</title>
    <link href="/2023/07/10/Interview-Exp-20230710/"/>
    <url>/2023/07/10/Interview-Exp-20230710/</url>
    
    <content type="html"><![CDATA[<h1 id="携程-JAVA后端实习"><a href="#携程-JAVA后端实习" class="headerlink" title="携程-JAVA后端实习"></a>携程-JAVA后端实习</h1><p>来源： 牛客 xiang314159265</p><p><a href="https://www.nowcoder.com/feed/main/detail/8a7a4595f2ba40658d01dc87056d1d44?sourceSSR=users">https://www.nowcoder.com/feed/main/detail/8a7a4595f2ba40658d01dc87056d1d44?sourceSSR=users</a></p><h2 id="1-栈和队列的区别，分别用在什么场景"><a href="#1-栈和队列的区别，分别用在什么场景" class="headerlink" title="1.栈和队列的区别，分别用在什么场景"></a>1.栈和队列的区别，分别用在什么场景</h2><p>栈（Stack）是一种线性数据结构，它的特点是先进后出（Last In First Out，LIFO）。栈可以看作是一个容器，只能在容器的一端进行插入和删除操作，这一端被称为栈顶。</p><p>栈的主要应用场景包括：</p><ol><li>表达式求值：在中缀表达式转后缀表达式或前缀表达式的过程中，需要使用栈来保存操作符，以便按照正确的优先级进行计算。</li><li>函数调用：当函数被调用时，需要将调用该函数的程序的状态信息（包括程序计数器和局部变量等）保存到栈中，以便在函数返回时恢复这些状态信息。</li></ol><p>队列（Queue）也是一种线性数据结构，它的特点是先进先出（First In First Out，FIFO）。队列可以看作是一个管道，数据只能从管道的一端进入，从另一端出去。</p><p>队列的主要应用场景包括：</p><ol><li>线程池：线程池将任务放入队列中，线程池中的线程从队列中取出任务并执行。</li><li>消息队列：消息队列是一种常见的消息传递机制，多个进程可以共享同一个消息队列，将消息放入队列中，其他进程可以从队列中取出消息并进行处理。</li></ol><h2 id="2-BIO、AIO、NIO、多路复用是什么"><a href="#2-BIO、AIO、NIO、多路复用是什么" class="headerlink" title="2.BIO、AIO、NIO、多路复用是什么"></a>2.BIO、AIO、NIO、多路复用是什么</h2><p>详情见：<a href="https://bigducksoup.github.io/2023/07/18/IO-detail/">https://bigducksoup.github.io/2023/07/18/IO-detail/</a></p><h2 id="3-多路复用相比NIO的优势"><a href="#3-多路复用相比NIO的优势" class="headerlink" title="3.多路复用相比NIO的优势"></a>3.多路复用相比NIO的优势</h2><p>非阻塞IO和IO多路复用都是用于提高I&#x2F;O操作效率的技术，但它们之间有一些区别。</p><p>非阻塞IO是指在进行I&#x2F;O操作时，如果数据没有准备好或者无法立即读取或写入，I&#x2F;O操作不会阻塞线程，而是立即返回一个错误码或者空值，线程可以继续执行其他任务。在Java中，非阻塞IO通常使用Java NIO库中的Channel和Buffer类实现。使用非阻塞IO技术时，<strong>需要采用轮询的方式不断地检查I&#x2F;O操作是否已经准备好，这会带来一定的系统开销</strong>。</p><p>IO多路复用是指通过一种机制，可以监控多个I&#x2F;O流（例如网络套接字）的状态，当其中任意一个I&#x2F;O流有数据可读或可写时，就通知相应的线程进行读写操作。在Java中，IO多路复用通常使用Java NIO库中的Selector类实现。使用IO多路复用技术时，只需要一个线程就可以同时处理多个I&#x2F;O操作，从而避免了创建多个线程的开销，同时也提高了系统的吞吐量。</p><p>因此，非阻塞IO和IO多路复用都可以提高I&#x2F;O操作的效率，但它们的实现方式有所不同。非阻塞IO需要轮询检查I&#x2F;O操作是否已准备好，而IO多路复用可以监控多个I&#x2F;O流的状态，只需要一个线程就可以处理多个I&#x2F;O操作。</p><h2 id="4-Hashmap底层原理，线程安全吗"><a href="#4-Hashmap底层原理，线程安全吗" class="headerlink" title="4.Hashmap底层原理，线程安全吗"></a>4.Hashmap底层原理，线程安全吗</h2><p>数组+链表+红黑树</p><p>JDK1.8 中，由于多线程对HashMap进行put操作，调用了HashMap#putVal()，具体原因：假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。</p><h2 id="5-红黑树与其他树的优缺点比较"><a href="#5-红黑树与其他树的优缺点比较" class="headerlink" title="5.红黑树与其他树的优缺点比较"></a>5.红黑树与其他树的优缺点比较</h2><p>红黑树是一种自平衡二叉查找树，它与其他二叉查找树（如AVL树、Splay树等）相比具有一些优缺点。</p><p>优点：</p><ol><li>自平衡性：红黑树能够自动调整自己的结构，保持平衡，使得查找、插入、删除等操作的时间复杂度都能够保持在O(log n)级别。</li><li>插入和删除操作效率高：红黑树采用颜色标记和旋转操作来维护平衡，相比于其他自平衡二叉查找树，红黑树的旋转操作次数较少，因此插入和删除操作效率较高。</li><li>适用于大规模数据存储和动态查询：红黑树在大规模数据存储和动态查询方面表现优异，它能够支持高效的插入、删除、查找等操作。</li></ol><p>缺点：</p><ol><li>空间占用较大：红黑树的每个节点都需要存储额外的颜色信息，因此空间占用较大。</li><li>难以实现：相比于其他二叉查找树，红黑树的实现较为复杂，旋转操作需要考虑多种情况，因此实现难度较大。</li><li>查找操作效率相对较低：尽管红黑树的查找操作时间复杂度为O(log n)，但是相比于其他平衡树（如AVL树）的查找效率稍低。</li></ol><p>总的来说，红黑树在实际应用中表现良好，尤其适用于大规模数据存储和动态查询的场景。但是在一些特定的应用场景下，其他平衡树（如AVL树）可能更为适合。</p><h2 id="6-ConcurrentHashmap底层原理"><a href="#6-ConcurrentHashmap底层原理" class="headerlink" title="6.ConcurrentHashmap底层原理"></a>6.ConcurrentHashmap底层原理</h2><p>ConcurconrentHashMap底层可有老多东西了，1.7版本ConcurconrentHashMap底层采用的是分段锁，1.8版本优化为CAS+synchnoized的方式</p><p>相比于HashMap，ConcurrentMap的Node在value和下个节点都加上了volatile，以保证val的可见性。</p><h2 id="7-讲一下熟悉的一个设计模式"><a href="#7-讲一下熟悉的一个设计模式" class="headerlink" title="7.讲一下熟悉的一个设计模式"></a>7.讲一下熟悉的一个设计模式</h2><p>略</p><h2 id="8-Volatile和synchronized区别"><a href="#8-Volatile和synchronized区别" class="headerlink" title="8.Volatile和synchronized区别"></a>8.Volatile和synchronized区别</h2><p>Volatile和synchronized都是Java中用于实现多线程同步的关键字，但它们的作用和使用方式略有不同。</p><ol><li>作用：Volatile用于保证变量的可见性和禁止指令重排序，而synchronized用于保证线程间的互斥和同步执行。</li><li>使用方式：Volatile只需要在变量声明时加上volatile关键字即可，而synchronized需要在方法或代码块中加上synchronized关键字，并指定同步锁对象。</li><li>适用范围：Volatile适用于单个变量的读写操作，而synchronized适用于多个线程之间的协调和同步。</li><li>性能影响：Volatile的性能影响比synchronized要小，因为Volatile不会阻塞线程。而synchronized由于需要获取锁资源，可能会导致线程阻塞和性能下降。</li><li>功能限制：Volatile不能保证原子性，也不能替代synchronized在复杂的多线程同步场景中的使用。synchronized能够保证线程安全和原子性。</li></ol><h2 id="9-Java类是怎么加载的"><a href="#9-Java类是怎么加载的" class="headerlink" title="9.Java类是怎么加载的"></a>9.Java类是怎么加载的</h2><p>Java类加载（Class Loading）是Java虚拟机（JVM）的核心特性之一，它是将Java字节码文件（.class文件）加载到JVM中，并转换为Java类对象的过程。Java类加载分为三个步骤：加载、连接和初始化。</p><ol><li>加载：类加载的第一步是加载，它是指将类的字节码文件加载到JVM中。在加载过程中，JVM会根据类的全限定名查找类的字节码文件，并将其读取到内存中。类的字节码文件可以从多种来源获取，包括本地文件系统、网络、JAR包、ZIP文件等。</li><li>连接：连接是指将类的二进制数据合并到JVM的运行时数据区中的过程。连接阶段分为三个子阶段：验证、准备和解析。<ul><li>验证：验证阶段是对字节码的验证，确保字节码符合Java虚拟机规范，并且不会对JVM的安全性造成威胁。</li><li>准备：准备阶段是为类的静态变量分配内存，并赋予默认初始值的过程。这些静态变量在JVM启动时就会被分配内存。</li><li>解析：解析阶段是将符号引用转换为实际引用的过程。</li></ul></li><li>初始化：初始化是类加载的最后一个阶段，它是指执行类的静态初始化代码块的过程。在初始化过程中，JVM会按照静态初始化代码块的顺序依次执行，直到所有的静态初始化代码块都执行完毕。</li></ol><h2 id="10-讲一下虚拟内存是什么"><a href="#10-讲一下虚拟内存是什么" class="headerlink" title="10.讲一下虚拟内存是什么"></a>10.讲一下虚拟内存是什么</h2><p>每个进程创建加载的时候，会被分配一个大小为4G的连续的虚拟地址空间，虚拟的意思就是，其实这个地址空间时不存在的，仅仅是每个进程“认为”自己拥有4G的内存，而实际上，它用了多少空间，操作系统就在磁盘上划出多少空间给它，等到进程真正运行的时候，需要某些数据并且数据不在物理内存中，才会触发缺页异常，进行数据拷贝</p><h2 id="11-多级页表的优点"><a href="#11-多级页表的优点" class="headerlink" title="11.多级页表的优点"></a>11.多级页表的优点</h2><p>多级页表是一种操作系统中常见的虚拟内存管理技术，它将虚拟地址空间分成多个层次，每个层次都有自己的页表。多级页表相较于单级页表的优点包括：</p><ol><li>空间利用率高：多级页表可以有效地减小页表的大小，从而减小了内存的占用。由于每个页表项都可以覆盖更多的虚拟地址空间，因此多级页表可以更有效地利用内存空间。</li><li>快速访问页表：由于多级页表缩小了每个页表的大小，因此可以更快地访问页表。当需要查找某个虚拟地址对应的物理地址时，操作系统只需要访问少量的页表项，从而提高了访问速度。</li><li>灵活性高：多级页表允许操作系统根据需要动态地调整页表的大小和层次。当系统的虚拟地址空间变大时，可以增加页表的层次；当虚拟地址空间较小时，可以减少页表的层次。这种灵活性可以使操作系统更加适应不同的内存管理需求。</li></ol><h2 id="12-用户态和内核态，以及如何在两个状态间转换"><a href="#12-用户态和内核态，以及如何在两个状态间转换" class="headerlink" title="12.用户态和内核态，以及如何在两个状态间转换"></a>12.用户态和内核态，以及如何在两个状态间转换</h2><p>用户态和内核态是计算机操作系统中的两种运行级别，也称为特权级别。用户态是指程序在普通的执行状态下运行，只能访问自己的内存和CPU资源，而内核态是指程序在特权级别较高的状态下运行，可以访问系统的所有资源，包括系统内存、I&#x2F;O设备等。</p><p>在用户态下，程序只能访问自己的内存空间和CPU资源，不能直接访问系统资源，必须通过系统调用（system call）来请求操作系统的服务。这些服务包括文件操作、网络通信、进程管理等。当程序需要使用这些服务时，必须通过系统调用进入内核态，由内核完成所需的操作，然后再返回用户态继续执行。</p><p>在内核态下，程序可以直接访问系统资源，包括系统内存、I&#x2F;O设备等。内核态的程序通常是操作系统的内核模块或驱动程序，它们需要运行在特权级别较高的状态下才能完成系统级别的任务。</p><p>在操作系统中，用户态和内核态之间的切换是通过系统调用实现的。当程序需要调用系统服务时，它需要向操作系统发出系统调用请求，操作系统会检查请求的合法性，并将程序的执行状态从用户态切换到内核态，执行所需的操作，并将执行结果返回给程序，最后再将程序的执行状态从内核态切换回用户态，继续执行程序的下一条指令。</p><h2 id="13-什么是索引，用的什么数据结构"><a href="#13-什么是索引，用的什么数据结构" class="headerlink" title="13.什么是索引，用的什么数据结构"></a>13.什么是索引，用的什么数据结构</h2><p>在计算机科学中，索引（Index）是一种数据结构，用于加快数据的检索速度。索引通常是在数据库或文件系统中使用，常见的索引数据结构包括哈希表、B树（或B+树）等。索引可以使数据的访问更快，通过索引可以快速地定位数据的位置，从而减少了数据的扫描时间。</p><h2 id="14-如果一个数据库查询过慢，你会通过什么方式去排查，有哪些方案"><a href="#14-如果一个数据库查询过慢，你会通过什么方式去排查，有哪些方案" class="headerlink" title="14.如果一个数据库查询过慢，你会通过什么方式去排查，有哪些方案"></a>14.如果一个数据库查询过慢，你会通过什么方式去排查，有哪些方案</h2><p>开启慢查询日志，使用explain解释SQL</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA内存模型（JMM）</title>
    <link href="/2023/07/06/JMM/"/>
    <url>/2023/07/06/JMM/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA内存模型（JMM）详解"><a href="#JAVA内存模型（JMM）详解" class="headerlink" title="JAVA内存模型（JMM）详解"></a>JAVA内存模型（JMM）详解</h1><p>在探讨JMM之前，需要建立以下几点共识。</p><ul><li>JMM只是一个抽象内存模型。</li><li>JMM和物理机内存模型不是一个范畴。</li><li>JMM和Java运行时数据区没有直接对应关系。</li></ul><h2 id="1、现代计算机内存模型"><a href="#1、现代计算机内存模型" class="headerlink" title="1、现代计算机内存模型"></a>1、现代计算机内存模型</h2><p>物理机遇到的并发问题与Java虚拟机中的情况有不少相似之处，物理机对并发问题的处理方案对虚拟机的实现也有相当大的参考价值。现代计算机中，CPU的指令速度远远超过内存的存取速度，由于计算机的存储设备与CPU的运算速度有几个数量级的差距，所以现在计算机中都不得不加入一层读写速度尽可能接近CPU运算速度的高速缓存（cache）来作为内存和CPU之间的缓冲。</p><p>基于高速缓存的存储交互很好的解决了CPU和内存的速度的矛盾，但也引入了一个新的问题，缓存一致性，在多处理器系统中，每个CPU都有自己的高速缓存，而他们又共享同一主内存，当多个处理器运算任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致。为了解决这个问题，需要各个处理器在访问内存时，需要遵循一些协议，例如MSI、EMSI、MOSI等。</p><p><img src="/../img/JMM/computer-mem-model.png" alt="计算机内存模型"></p><h2 id="2、缓存一致性"><a href="#2、缓存一致性" class="headerlink" title="2、缓存一致性"></a><strong>2、缓存一致性</strong></h2><p>为了解决这个问题，先后有过两种办法：</p><ul><li><strong>总线锁机制</strong></li></ul><p>总线锁就是使用CPU提供的一个LOCK#信号，当一个处理器在总线上输出此信号，其他处理器的请求将被阻塞，那么该处理器就可以独占共享锁。这样就保证了数据一致性。</p><ul><li><strong>缓存锁机制</strong></li></ul><p>但是总线锁定开销太大，我们需要控制锁的力度，所以又有了缓存锁，核心就是缓存一致性协议，不同的CPU硬件厂商实现方式稍有不同，有MSI、MESI、MOSI等。</p><p><strong>3、多线程编程面临的问题</strong></p><p>多线程编程面临的两个重要的问题是：</p><ul><li><strong>线程之间的通信</strong></li><li><strong>线程之间的同步</strong></li></ul><p>线程之间的通信是指线程之间通过什么方式来交换信息。</p><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制。</p><p><strong>线程的通信方式：</strong></p><ul><li><strong>共享内存</strong></li><li><strong>消息传递</strong></li></ul><p>在共享内存的并发模式里，线程之间共享程序的公共状态，线程之间通过读-写内存中的公共状态来实现隐式通信。</p><p>在消息传递的并发模式里，同步是显式进行的，程序员必须显式指定某个方法或某段代码需要在线程之间互斥进行。</p><p><img src="/../img/JMM/mem-share-model.png" alt="共享内存并发模型"></p><p>在消息传递的并发模式里，线程之间没有公共状态，线程之间必须明确发送消息来显式进行通信。</p><p>在消息传递的并发模型里，同步是隐式进行的，由于消息发送必然在消息接收之前，因此同步是隐式进行的。</p><p><img src="/../img/JMM/messaging-model.png" alt="消息传递并发模型"></p><h2 id="3-JMM内存模型概述"><a href="#3-JMM内存模型概述" class="headerlink" title="3.JMM内存模型概述"></a>3.JMM内存模型概述</h2><p>前面在第三章节，讲述了共享内存和消息传递并发模型，java采用的是共享内存并发模型。</p><p>在java中，所有的实例域，静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。局部变量，方法参数和异常处理器参数不会在线程之间共享，他们不会有内存可见性问题，也不受内存模型的影响。</p><p>java线程之间的通信由java内存模型（JMM）控制，JMM决定了一个线程对共享变量的写入何时对另一个线程可见。JMM定义了多线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地化内存，本地内存中存储了该线程用以读&#x2F;写共享变量的副本。本地内存只是JMM的抽象，并不真实存在，它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。java内存模型的抽象示意，如图6：</p><p><img src="/../img/JMM/JMM.png" alt="JMM"></p><h2 id="4-重排序"><a href="#4-重排序" class="headerlink" title="4.重排序"></a>4.重排序</h2><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。总的来说重排序分成两类：</p><p><strong>编译器优化的重排序。</strong>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p><p><strong>处理器重排序。</strong>现在处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p><p>这些重排序可能会导致多线程出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序。</p><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><p><strong>重排序对多线程的影响</strong></p><p>下面我们从一个很经典的代码例子说明重排序的问题,代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RecordExample</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span> ;<br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span>&#123;<br>a = <span class="hljs-number">1</span> ;                 <span class="hljs-comment">//步骤1</span><br>flag = <span class="hljs-literal">true</span> ；        <span class="hljs-comment">//步骤2</span><br>&#125;<br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">if</span>(flag)&#123;              <span class="hljs-comment">//步骤3</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> a * a;   <span class="hljs-comment">//步骤4</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>flag变量是个标记，用来标识变量a是否已被写入。这里假设有两个线程A和B，A首先执行writer()方法，随后B线程接着执行reader()。线程B在执行操作4时，能否看到线程A在操作1对共享变量a的写入呢？</p><p>答案是：不一定能看到。</p><p>由于操作1和操作2没有数据依赖关系，编译器和处理器可以对这两个操作重排序；同样，操作3和操作4没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。当操作1和操作2重排序时，可能产生什么效果？如下图。</p><p><img src="/../img/JMM/example-1.png" alt="程序执行时序图"></p><p>如上图，操作1和操作2做了重排序。程序执行时，线程A首先写标记变量flag，随后线程B读取这个变量。由于条件判断为真，线程B将读取变量a。此时，变量a还没有被线程A写入，在这里多线程的语义被重排序破坏了！</p><h2 id="5-原子性、可见性、有序性"><a href="#5-原子性、可见性、有序性" class="headerlink" title="5.原子性、可见性、有序性"></a>5.原子性、可见性、有序性</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><strong>原子性</strong></h3><p>一个或多个操作，要么全部执行且在执行过程中不被任何因素打断,要么全部不执行。在java中当我们讨论一个操作具有原子性问题一般是指这个操作会被线程的随机调度打断。比如下面的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;                   <span class="hljs-comment">//原子操作</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> b;                   <span class="hljs-comment">//非原子操作，分两步操作第一步读取b的值，第二部将b赋值a</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;               <span class="hljs-comment">//非原子操作，分两步操作第一步读取a的值，第二部将计算结果赋值给a</span><br>a ++ ;                       <span class="hljs-comment">//非原子操作，同上</span><br></code></pre></td></tr></table></figure><p><strong>JMM对原子性问题的保证如下：</strong></p><p><strong>自带原子性保证：</strong>在java中，对基本数据类型的变量的读取和赋值操作是原子性操作。</p><p><strong>synchronized：</strong>synchronized可以保证边界操作结果的原子性。synchronized可以防止多个线程并发的执行同一段代码，从结果上保证原子性。</p><p><strong>Lock锁：</strong>Lock锁保证原子性的原理和synchronized类似。</p><p><strong>原子类操作：</strong>JDK提供了很多原子操作类来保证操作的原子性，例如基础类型：AtomicXxx；引用类型AtomicReference等。原子类的底层是使用CAS机制，这个机制对原子性的保证和synchroinized有本质的区别。CAS机制保证了整个赋值操作是原子的不能被打断，二synchronized只能保证代码最终执行结果的正确性，也就是说，synchronized消除了原子性问题对代码最后执行结果的影响。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a><strong>可见性</strong></h3><p>在多线程环境下，一个线程对共享变量的修改，不仅要对本线程可见，而且要对其他线程可见。造成可见性的主要原因是由于CPU多核心和高速缓存（L1,L2,L3）。JMM对可见性问题，提供了如下保证：</p><p><strong>volatile：</strong>使用volatile关键字修饰一个变量可以保证变量的可见性，大概的保证语义如下（详细的参看volatile的内存语义章节）</p><ul><li>线程对共享变量的副本做了修改，会立刻刷新最新值到主内存中。</li><li>线程对共享变量的副本做了修改，其他其他线程中对这个变量拷贝的副本会时效；其他线程如果需要对这个共享变量进行读写，必须重新从主内存中加载。</li></ul><p><strong>synchronized：</strong>使用synchronized代码块或者synchronized方法也可以保证共享变量的可见性。当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把该线程对应的本地内存置为无效，从而使得被监听器保护的临界区代码必须从主内存中读取共享变量，从而实现共享变量的可见性。</p><p><strong>Lock锁：</strong>使用Lock相关实现类也可以保证共享变量的可见性。其原理同synchronized。</p><p><strong>原子操作类：</strong>原子类底层使用的是CAS机制。java中CAS机制每次都会从主内存中获取最新值进行compare，比较一致之后才会将新值set到主内存中去。而且这个操作是一个原子操作，所以CAS每次操作每次拿到的都是主内存中的最新值，每次set的值也会立即写到主内存中。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a><strong>有序性</strong></h3><p>程序执行的顺序按照代码的先后顺序执行。在JMM允许的重排序环境下，单线程的执行结果和没有重排序的情况下保持一致。JMM中提供一下方式来保证有序性：</p><p><strong>happens-before原则：</strong>happens-before原则是java内存模型中定义的两项操作之间的偏序关系，如果操作A先行发生于操作B，也就是说发生操作B之前，操作A产生的影响能被操作B观察到。这里的“影响”包括修改共享变量，方法调用。详细的happens-before说明请参看happens-before原则章节。</p><p><strong>synchronized机制：</strong>synchronized能够保证有序性是因为synchronized可以保证同一时间只有一个线程访问代码块，而单线程环境下，JMM能够保证代码的串行语义；虽然使用synchronized的代码块，还可以发生指令重排序，但是synchronized可以保证只有一个线程执行，所以最后的结果还是正确的。</p><p><strong>volatile机制：</strong>volatile的底层是使用内存屏障（详细请参看内存屏障章节）来保障有序性的。写volatile变量时，可以确保volatile写之前的操作不会被编译器重排序到volatile写之后。读volatile变量时，可以确保volatile读之后的操作不会被编译器重排序到volatile读之前。</p><p>多线程面临的两个问题线程之间的通信和线程之间的同步,这两个问题如果仔细分析，从结果的角度看线程之间的通信就是可见性问题，线程之间的同步就是原子性和有序性的问题。</p><p><strong>总结JMM对特性提供的支持如下：</strong></p><table><thead><tr><th>特性</th><th>volatile关键字</th><th>synchronized关键字</th><th>Lock接口</th><th>Atomic变量</th></tr></thead><tbody><tr><td>原子性</td><td>无法保障</td><td>可以保障</td><td>可以保障</td><td>可以保障</td></tr><tr><td>可见性</td><td>可以保障</td><td>可以保障</td><td>可以保障</td><td>可以保障</td></tr><tr><td>有序性</td><td>一定程度</td><td>可以保障</td><td>可以保障</td><td>无法保障</td></tr></tbody></table><h2 id="6-happens-before原则"><a href="#6-happens-before原则" class="headerlink" title="6. happens-before原则"></a><strong>6. happens-before原则</strong></h2><p>JSR133使用happens-before来阐述操作之间的内存可见性。在JMM中，如果一个操作的结果需要对另一个操作可见，那么这两个操作之间必然要存在happens-before关系。这里提到的两个操作既可以是一个线程之内，也可以是不同线程之间。</p><p>在《并发编程的艺术》一书中，对happens-before的定义如下：</p><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是一个线程之内，也可以是不同线程之间。两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。</p><p><strong>happens-before规则如下：</strong></p><p><strong>程序顺序规则（Program Order Rule）：</strong>一个线程中的每个操作，happens-before于该线程中的任意后续操作。</p><p><strong>监视器锁规则（Monitor Lock Rule）：</strong>对一个锁的解锁，happens-before于随后对这个锁的加锁。</p><p><strong>volatile变量规则（Volatile Variable Rule）：</strong>对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</p><p><strong>start()规则（Thread Start Rule）：</strong>如果线程A执行线程B.start()(启动线程B），那么A线程的B.start()操作happens-before于线程B中的任意操作。</p><p><strong>join()规则（Thread Join Rule）：</strong>如果线程A执行线程B.join()并成功返回，那么线程B中的任意操作happens-before于线程A从B.join()操作成功返回。</p><p><strong>程序中断规则（Thread Interruption Rule）：</strong>对线程interrupt()的调用happens-before于被中断线程的interrupted()或者isInterrupted()。</p><p><strong>finalizer规则（Finalizer Rule）：</strong>一个对象构造函数的结束happens-before于该对象finalizer()的开始。</p><p><strong>传递性规则（Transitivity）：</strong>如果A happens-before B，且B happens-before C ，那么A happens-before C。</p><p>了解了happens-before原则，下面举例帮助理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span><br>&#123;<br>    <span class="hljs-built_in">this</span>.value = value;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设两个线程A和B，线程A先（在时间上先）调用了这个对象的setValue(1),接着线程B调用了getValue（）方法，那么B的返回值是多少？</p><p>对照happens-before原则，上面的操作不满下面的条件：</p><ul><li>不是同一个线程，所以不涉及：程序顺序规则。</li><li>不涉及同步，所以不涉及：监视器锁规则。</li><li>没有volatile，所以不涉及：volatile变量规则。</li><li>没有线程的启动和中断，所以不涉及：start()规则，join规则，程序中断规则。</li><li>没有对象的创建和终结，所以不涉及：finalizer规则。</li><li>更没有传递规则。</li></ul><p>所以，一条规则都不满足，尽管线程A在时间上与线程B具有先后顺序，但是，却不满足happens-before原则，也就是有序性并不会保障，所以线程B获取到的数据是不安全的！！！这也反向说明了happens-before原则提到的关系和时间的先后顺序没有关系。</p><p><strong>时间先后顺序与先行发生原则之间基本没有太大关系，所以我们衡量并发安全问题的时候不要收到时间顺序的干扰，一切必须以先行发生原则为准。只有真正满足了happens-before原则，才能保证安全。</strong></p><h2 id="7-内存屏障"><a href="#7-内存屏障" class="headerlink" title="7.内存屏障"></a><strong>7.内存屏障</strong></h2><p>内存屏障（Memory Barrier），也称为内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以执行此点之后的操作。大多数现代计算机为了提高性能而采取乱序执行，这使得内存屏障成为必须。</p><p>语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。因此，对于敏感的程序块，写操作之后、读操作之前可以插入内存屏障。</p><h3 id="CPU层面的内存屏障"><a href="#CPU层面的内存屏障" class="headerlink" title="CPU层面的内存屏障"></a>CPU层面的内存屏障</h3><p>CPU层面的内存屏障分为三类：</p><p><strong>写屏障（Store Memory Barrier）：</strong>告诉处理器在写屏障之前的所有已经存储在存储缓存(store bufferes)中的数据同步到主内存，简单来说就是使得写屏障之前的指令的结果对写屏障之后的读或者写是可见的。</p><p><strong>读屏障（Load Memory Barrier）：</strong>处理器在读屏障之后的读操作,都在读屏障之后执行。配合写屏障，使得写屏障之前的内存更新对于读屏障之后的读操作是可见的。</p><p><strong>全屏障（Full Memory Barrier）</strong>：确保屏障前的内存读写操作的结果提交到内存之后，再执行屏障后的读写操作。</p><h3 id="JMM层面的内存屏障"><a href="#JMM层面的内存屏障" class="headerlink" title="JMM层面的内存屏障"></a>JMM层面的内存屏障</h3><p>在JMM中将内存屏障分为四类：LoadLoad Barrier；StoreStore Barrier；LoadStore Barrier；StoreLoad Barrier，内存屏障的详细解释如下表（来源于《并发编程艺术》）</p><table><thead><tr><th>屏障类型</th><th>指令示例</th><th>说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td>Load1;LoadLoad;Load2</td><td>确保Load1数据的装载先于Load2及所有后续装载指令的装载</td></tr><tr><td>StoreStore Barriers</td><td>Store1;StoreStore;Store2</td><td>确保Store1数据对其他处理器可见（刷新到内存）先于Store2及所有后续存储指令的存储</td></tr><tr><td>LoadStore Barriers</td><td>Load1;LoadStore;Store2</td><td>确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存</td></tr><tr><td>StoreLoad Barriers</td><td>Store1;StoreLoad;Load2</td><td>确保Store1数据对其他处理器变得可见（指刷新到内存）先于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访间指令（存储和装载指令）完成之后。才执行该屏障之后的内存访问指令</td></tr></tbody></table><h2 id="8-volatile的内存语义"><a href="#8-volatile的内存语义" class="headerlink" title="8.volatile的内存语义"></a>8.volatile的内存语义</h2><p>volatile是java提供的一种轻量级的同步机制，在并发编程中，它也扮演着比较重要的角色。一方面volatile不会造成上下文切换的开销，另一方面它又不能像synchronized那样保证所有场景下线程安全，因此必须在合适的场景下使用volatile机制。前面一个章节，我们了解到volatile可以支持可见性和有序性，那么它是通过怎样的机制来实现这些特性的？其核心原理就是上一章节描述的内存屏障。</p><p><strong>volatile写-读的内存语义</strong></p><ul><li>当写一个volatile变量时，JMM会把该线程对应的本地内存中的变量值刷新到主内存。</li><li>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程将从主内存中读取共享变量。</li></ul><p><strong>volatile内存语义的实现</strong></p><p>为了实现volatile的内存语义，JMM会限制两种类型的重排序，下图是JMM针对编译器指定的volatile重排序规则表：</p><table><thead><tr><th>是否能重排序</th><th>第二个操作</th><th></th><th></th></tr></thead><tbody><tr><td>第一个操作</td><td>普通读&#x2F;写</td><td>volatile读</td><td>volatile写</td></tr><tr><td>普通读&#x2F;写</td><td></td><td></td><td>NO</td></tr><tr><td>volatile读</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>volatile写</td><td></td><td>NO</td><td>NO</td></tr></tbody></table><ul><li>当第二个操作为volatile写操作时，不管第一个操作是什么，都不能进行重排序。这个规则确保volatile写之前的所有操作都不会被重排序到volatile写之后。</li><li>当第一个操作为volatile读操作时，不管第二个操作时什么，都不能进行重排序。这个规则确保volatile读之后的所有操作都不会被重排序到volatile读之前。</li><li>当第一个操作时volatile写操作时，第二个操作时读操作，不能进行重排序。</li></ul><p>为了实现以上规则，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序，下面是基于保守策略（根据不同虚拟机策略不同）的JMM内存屏障插入策略：</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障（禁止前面的写与volatile写重排序）。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障（禁止volatile写与后面可能有的读和写重排序）。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障（禁止volatile读与后面的读操作重排序）。</li><li>在每个volatile读操作的后面插入一个LoadStore屏障（禁止volatile读与后面的写操作重排序）。</li></ul><p>下图为volatile写操作插入内存屏障后生成的指令序列示意图。</p><p><img src="/../img/JMM/volatile-write.png" alt="volatile写操作的内存屏障示意"></p><p>下图为volatile读操作插入内存屏障后生成的指令序列示意图：</p><p><img src="/../img/JMM/volatile-read.png" alt="volatile读操作的内存屏障示意"></p><p>上述volatile写和volatile读的内存屏障插入策略非常保守，在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况忽略不必要的屏障。</p><h2 id="9-final的内存语义"><a href="#9-final的内存语义" class="headerlink" title="9.final的内存语义"></a>9.final的内存语义</h2><p>在平时的开发过程中常常使用final关键字来修饰方法，保证方法不能被子类重写，那使用final修饰变量又表达什么内存语义呢？</p><p><strong>final的内存语义</strong></p><ul><li>在构造函数内对一个final域的写入，与随后把这个构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>初次读取一个包含final域对象的引用，与随后初次读取这个final域，这两个操作之间不能重排序。</li></ul><p><strong>final的内存语义实现</strong></p><ul><li>写final域的重排序规则会要求编译器在final域写之后，构造函数返回之前，插入一个StoreStore屏障。</li><li>读final域的重排序规则会要求编译器在final域读之前插入一个LoadLoad屏障。</li></ul><h1 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&mid=2247533850&idx=4&sn=7477c8346a738e9a234c3b85f1cd0bc4&chksm=fbb1cce4ccc645f238e66ee5d45c9aa85c51f47987a8719e035b51ec8d49c75457b18a1dfae3&scene=27">https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&amp;mid=2247533850&amp;idx=4&amp;sn=7477c8346a738e9a234c3b85f1cd0bc4&amp;chksm=fbb1cce4ccc645f238e66ee5d45c9aa85c51f47987a8719e035b51ec8d49c75457b18a1dfae3&amp;scene=27</a></p><p>文章来源于京东技术 ，作者潘坤 郑冰</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面经2023-07-06</title>
    <link href="/2023/07/06/Interview-Exp-20230706/"/>
    <url>/2023/07/06/Interview-Exp-20230706/</url>
    
    <content type="html"><![CDATA[<h1 id="小米JAVA软开"><a href="#小米JAVA软开" class="headerlink" title="小米JAVA软开"></a>小米JAVA软开</h1><p>来源：牛客 众所周周知</p><p><a href="https://www.nowcoder.com/discuss/494189564689387520?sourceSSR=users">https://www.nowcoder.com/discuss/494189564689387520?sourceSSR=users</a></p><h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><h2 id="1-Redis-如何清除过期数据？"><a href="#1-Redis-如何清除过期数据？" class="headerlink" title="1.Redis 如何清除过期数据？"></a>1.Redis 如何清除过期数据？</h2><h4 id="Redis的缓存清除策略："><a href="#Redis的缓存清除策略：" class="headerlink" title="Redis的缓存清除策略："></a>Redis的缓存清除策略：</h4><h5 id="1-惰性删除"><a href="#1-惰性删除" class="headerlink" title="1.惰性删除"></a>1.惰性删除</h5><p>可以通过在需要使用缓存时检查它是否过期，并在过期时清除它。这种策略可以节省内存空间，但需要在访问缓存时进行额外的检查和处理。这种策略适用于缓存数据量较大，但不需要维护过期时间的场景。</p><h5 id="2-定时过期策略"><a href="#2-定时过期策略" class="headerlink" title="2.定时过期策略"></a>2.定时过期策略</h5><p>可以通过设置键的过期时间来自动清除过期的缓存。当键过期时，Redis会自动删除它，以释放内存空间。这种策略适合于需要具有一定时效性的缓存数据。</p><h5 id="3-LRU（Least-Recently-Used）策略"><a href="#3-LRU（Least-Recently-Used）策略" class="headerlink" title="3.LRU（Least Recently Used）策略"></a>3.LRU（Least Recently Used）策略</h5><p>可以通过记录每个键的访问时间，并在需要清除缓存时删除最近最少使用的缓存。这种策略可以最大程度地利用内存空间，但需要维护额外的数据结构来记录缓存的访问时间。这种策略适用于需要缓存大量数据，并且需要保持最常用数据的缓存的场景。</p><h5 id="4-LFU（Least-Frequently-Used）策略"><a href="#4-LFU（Least-Frequently-Used）策略" class="headerlink" title="4.LFU（Least Frequently Used）策略"></a>4.LFU（Least Frequently Used）策略</h5><p>可以通过记录每个键的访问次数，以及在需要清除缓存时删除最少使用的缓存。这种策略可以在缓存访问次数相对均匀的情况下，最大程度地利用内存空间，但需要维护额外的数据结构来记录缓存的访问次数。这种策略适用于需要缓存大量数据，并且需要保持最常用数据的缓存的场景。</p><h2 id="2-Redis-的持久化机制。"><a href="#2-Redis-的持久化机制。" class="headerlink" title="2.Redis 的持久化机制。"></a>2.Redis 的持久化机制。</h2><p>RDB：<a href="https://bigducksoup.github.io/2023/05/10/redis-rdb/">https://bigducksoup.github.io/2023/05/10/redis-rdb/</a></p><p>AOF：<a href="https://bigducksoup.github.io/2023/05/13/redis-aof/">https://bigducksoup.github.io/2023/05/13/redis-aof/</a></p><h2 id="3-RDB-和-AOF-方式有什么区别？为什么提供第三种混合方式？"><a href="#3-RDB-和-AOF-方式有什么区别？为什么提供第三种混合方式？" class="headerlink" title="3.RDB 和 AOF 方式有什么区别？为什么提供第三种混合方式？"></a>3.RDB 和 AOF 方式有什么区别？为什么提供第三种混合方式？</h2><p><strong>它们之间的区别如下</strong></p><ol><li>RDB：RDB是一种快照式持久化方式，它会定期将Redis的内存数据快照写入磁盘，以备份数据。RDB的优点是备份数据方便、恢复速度快，适合用于数据量较大、备份频率较低的场景。</li><li>AOF：AOF是一种日志式持久化方式，它会将Redis的写操作以追加的方式记录到一个文件中，以保证数据的持久性。AOF的优点是数据可靠性高、可恢复性好，适合用于需要保证数据完整性和可靠性的场景。</li></ol><p><strong>混合持久化</strong></p><p>重启Redis时，我们很少使用RDB来恢复内存状态，因为会丢失大量数据。我们通常使用AOF日志重放，但是重放AOF日志性能相对于RDB来说慢很多，在Redis实例大的情况下，启动需要花费很长时间，Redis4.0之后提供了新的持久化机制，混合持久化<br>修改配置开启混合持久化（需开启aof）</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">aof‐<span class="hljs-keyword">use</span>‐rdb‐preamble yes<br></code></pre></td></tr></table></figure><p>如果开启了混合持久化，AOF在重写时，不再单纯的将内存数据转换为resp命令写入AOF文件，而是将重写这一刻之前的内存做了RDB快照处理，并且将RDB快照内容和增量AOF修改内存数据的命令存在一起，都写入新的AOF文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。在Redis重启时，可以先加载RDB内容，然后再重放增量AOF日志就可以完全替代之前的AOF全量文件重放，重启效率大幅度提升</p><h2 id="4-Redis-缓存异常的三个问题以及如何解决？"><a href="#4-Redis-缓存异常的三个问题以及如何解决？" class="headerlink" title="4.Redis 缓存异常的三个问题以及如何解决？"></a>4.Redis 缓存异常的三个问题以及如何解决？</h2><p>缓存穿透：<a href="https://bigducksoup.github.io/2023/05/30/redis-cache-penetration/">https://bigducksoup.github.io/2023/05/30/redis-cache-penetration/</a></p><p>缓存击穿：<a href="https://bigducksoup.github.io/2023/06/08/redis-cache-breakdown/">https://bigducksoup.github.io/2023/06/08/redis-cache-breakdown/</a></p><p>缓存雪崩：<a href="https://bigducksoup.github.io/2023/06/09/redis-cache-avalanche/">https://bigducksoup.github.io/2023/06/09/redis-cache-avalanche/</a></p><h2 id="5-布隆过滤器存在什么问题？"><a href="#5-布隆过滤器存在什么问题？" class="headerlink" title="5.布隆过滤器存在什么问题？"></a>5.布隆过滤器存在什么问题？</h2><ol><li>误判率：布隆过滤器是一种概率性数据结构，因此存在一定的误判率。这是因为在哈希冲突的情况下，多个元素可能被映射到同一个位上，从而导致误判。</li><li>不支持删除操作：由于布隆过滤器是基于哈希表实现的，删除一个元素可能会影响其他元素的判断结果。因此，布隆过滤器通常不支持删除操作。</li></ol><h2 id="6-Java-内存模型。"><a href="#6-Java-内存模型。" class="headerlink" title="6.Java 内存模型。"></a>6.Java 内存模型。</h2><p><a href="https://bigducksoup.github.io/2023/07/06/JMM/">https://bigducksoup.github.io/2023/07/06/JMM/</a></p><h2 id="7-介绍下原子性、可见性和有序性，以及如何实现？"><a href="#7-介绍下原子性、可见性和有序性，以及如何实现？" class="headerlink" title="7.介绍下原子性、可见性和有序性，以及如何实现？"></a>7.介绍下原子性、可见性和有序性，以及如何实现？</h2><p>原子性（Atomicity）、可见性（Visibility）和有序性（Ordering）是多线程编程中的三个重要概念。</p><p><strong>原子性</strong>指的是一个操作是不可分割的，要么全部执行成功，要么全部不执行。在并发编程中，原子性可以保证多个线程对共享变量的操作不会相互干扰，从而避免了数据不一致的问题。常见的实现方式包括使用锁、CAS（Compare and Swap）操作等。</p><p><strong>可见性</strong>指的是一个线程对共享变量的修改能够被其他线程立即看到。在多线程编程中，由于存在线程间的竞争，一个线程对共享变量的修改可能不会立即写入主存，而是先写入缓存。如果其他线程读取的是缓存中的数据，就会导致数据不一致的问题。为了解决这个问题，可以使用volatile关键字或者synchronized关键字来实现可见性。</p><p><strong>有序性</strong>指的是程序执行的顺序与代码的顺序一致。在多线程编程中，由于存在指令重排的优化，程序的执行顺序可能与代码的顺序不一致，从而导致程序的行为出现问题。为了避免这个问题，可以使用volatile关键字或者synchronized关键字来实现有序性。</p><p>在实际编程中，为了保证原子性、可见性和有序性，可以采用以下几种方式：</p><ol><li>使用synchronized关键字或者Lock接口来实现原子性、可见性和有序性。</li><li>使用volatile关键字来实现可见性和有序性。</li><li>使用Atomic类来实现原子性。</li><li>使用Concurrent包中的并发容器来实现原子性和可见性。</li></ol><h2 id="7-volatile-关键字如何实现的？"><a href="#7-volatile-关键字如何实现的？" class="headerlink" title="7.volatile 关键字如何实现的？"></a>7.volatile 关键字如何实现的？</h2><p><strong>可见性</strong></p><p>每个线程都有自己的工作内存（寄存器、高速缓存组成），线程之间是通过主内存进行通信。即线程A把从主内存读取，然后进行运算，将运算后的结果从自己的工作内存写回到主内存，当线程A写回完成之后，其他线程再去主内存读取，就可以得到线程A处理的结果，完成通信。但是，线程A不会经常回写主内存，不然的话处理速度就慢死了，不回写其他的线程就看不到处理之后的数据，只能得到之前的数据。线程看到的数据不一致，就造成可见性问题。</p><p>计算机的处理器运行速度要比内存的读取速度快好几个数量级。但是整个运算流程必须是先从内存中读取某个数据，然后交给处理器，随后将结果再写回到内存中。如果这样的话整个运行的速度就会被卡在内存上，内存读取有多快整体运算有多快，就算处理器再好也没用。巧妇难为无米之炊，从内存读取的数据就是处理器需要的米。遇到海量高并发的时候有个统一思想，异步缓存批量处理。这里采用的就是批量处理，直接从内存中读取一批数据，然后统一交给处理器处理，等处理完成之后统一写回到内存中。</p><p><strong>所以普通的数据是不会立即写回到主内存中的，而是先保存在工作内存中。但是如果用volatile修饰，会让工作内存立即写回到主内存或者从主内存中重新读取，保证数据的可见性。</strong></p><p><strong>Lock前缀</strong></p><p>有 volatile 变量修饰的共享变量进行写操作的时候会多出一行汇编代码，且是Lock指令开头。Lock 前缀的指令在多核处理器下会引发了两件事情：<br>1.将当前处理器缓存行的数据写回到系统内存。<br>2.这个写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</p><p>Lock前缀指令导致在指令执行期间，声言处理器的LOCK#信号，LOCK#信号会保证在声言此信号期间，处理器可以独占任何共享内存。一部分处理器是通过锁住总线，总线控制读写，锁住总线意味着其他的处理器没有办法访问共享内存，此时只有当前的处理器可以访问内存，实现了独占共享内粗功能。但是锁住总线的代价是很大的，所以另一部分处理器采取的是锁住缓存，如果要写入的内存区域已经缓存在处理器内部，则不会声言LOCK#信号，而是锁定内存区域的缓存并将他写回到内存中，并使用缓存一致性机制来确保修改的原子性，此操作被称为“缓存锁定”，缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。</p><p>当一个处理器缓存写回到内存时，其他处理器的中此缓存数据将无效。每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是否过期，当处理器发现自己缓存行对应的总线地址被修改，就会将当前处理器的缓存设置为无效，当处理器需要此数据时，会重新从共享内存中读取。</p><p><strong>缓存一致性机制</strong></p><p>总线加锁是对整个共享内存，此时其他的处理器无法从共享内存读取数据，会严重降低CPU的处理能力。缓存一致性协议只会对单个缓存行的数据进行加锁，不会影响到内存中其数据的读写。缓存一致性协议有：MSI、MESI、MOSI等。MESI协议只对汇编指令中执行加锁操作的变量有效，表现到java中为使用voliate关键字定义变量或使用加锁操作。</p><p>MESI协议有四种状态：修改、独占、共享、无效</p><table><thead><tr><th>状态</th><th>描述</th><th>监听任务</th></tr></thead><tbody><tr><td>M修改（modified）</td><td>该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</td><td>缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在<br/>缓存将该缓存行写回主存并将状态变成S(共享)状态之前被延迟执行。</td></tr><tr><td>E独享、互斥(exclusive)</td><td>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</td><td>缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S(共享)状态。</td></tr><tr><td>S共享(shared)</td><td>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</td><td>缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效(Invalid)</td></tr><tr><td>I无效(Invalid)</td><td>该Cache line无效</td><td>无</td></tr></tbody></table><p>大致流程如下：<br>1.线程A读取数据Q，将数据Q的状态设置为E（独享、互斥），同时通过总线嗅探机制对共享内存中的数据Q进行嗅探</p><p>2.线程B再次读取数据Q， 总线嗅探将线程A中的Q设置为S（共享），线程B的Q状态也是S共享</p><p>3.线程A修改数据Q， 线程A中的状态变为M（修改），而线程B将会被通知修改为I（无效）。无效的数据将不会被操作，需要从共享内存中重新读取。如果有多个线程同时修改Q，那么总线会进行裁决，某一个变为M，其他的都变为I。</p><p>4.线程A将Q回写内存，此时状态变为E（独占），因为只有他时新数据，其他线程都无效，相当都独享。</p><p>5.线程B通过总线嗅探机制得知Q已经回写到内存，重新读取Q，状态为S，同时线程A中的状态也变成S。</p><h2 id="8-Java-实现同步机制的有哪些方法？加锁方式有哪些？"><a href="#8-Java-实现同步机制的有哪些方法？加锁方式有哪些？" class="headerlink" title="8.Java 实现同步机制的有哪些方法？加锁方式有哪些？"></a>8.Java 实现同步机制的有哪些方法？加锁方式有哪些？</h2><p><strong>Java实现同步机制的方式有以下几种</strong></p><ol><li>synchronized关键字：synchronized是Java中最基本的同步机制，通过在方法或代码块上加锁来实现线程同步。</li><li>Lock接口：Java5引入了Lock接口，提供了比synchronized更加灵活和强大的锁机制。Lock接口有多个实现类，例如ReentrantLock、ReentrantReadWriteLock等。</li><li>volatile关键字：volatile关键字可以保证变量的可见性和有序性，但无法保证原子性，适用于非常简单的同步场景。</li><li>Atomic类：Java中提供了多个原子类，例如AtomicInteger、AtomicLong等，可以保证对变量的操作具有原子性和可见性。</li><li>信号量（Semaphore）：Semaphore是一种计数器，用于控制同时访问某个资源的线程数量。</li><li>读写锁（ReentrantReadWriteLock）：读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。</li></ol><p>加锁方式有以下几种</p><ol><li>对象锁：使用synchronized关键字或者Lock接口实现的锁机制，可以锁定对象或者代码块，保证同一时间只有一个线程访问。</li><li>类锁：使用synchronized关键字实现的类锁可以锁定整个类，保证同一时间只有一个线程访问。</li><li>读写锁：使用ReentrantReadWriteLock实现的锁机制，可以在读多写少的场景下提高效率。</li><li>原子性操作：使用Atomic类提供的原子性操作可以保证对变量的操作具有原子性和可见性。</li></ol><h2 id="9-synchronized-关键字修饰方法和修饰代码块有什么区别？"><a href="#9-synchronized-关键字修饰方法和修饰代码块有什么区别？" class="headerlink" title="9.synchronized 关键字修饰方法和修饰代码块有什么区别？"></a>9.synchronized 关键字修饰方法和修饰代码块有什么区别？</h2><p><strong>同步方法</strong><br>在Java中，我们可以使用Synchronized关键字修饰方法来实现线程同步。当一个线程进入被Synchronized关键字修饰的方法时，该线程会自动获取该方法所在对象的锁。其他线程如果想要访问该方法，只能等待该线程执行完毕并释放锁之后才能获取锁进入该方法。下面是一个使用Synchronized修饰方法的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        count++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用Synchronized关键字修饰了increment()和getCount()两个方法。当一个线程进入increment()方法时，它会自动获取SynchronizedTest对象的锁并执行count++操作，其他线程如果想要访问increment()方法，必须等待该线程执行完毕并释放锁之后才能获取锁进入该方法。同理，当一个线程进入getCount()方法时，它也会自动获取SynchronizedTest对象的锁并返回count值，其他线程必须等待该线程执行完毕并释放锁之后才能获取锁进入该方法。</p><p><strong>同步块</strong><br>除了使用Synchronized修饰方法之外，我们还可以使用同步块来实现线程同步。同步块是指在代码块中使用Synchronized关键字来实现线程同步。在同步块中，我们需要指定一个锁对象，该锁对象可以是任意对象。当一个线程进入同步块时，它会自动获取该锁对象的锁，其他线程如果想要访问同步块中的代码，必须等待该线程执行完毕并释放锁之后才能获取锁进入该代码块。下面是一个使用同步块的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(lock) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(lock) &#123;<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们使用了一个Object类型的lock对象来作为锁对象，并在increment()和getCount()方法中使用同步块来实现线程同步。当一个线程进入increment()方法时，它会自动获取lock对象的锁并执行count++操作，其他线程如果想要访问increment()方法，必须等待该线程执行完毕并释放lock对象的锁之后才能获取锁进入该方法。同理，当一个线程进入getCount()方法时，它也会自动获取lock对象的锁并返回count值，其他线程必须等待该线程执行完毕并释放lock对象的锁之后才能获取锁进入该方法。</p><p><strong>二者区别</strong><br>在使用Synchronized机制时，我们可以选择Synchronized修饰方法或者使用同步块来实现线程同步。虽然它们都可以实现线程同步，但是它们之间存在一些区别。</p><p><strong>锁的粒度不同</strong><br>Synchronized修饰方法是以对象为锁的粒度进行同步的，而同步块是以代码块为锁的粒度进行同步的。在使用Synchronized修饰方法时，如果该方法中包含了多个代码块，那么这些代码块都会被该方法所在对象的锁所保护。这种方式在多线程并发访问时，可能会导致锁的竞争，从而影响程序的性能。而使用同步块时，我们可以控制锁的粒度，只将需要同步的代码块进行同步，避免了不必要的锁竞争，提高了程序的性能。</p><p><strong>锁的获取时间不同</strong><br>Synchronized修饰方法是在进入方法时自动获取锁的，而同步块需要手动获取锁。在使用Synchronized修饰方法时，如果该方法执行时间较长，其他线程需要等待该方法执行完毕并释放锁之后才能获取锁进入该方法。而使用同步块时，我们可以手动获取和释放锁，在代码块执行完毕之后立即释放锁，避免了其他线程等待的时间，提高了程序的运行效率。</p><p><strong>锁的释放时间不同</strong><br>Synchronized修饰方法是在方法执行完毕之后自动释放锁的，而同步块需要手动释放锁。在使用Synchronized修饰方法时，如果该方法中包含了多个代码块，那么其他线程必须等待该方法执行完毕并释放锁之后才能获取锁进入其他代码块。而使用同步块时，我们可以手动控制锁的释放时间，在代码块执行完毕之后立即释放锁，避免了不必要的锁竞争，提高了程序的运行效率。</p><p>综上所述，Synchronized修饰方法与代码块之间存在一些区别。在实际应用中，我们应该根据具体场景和需求来灵活选择和使用，以保证程序的性能和安全性。</p><h2 id="10-线程池如何创建和管理？"><a href="#10-线程池如何创建和管理？" class="headerlink" title="10.线程池如何创建和管理？"></a>10.线程池如何创建和管理？</h2><blockquote><p>阿里巴巴《Java开发手册》</p><p>【强制要求】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br>说明：Executors 返回的线程池对象的弊端如下：<br>1） FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。<br>2）CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数 1：corePoolSize<br>核心线程数，线程池中始终存活的线程数。</p><p>参数 2：maximumPoolSize<br>最大线程数，线程池中允许的最大线程数，当线程池的任务队列满了之后可以创建的最大线程数。</p><p>参数 3：keepAliveTime<br>最大线程数可以存活的时间，当线程中没有任务执行时，最大线程就会销毁一部分，最终保持核心线程数量的线程。</p><p>参数 4：unit:<br>单位是和参数 3 存活时间配合使用的，合在一起用于设定线程的存活时间 。</p><p>参数 5：workQueue<br>一个阻塞队列，用来存储线程池等待执行的任务，均为线程安全，它包含以下 7 种类型：较常用的是 LinkedBlockingQueue 和 Synchronous，线程池的排队策略与 BlockingQueue 有关。</p><p>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。<br>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。<br>SynchronousQueue：一个不存储元素的阻塞队列，即直接提交给线程不保持它们。<br>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。<br>DelayQueue：一个使用优先级队列实现的无界阻塞队列，只有在延迟期满时才能从中提取元素。<br>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。与SynchronousQueue类似，还含有非阻塞方法。<br>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</p><p>参数 6：threadFactory<br>线程工厂，主要用来创建线程，默认为正常优先级、非守护线程。</p><p>参数 7：handler<br>拒绝策略，拒绝处理任务时的策略，系统提供了 4 种可选：默认策略为 AbortPolicy。</p><p>AbortPolicy：拒绝并抛出异常。<br>CallerRunsPolicy：使用当前调用的线程来执行此任务。<br>DiscardOldestPolicy：抛弃队列头部（最旧）的一个任务，并执行当前任务。<br>DiscardPolicy：忽略并抛弃当前任务。</p><p><strong>ThreadPoolExecutor 关键节点的执行流程如下：</strong></p><p>当线程数小于核心线程数时，创建线程。<br>当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。<br>当线程数大于等于核心线程数，且任务队列已满：若线程数小于最大线程数，创建线程；若线程数等于最大线程数，抛出异常，拒绝任务。</p><h2 id="11-当用户量特别大的时候，如何设计用户表？"><a href="#11-当用户量特别大的时候，如何设计用户表？" class="headerlink" title="11.当用户量特别大的时候，如何设计用户表？"></a>11.当用户量特别大的时候，如何设计用户表？</h2><p>当用户量非常大时，需要考虑用户表的性能和扩展性，例如使用索引、分库分表、缓存等技术来提高系统的性能和可扩展性。同时，需要对用户表进行定期维护和优化，例如清理无用数据、压缩表空间、优化查询语句等。</p><h2 id="12-索引有哪些？"><a href="#12-索引有哪些？" class="headerlink" title="12.索引有哪些？"></a>12.索引有哪些？</h2><p>按照数据结构维度划分：</p><ul><li>BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。</li><li>哈希索引：类似键值对的形式，一次即可定位。</li><li>RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><p>按照底层存储方式角度划分：</p><ul><li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li><li>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li></ul><p>按照应用维度划分：</p><ul><li>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li><li>普通索引：仅加速查询。</li><li>唯一索引：加速查询 + 列值唯一（可以有 NULL）。</li><li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li><li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><p>MySQL 8.x 中实现的索引新特性：</p><ul><li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li><li>降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li><li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li></ul><h2 id="13-索引失效有哪些情况？"><a href="#13-索引失效有哪些情况？" class="headerlink" title="13.索引失效有哪些情况？"></a>13.索引失效有哪些情况？</h2><ol><li><p>MySQL 可以为多个字段创建索引，一个索引可以包括 16 个字段。对于多列索引，过滤条件要使用索引，必须按照索引建立的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。如果查询条件中没有使用这些字段中第 1 个字段时，多列（或联合）索引不会被使用。</p></li><li><p>计算、函数、类型转换（自动或手动）导致索引失效</p></li><li><p>范围条件右边的列索引失效</p><blockquote><p>应用开发中范围查询，例如：金额查询，日期查询往往都是范围查询。应将查询条件放置 WHERE 语句最后。（创建的联合索引中，务必把范围涉及到的字段写在最后）</p></blockquote></li><li><p>不等于（ !&#x3D; 或者 &lt;&gt; ）索引失效</p></li><li><p>is null 可以使用索引，is not null 无法使用索引</p></li></ol><blockquote><p>最好在设计数据表的时候就将字段设置为 NOT NULL 约束，比如可以将 INT 类型的字段，默认值设置为 0。将字符类型的默认值设置为空字符串 ‘’ 。同理，在查询中使用 not like 也无法使用索引，导致全表扫描</p></blockquote><ol start="6"><li><p>like 以通配符 % 开头索引失效</p></li><li><p>OR 前后存在非索引的列，索引失效</p></li><li><p>数据表和表的字符集统一使用 utf8mb4</p></li></ol><h2 id="14-如何排查数据库查询速度比较慢的问题？"><a href="#14-如何排查数据库查询速度比较慢的问题？" class="headerlink" title="14.如何排查数据库查询速度比较慢的问题？"></a>14.如何排查数据库查询速度比较慢的问题？</h2><p>开启慢查询日志<br>SQL慢查询是指执行时间较长的SQL语句，可能导致系统性能下降和响应时间延长。通过以下步骤可以开启慢查询日志记录：</p><p>#查询是否开启慢查询日志 slow_query_log显示ON说明已开启，显示OFF说明未开启</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%slow_query_log%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>#开启慢查询日志</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> slow_query_log <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>确认慢查询日志是否已开启 slow_query_log的值应该为ON，表示慢查询日志已经成功开启。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%slow_query_log%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>#默认情况下，MySQL会将执行时间超过10秒的查询认定为慢查询</p><p>设置全局的超过5秒就记录到日志文件中 如果等于0可以记录所有的SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> long_query_time <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>慢查询日志的记录位置命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%slow_query_log_file%&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="15-SQL返回部分字段和返回全部字段有什么区别-应该是想问Select-与-Select-字段-的区别-？"><a href="#15-SQL返回部分字段和返回全部字段有什么区别-应该是想问Select-与-Select-字段-的区别-？" class="headerlink" title="15.SQL返回部分字段和返回全部字段有什么区别(应该是想问Select * 与 Select 字段 的区别)？"></a>15.SQL返回部分字段和返回全部字段有什么区别(应该是想问Select * 与 Select 字段 的区别)？</h2><p>1、查询效率上：select * 在系统解析的时候会多一步从系统表获取具体字段的步骤，因此会比select 全部字段多花时间，效率稍低。</p><p>2、查询结果上：在表结构不修改的情况下结果相同，但是后者的顺序可以调整，前者则固定；而如果修改了表结构，前者能够获得新表结构的所有字段，后者则会在修改字段名或删除字段时报错，会在增加字段时不会输出新字段。</p><p>3、应用场景上：select * 效率稍低但是能应对频繁调整的表结构，适应力强，可应用于开发环境，仅极少数特殊业务场景会在生产环境使用场景；后者效率稍高语意明确，更能清晰的表达业务的需求，强烈建议在生产环境中使用。</p><h2 id="16-MySQL-索引的数据结构，B-树的优点。"><a href="#16-MySQL-索引的数据结构，B-树的优点。" class="headerlink" title="16.MySQL 索引的数据结构，B+ 树的优点。"></a>16.MySQL 索引的数据结构，B+ 树的优点。</h2><p>MySQL中常用的索引数据结构是B+树，B+树是一种多路搜索树，具有以下优点：</p><ol><li>高效的范围查询：B+树的叶子节点是按照顺序存储的，可以快速进行范围查询和排序操作。</li><li>磁盘读写优化：B+树的非叶子节点只存储键值信息，不存储数据信息，可以减少磁盘读写次数，提高IO效率。</li><li>支持高并发：B+树的读写操作是基于页的，可以减少锁的粒度，提高并发性能。</li><li>索引高度稳定：B+树的高度稳定，查询效率稳定，不会因为数据量的增加而导致性能下降。</li><li>支持快速插入和删除：B+树的叶子节点是链表结构，可以快速进行插入和删除操作。</li></ol><h2 id="17-分布式下，如何获取全局的唯一ID，有哪些方式？"><a href="#17-分布式下，如何获取全局的唯一ID，有哪些方式？" class="headerlink" title="17.分布式下，如何获取全局的唯一ID，有哪些方式？"></a>17.分布式下，如何获取全局的唯一ID，有哪些方式？</h2><p>​在分布式系统中，获取全局唯一ID是非常重要的。下面介绍几种获取全局唯一ID的方式：</p><ol><li>UUID：UUID是一种128位的全局唯一标识符，可以使用UUID算法生成唯一ID。UUID具有无序性、唯一性和方便生成等优点，可以用于分布式系统的唯一ID生成。</li><li>雪花算法：雪花算法是一种基于时间戳、机器ID和序列号的算法，可以生成全局唯一ID。雪花算法具有高效性、可扩展性和可读性等优点，被广泛应用于分布式系统中。</li></ol><h2 id="18-设计分布式下的唯一ID，你会考虑哪些因素？"><a href="#18-设计分布式下的唯一ID，你会考虑哪些因素？" class="headerlink" title="18.设计分布式下的唯一ID，你会考虑哪些因素？"></a>18.设计分布式下的唯一ID，你会考虑哪些因素？</h2><p>设计分布式下的唯一ID需要考虑以下因素：</p><ol><li>唯一性：ID必须在分布式环境下全局唯一，不能出现重复的情况。</li><li>性能：ID的生成过程应该尽可能地快速，不应该成为系统的瓶颈。</li><li>可扩展性：ID的生成应该能够随着系统的扩展而扩展，支持高并发的生成请求。</li><li>可读性：ID的格式应该易于识别和理解，方便人类进行调试和排查问题。</li><li>安全性：ID应该足够难以被猜测或伪造，防止恶意攻击。</li><li>有序性：ID的生成应该具有一定的有序性，方便对数据进行排序或查找。</li></ol><h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><h2 id="1-随着项目中的数据量不断增大，觉得会有哪些问题和挑战？如何解决？"><a href="#1-随着项目中的数据量不断增大，觉得会有哪些问题和挑战？如何解决？" class="headerlink" title="1.随着项目中的数据量不断增大，觉得会有哪些问题和挑战？如何解决？"></a>1.随着项目中的数据量不断增大，觉得会有哪些问题和挑战？如何解决？</h2><p>随着项目中的数据量不断增大，可能会出现以下问题和挑战：</p><ol><li>数据读写效率下降：随着数据量的增大，查询和写入数据的效率可能会下降，导致系统响应时间变慢。这时需要考虑优化数据库索引、分表分库等方式来提高数据读写效率。</li><li>数据存储成本增加：随着数据量的增大，数据存储成本也会随之增加。这时需要考虑使用压缩和归档等方式来减少数据存储成本。</li><li>数据安全性问题：随着数据量的增大，数据安全性问题也会变得更加重要。需要考虑加强数据加密、访问控制等方式来提高数据安全性。</li><li>数据一致性问题：随着数据量的增大，数据一致性问题也会变得更加显著。需要考虑使用分布式事务、分布式锁等方式来解决数据一致性问题。</li><li>数据备份和恢复问题：随着数据量的增大，数据备份和恢复也会变得更加困难。需要考虑使用分布式备份和恢复等方式来解决数据备份和恢复问题。</li></ol><p>为解决以上问题和挑战，可以采取以下措施：</p><ol><li>数据库优化：优化数据库索引、分表分库、数据库缓存等，提高数据读写效率。</li><li>数据压缩和归档：使用数据压缩和归档等方式，减少数据存储成本。</li><li>数据加密和访问控制：加强数据加密、访问控制等方式，提高数据安全性。</li><li>分布式事务和分布式锁：使用分布式事务、分布式锁等方式，解决数据一致性问题。</li><li>分布式备份和恢复：使用分布式备份和恢复等方式，解决数据备份和恢复问题。</li></ol><h2 id="2-数据量很大时，软件层面或设计层面有什么考虑？"><a href="#2-数据量很大时，软件层面或设计层面有什么考虑？" class="headerlink" title="2.数据量很大时，软件层面或设计层面有什么考虑？"></a>2.数据量很大时，软件层面或设计层面有什么考虑？</h2><p>当数据量很大时，软件层面或设计层面需要考虑以下几个方面：</p><ol><li>数据库设计：需要根据数据量的大小和业务需求，设计合理的数据库结构、索引和分表分库策略，以提高数据读写效率和可扩展性。</li><li>数据存储和访问：需要考虑使用合适的数据存储和访问方式，例如使用缓存技术、分布式文件系统等方式，提高数据读写效率和可靠性。</li><li>数据处理和分析：需要考虑使用合适的数据处理和分析工具，例如使用MapReduce、Spark等方式，处理和分析大规模数据，提高数据价值和应用效果。</li><li>性能优化：需要对系统进行性能优化，例如使用异步编程、多线程等方式，提高系统的并发性能和响应时间。</li><li>安全性和稳定性：需要考虑加强系统的安全性和稳定性，例如使用备份和恢复、灾备容灾等方式，保障系统的可靠性和稳定性。</li><li>数据一致性：需要考虑解决数据一致性问题，例如使用分布式事务、分布式锁等方式，确保数据的一致性和可靠性。</li></ol><h2 id="3-MySQL-存储引擎。"><a href="#3-MySQL-存储引擎。" class="headerlink" title="3.MySQL 存储引擎。"></a>3.MySQL 存储引擎。</h2><p><strong>InnoDB和MyISAM</strong></p><p>事务: InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</p><p>并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</p><p>外键: InnoDB 支持外键。</p><p>备份: InnoDB 支持在线热备份。</p><p>崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</p><p>其它特性: MyISAM 支持压缩表和空间数据索引。</p><h2 id="4-MySQL-的事务隔离级别。"><a href="#4-MySQL-的事务隔离级别。" class="headerlink" title="4.MySQL 的事务隔离级别。"></a>4.MySQL 的事务隔离级别。</h2><p><strong>未提交读(READ UNCOMMITTED)</strong></p><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><p><strong>提交读(READ COMMITTED)</strong></p><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><p><strong>可重复读(REPEATABLE READ)</strong></p><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p><p><strong>可串行化(SERIALIZABLE)</strong></p><p>强制事务串行执行。</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻影读</th></tr></thead><tbody><tr><td align="center">未提交读</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">提交读</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">可重复读</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">可串行化</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h2 id="5-MySQL-为什么加索引后查询速度会快很多？"><a href="#5-MySQL-为什么加索引后查询速度会快很多？" class="headerlink" title="5.MySQL 为什么加索引后查询速度会快很多？"></a>5.MySQL 为什么加索引后查询速度会快很多？</h2><ol><li><p>减少磁盘IO操作：当我们使用MySQL查询大量数据时，查询语句需要在磁盘上扫描表来找到符合条件的数据。如果没有索引，每行数据都需要读取一次，增加了磁盘IO操作。而有了索引，MySQL只需要扫描索引，然后再去读取符合条件的行，减少了磁盘IO操作。</p></li><li><p>加快查找速度：索引建立在一列或多列上，这将大大加快MySQL的查询速度。就像字典的目录一样，索引将数据按顺序排列，这样可以快速查找特定的数据，而不需要遍历整个表。</p></li><li><p>提高排序性能：如果我们需要对查询结果进行排序，有索引的情况下MySQL可以快速地读取数据并进行排序。这将加快MySQL的性能，因为没有索引将会麻烦地进行排序。</p></li></ol><h2 id="6-二级索引检索方式是什么样的？"><a href="#6-二级索引检索方式是什么样的？" class="headerlink" title="6.二级索引检索方式是什么样的？"></a>6.二级索引检索方式是什么样的？</h2><p><strong>回表查询</strong></p><p>当使用二级索引进行查询时，MySQL首先会根据二级索引找到符合条件的记录所在的位置，然后再通过主键值去访问数据表中的对应记录，这个过程称为回表查询（或者称为二次查询）。回表查询的优点是可以减少二级索引的存储空间和减少索引更新的成本，但是会增加查询的开销和IO操作。</p><h2 id="7-Autowired-和-Resource-注解有什么区别？"><a href="#7-Autowired-和-Resource-注解有什么区别？" class="headerlink" title="7.@Autowired 和 @Resource 注解有什么区别？"></a>7.@Autowired 和 @Resource 注解有什么区别？</h2><h3 id="注解的作用域"><a href="#注解的作用域" class="headerlink" title="注解的作用域"></a>注解的作用域</h3><p>@Resource和@Autowired注解的作用域不同，@Resource注解默认按照名称进行注入，而@Autowired注解默认按照类型进行注入。</p><p>@Resource注解可以在字段、方法、构造函数上使用，而@Autowired注解可以在字段、方法、构造函数、以及参数上使用。</p><h3 id="注解的来源"><a href="#注解的来源" class="headerlink" title="注解的来源"></a>注解的来源</h3><p>@Resource和@Autowired注解来自于不同的包，@Resource注解来自于<code>javax.annotation.Resource</code>包，而@Autowired注解来自于<code>org.springframework.beans.factory.annotation.Autowired</code>包。</p><h3 id="属性名称"><a href="#属性名称" class="headerlink" title="属性名称"></a>属性名称</h3><p>@Resource注解中的name属性指定了注入对象的名称，而@Autowired注解中的name属性指定了注入对象的bean名称。当一个bean有多个实例时，可以使用name属性指定注入哪个bean实例。</p><h3 id="类型匹配"><a href="#类型匹配" class="headerlink" title="类型匹配"></a>类型匹配</h3><p>@Autowired注解在类型匹配上更加灵活，它可以匹配同类型的bean，也可以匹配子类型的bean，而@Resource注解只能匹配同类型的bean。</p><h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>@Resource注解有一个可选的属性，即mappedName属性，用于指定JNDI名称，而@Autowired注解没有可选属性。</p><h2 id="8-JWT-好处在哪里？"><a href="#8-JWT-好处在哪里？" class="headerlink" title="8.JWT 好处在哪里？"></a>8.JWT 好处在哪里？</h2><p>JWT（JSON Web Token）是一种标准化的身份验证和授权解决方案，它将用户信息和权限信息封装在一个安全的、可靠的、自包含的JSON对象中，通过数字签名来保证数据的完整性和安全性，并可在多个系统之间共享和传递。</p><p>JWT有以下几个优点和好处：</p><p>1.无状态</p><p>JWT是无状态的，即服务器端不需要保存任何用户信息，所有的信息都包含在JWT中。这样就可以在多个系统之间共享和传递用户信息，方便实现分布式系统和微服务架构。</p><p>2.自包含</p><p>JWT是自包含的，即包含了用户身份信息和权限信息，可以在客户端保存，无需频繁向服务器请求，减少了网络开销和服务器压力。</p><p>3.安全性高</p><p>JWT使用数字签名来保证数据的完整性和安全性，防止数据被篡改和伪造，可以有效防止跨站点脚本（XSS）和跨站点请求伪造（CSRF）等攻击。</p><h2 id="9-HTTP-协议特点有哪些？"><a href="#9-HTTP-协议特点有哪些？" class="headerlink" title="9.HTTP 协议特点有哪些？"></a>9.HTTP 协议特点有哪些？</h2><p>HTTP（Hypertext Transfer Protocol）是一种应用层协议，是Web应用的基础，它主要用于客户端和服务器之间的通信。HTTP协议的特点如下：</p><p>1.简单快速</p><p>HTTP协议采用简单的请求-响应模型，请求报文和响应报文的格式都很简单，可以快速地进行通信和传输。</p><p>2.可扩展性强</p><p>HTTP协议的请求报文和响应报文都是基于文本的，可以通过自定义头部、请求方法、状态码等方式来扩展和定制协议的功能和特性，具有很好的灵活性和可扩展性。</p><p>3.无连接</p><p>HTTP协议是无连接的，即每次请求和响应都是独立的，服务器不会保留与客户端的任何连接信息，这样可以减少服务器的负担和资源消耗，但也会增加网络延迟和连接开销。</p><p>4.无状态</p><p>HTTP协议是无状态的，即服务器不会保存任何客户端的状态信息，每个请求都是相互独立的，这样可以减少服务器的负担和资源消耗，但也会增加客户端的负担和复杂度。</p><h2 id="10-HTTP-1-1-相比-HTTP-1-0-有哪些重要改进？"><a href="#10-HTTP-1-1-相比-HTTP-1-0-有哪些重要改进？" class="headerlink" title="10.HTTP 1.1 相比 HTTP 1.0 有哪些重要改进？"></a>10.HTTP 1.1 相比 HTTP 1.0 有哪些重要改进？</h2><p>HTTP 1.1 相比 HTTP 1.0 有以下几个重要的改进：</p><p>1.持久连接</p><p>HTTP 1.1 引入了持久连接（persistent connection），即客户端和服务器之间的连接可以被重复使用，多个请求可以在同一个连接上进行，避免了每次请求都需要建立和关闭连接的开销，提高了网络性能和效率。</p><p>2.流水线式请求处理</p><p>HTTP 1.1 支持流水线式请求处理（pipelining），即客户端可以在一个连接上同时发送多个请求，服务器可以以任意顺序响应这些请求，避免了请求之间的等待和延迟，提高了网络性能和效率。</p><p>3.分块传输编码</p><p>HTTP 1.1 引入了分块传输编码（chunked transfer encoding），即服务器可以将响应数据分成多个块，每个块都包含大小和数据，可以在传输过程中逐个发送，避免了等待整个响应数据的传输，提高了网络性能和效率。</p><p>4.Host 头部</p><p>HTTP 1.1 引入了 Host 头部，即客户端可以在请求报文中指定请求的主机名和端口号，使得多个域名可以共享同一个IP地址，避免了请求被路由到错误的服务器上。</p><p>5.缓存控制</p><p>HTTP 1.1 引入了更加细粒度的缓存控制机制，包括 Cache-Control 头部、ETag 头部、If-Modified-Since 头部等，可以更好地控制缓存的有效性和命中率，减少了网络传输和资源消耗。</p><h2 id="11-HTTP-1-1-如何每次请求都建立一个连接？"><a href="#11-HTTP-1-1-如何每次请求都建立一个连接？" class="headerlink" title="11.HTTP 1.1 如何每次请求都建立一个连接？"></a>11.HTTP 1.1 如何每次请求都建立一个连接？</h2><p>HTTP 1.1 引入了持久连接（persistent connection）机制，即客户端和服务器之间的连接可以被重复使用，多个请求可以在同一个连接上进行。但是，如果需要每次请求都建立一个新的连接，可以采用以下两种方式：</p><p><strong>强制关闭连接</strong></p><p>客户端可以在请求报文中添加 Connection: close 头部，告知服务器在响应完成后强制关闭连接，这样服务器就会在响应完成后立即关闭连接，下次请求需要重新建立连接。</p><p><strong>使用无缓存的代理服务器</strong></p><p>客户端可以通过使用无缓存的代理服务器来实现每次请求都建立一个新的连接，无缓存的代理服务器不会保存任何客户端和服务器之间的连接信息，每次请求都需要重新建立连接。</p><h2 id="12-Spring-AOP-实现日志记录功能，为什么用-AOP？"><a href="#12-Spring-AOP-实现日志记录功能，为什么用-AOP？" class="headerlink" title="12.Spring AOP 实现日志记录功能，为什么用 AOP？"></a>12.Spring AOP 实现日志记录功能，为什么用 AOP？</h2><ol><li>横切关注点</li></ol><p>日志记录功能通常是一个横切关注点，即在应用程序的多个组件中都可能需要记录日志。使用传统的编程方式，需要在每个组件中都编写相同的日志记录代码，代码冗余，且难以维护。而使用 Spring AOP，可以在一个切面中实现日志记录功能，通过将切面织入到应用程序中，可以自动地将日志记录功能应用到所有需要的组件中，避免了代码冗余和维护困难的问题。</p><ol><li>低耦合性</li></ol><p>使用 Spring AOP 实现日志记录功能，可以将日志记录和业务逻辑分离，实现低耦合性。即业务逻辑代码不需要关心日志记录的细节，将日志记录功能委托给切面处理，业务逻辑代码只关注自己的业务逻辑，可以提高代码的可读性和可维护性。</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面经2023-06-29</title>
    <link href="/2023/06/29/Interview-Exp-2023-06-29/"/>
    <url>/2023/06/29/Interview-Exp-2023-06-29/</url>
    
    <content type="html"><![CDATA[<h1 id="字节-商业技术"><a href="#字节-商业技术" class="headerlink" title="字节-商业技术"></a>字节-商业技术</h1><p>来源：牛客 小小啊啊啊啊</p><p><a href="https://www.nowcoder.com/feed/main/detail/d49c548611cc47e28ed8bd96db906ba3?sourceSSR=users">https://www.nowcoder.com/feed/main/detail/d49c548611cc47e28ed8bd96db906ba3?sourceSSR=users</a></p><h2 id="1-布隆过滤器怎么初始化的"><a href="#1-布隆过滤器怎么初始化的" class="headerlink" title="1.布隆过滤器怎么初始化的"></a>1.布隆过滤器怎么初始化的</h2><ol><li><p>确定预期元素数量：首先需要确定预期元素数量，即布隆过滤器将要处理多少个元素。这个数量将决定布隆过滤器的大小。</p></li><li><p>确定误差率：其次需要确定误差率，即布隆过滤器在判断一个元素是否存在时，可能出现的误判概率。误差率越小，布隆过滤器需要的空间就越大。</p></li><li><p>计算哈希函数个数：根据预期元素数量和误差率，可以计算出需要多少个哈希函数。通常情况下，哈希函数的个数与布隆过滤器的大小成正比。</p></li><li><p>创建位数组：根据布隆过滤器的大小，创建一个位数组。位数组中的每个位都被初始化为0。</p></li><li><p>选择哈希函数：根据计算出的哈希函数个数，选择相应数量的哈希函数。常用的哈希函数有MurmurHash、MD5、SHA等等。</p></li><li><p>将元素插入布隆过滤器：将要处理的元素插入到布隆过滤器中，具体方法是将元素依次经过哈希函数，得到哈希值，并将位数组中对应的位标记为1。</p></li></ol><h2 id="2-模糊检索怎么实现的"><a href="#2-模糊检索怎么实现的" class="headerlink" title="2.模糊检索怎么实现的"></a>2.模糊检索怎么实现的</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;mapper namespace=&quot;com.example.mapper.UserMapper&quot;&gt;<br>    &lt;<span class="hljs-keyword">select</span> id=&quot;searchByName&quot; parameterType=&quot;String&quot; resultType=&quot;User&quot;&gt;<br>        <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-type">name</span> <span class="hljs-keyword">LIKE</span> CONCAT(<span class="hljs-string">&#x27;%&#x27;</span>, #&#123;keyword&#125;, <span class="hljs-string">&#x27;%&#x27;</span>)<br>    &lt;/<span class="hljs-keyword">select</span>&gt;<br>&lt;/mapper&gt;<br></code></pre></td></tr></table></figure><p>接收一个 String 类型的参数，表示需要查询的关键词。在对应的 XML 文件中，使用 SQL 语句来实现模糊查询的逻辑，其中 <code>CONCAT(&#39;%&#39;, #&#123;keyword&#125;, &#39;%&#39;)</code> 表示将 <code>%</code>、关键词和 <code>%</code> 连接起来，用于匹配包含关键词的字符串。</p><h2 id="3-B-树怎么实现的"><a href="#3-B-树怎么实现的" class="headerlink" title="3.B+树怎么实现的"></a>3.B+树怎么实现的</h2><p>首先看BTree</p><p><img src="/../img/Interview-Exp-2023-06-29/BTree.png" alt="BTree"></p><p>再来看B+Tree</p><p><img src="/../img/Interview-Exp-2023-06-29/B+Tree.png" alt="B+Tree"></p><ol><li><p>B+树上除叶子节点其他节点是不存储数据的。B树上每个节点都存储了key和data。而B+树只在叶子节点上存储数据，其他节点只存储key。<br>为什么要进行这样的改变呢？<br>以innoDB存储引擎来说，数据库中页的大小是固定的，每页的默认大小为16K。如果页不存储数据(data)就可以存储更多的key,那么就可以尽可能的减少树的高度。总结来说B+树相对于B树来说又矮又胖。这时候如果查询那么就会降低很多IO操作。<br>假定一个页16K可以存储1000个key。那么3层的B+树就可以存储100010001000&#x3D;10亿条数据。而且根节点是常驻内存的，也就是说查询10亿条数据只需要进行2次IO操作。</p></li><li><p>B+树所有的数据都存储在叶子节点上并且是按照顺序排列的。那么使用B+树完成范围查找，排序查找，分组查找，去重查找就会很简单，效率也比较高。而B树就不可以。因为B树的数据是分散个各个节点上的。</p></li><li><p>B+树上每页之间是一个双向链表进行链接，叶子节点中的数据都是使用单向链表链接的。但是需要记得一点的是B树也可以加链表。<br>PS：InnoDB存储引擎中索引就是这样存储的。InnoDB中的聚集索引就是上面的结构。需要记住一点是MyISAM中依然使用的是B+树，结构是一样的，原理也是一样的，区别在于存储不是数据而是数据的文件地址。</p></li></ol><h2 id="4-全局唯一-ID-怎么实现的"><a href="#4-全局唯一-ID-怎么实现的" class="headerlink" title="4.全局唯一 ID 怎么实现的"></a>4.全局唯一 ID 怎么实现的</h2><ol><li>基于时间戳：使用当前时间戳作为 ID 的一部分，可以保证在同一时刻生成的 ID 是唯一的。比如，可以使用 Unix 时间戳加上一个随机数或者自增序列来生成 ID。</li><li>基于 UUID：UUID（Universally Unique Identifier）是一种由网络软件工程师组织（IETF）定义的标准，它使用伪随机数来保证生成的 ID 是唯一的。常见的 UUID 版本有 1、3、4、5，其中版本 1 和 4 是最常用的。Java 中可以使用 java.util.UUID 类来生成 UUID。</li><li>基于 Snowflake 算法：Snowflake 是 Twitter 开发的一种分布式 ID 生成算法，它可以在分布式系统中生成唯一的、有序的、趋势递增的 ID。Snowflake 算法的核心思想是将一个 64 位的 ID 分成多个部分，其中包括时间戳、数据中心 ID、机器 ID、自增序列等。Java 中可以使用 snowflake-java 库来实现 Snowflake 算法。</li><li>基于数据库自增主键：使用数据库自增主键作为 ID，可以保证在数据库中唯一。不过需要注意的是，使用数据库自增主键可能会对数据库性能造成影响，因为每次插入数据都需要向数据库请求一个新的 ID。</li></ol><h2 id="5-Redis-和-mysql-数据一致性"><a href="#5-Redis-和-mysql-数据一致性" class="headerlink" title="5.Redis 和 mysql 数据一致性"></a>5.Redis 和 mysql 数据一致性</h2><p>redis-数据一致性</p><p><a href="https://bigducksoup.github.io/2023/06/13/redis-cache-coherence/">https://bigducksoup.github.io/2023/06/13/redis-cache-coherence/</a></p><h2 id="6-怎么解决缓存穿透、缓存击穿、缓存雪崩"><a href="#6-怎么解决缓存穿透、缓存击穿、缓存雪崩" class="headerlink" title="6.怎么解决缓存穿透、缓存击穿、缓存雪崩"></a>6.怎么解决缓存穿透、缓存击穿、缓存雪崩</h2><p>redis高可用之缓存穿透</p><p><a href="https://bigducksoup.github.io/2023/05/30/redis-cache-penetration/">https://bigducksoup.github.io/2023/05/30/redis-cache-penetration/</a></p><p>redis高可用之缓存击穿</p><p><a href="https://bigducksoup.github.io/2023/06/08/redis-cache-breakdown/">https://bigducksoup.github.io/2023/06/08/redis-cache-breakdown/</a></p><p>redis高可用之缓存雪崩</p><p><a href="https://bigducksoup.github.io/2023/06/09/redis-cache-avalanche/">https://bigducksoup.github.io/2023/06/09/redis-cache-avalanche/</a></p><h2 id="7-消息推送怎么实现的"><a href="#7-消息推送怎么实现的" class="headerlink" title="7.消息推送怎么实现的"></a>7.消息推送怎么实现的</h2><p>使用websocket</p><h2 id="8-分库分表"><a href="#8-分库分表" class="headerlink" title="8.分库分表"></a>8.分库分表</h2><h4 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h4><p>将原来一个单数据库的压力分担到不同的数据库，可以很好应对高并发场景。数据库垂直拆分后的架构如下：</p><p><img src="/../img/Interview-Exp-2023-06-29/vertical-db-split.png" alt="vertical-db-split"></p><h4 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h4><p>如果一个单表包含了几十列甚至上百列，管理起来很混乱，每次都<code>select *</code>的话，还占用IO资源。这时候，我们可以将一些<strong>不常用的、数据较大或者长度较长的列</strong>拆分到另外一张表。</p><p>比如一张用户表，它包含<code>user_id、user_name、mobile_no、age、email、nickname、address、user_desc</code>，如果<code>email、address、user_desc</code>等字段不常用，我们可以把它拆分到另外一张表，命名为用户详细信息表。这就是垂直分表</p><p><img src="/../img/Interview-Exp-2023-06-29/vertical-table-split.png" alt="vertical-table-split"></p><h4 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a><strong>水平分库</strong></h4><p>水平分库是指，将表的数据量切分到不同的数据库服务器上，每个服务器具有相同的库和表，只是表中的数据集合不一样。它可以有效的缓解单机单库的性能瓶颈和压力。</p><p>用户库的水平拆分架构如下：</p><p><img src="/../img/Interview-Exp-2023-06-29/horizontal-db-split.png" alt="horizontal-db-split"></p><h4 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a><strong>水平分表</strong></h4><p>如果一个表的数据量太大，可以按照某种规则（如<code>hash取模、range</code>），把数据切分到多张表去。</p><p>一张订单表，按<code>时间range</code>拆分如下：</p><p><img src="/../img/Interview-Exp-2023-06-29/horizontal-table-split.png" alt="horizontal-table-split"></p><h4 id="水平分库分表策略"><a href="#水平分库分表策略" class="headerlink" title="水平分库分表策略"></a>水平分库分表策略</h4><p>分库分表策略一般有几种，使用与不同的场景：</p><ul><li>range范围</li><li>hash取模</li><li>range+hash取模混合</li></ul><h5 id="range范围"><a href="#range范围" class="headerlink" title="range范围"></a><strong>range范围</strong></h5><p>range，即范围策略划分表。比如我们可以将表的主键，按照从<code>0~1000万</code>的划分为一个表，<code>1000~2000万</code>划分到另外一个表。如下图：</p><p><img src="/../img/Interview-Exp-2023-06-29/range.jpg" alt="range"></p><p>当然，有时候我们也可以按时间范围来划分，如不同年月的订单放到不同的表，它也是一种range的划分策略。</p><p><strong>这种方案的优点：</strong></p><ul><li>这种方案有利于扩容，不需要数据迁移。假设数据量增加到5千万，我们只需要水平增加一张表就好啦，之前<code>0~4000万</code>的数据，不需要迁移。</li></ul><p><strong>缺点：</strong></p><ul><li>这种方案会有热点问题，因为订单id是一直在增大的，也就是说最近一段时间都是汇聚在一张表里面的。比如最近一个月的订单都在<code>1000万~2000</code>万之间，平时用户一般都查最近一个月的订单比较多，请求都打到<code>order_1</code>表啦，这就导致表的<strong>数据热点</strong>问题。</li></ul><h5 id="hash取模"><a href="#hash取模" class="headerlink" title="hash取模"></a><strong>hash取模</strong></h5><p>hash取模策略：指定的路由key（一般是user_id、订单id作为key）对分表总数进行取模，把数据分散到各个表中。</p><p>比如原始订单表信息，我们把它分成4张分表：</p><p><img src="/../img/Interview-Exp-2023-06-29/hash.jpg" alt="hash"></p><ul><li>比如id&#x3D;1，对4取模，就会得到1，就把它放到第1张表，即<code>t_order_0</code>;</li><li>id&#x3D;3，对4取模，就会得到3，就把它放到第3张表，即<code>t_order_2</code>;</li></ul><p><strong>这种方案的优点：</strong></p><ul><li>hash取模的方式，不会存在明显的热点问题。</li></ul><p><strong>缺点：</strong></p><ul><li>如果一开始按照hash取模分成4个表了，未来某个时候，表数据量又到瓶颈了，需要扩容，这就比较棘手了。比如你从4张表，又扩容成<code>8</code>张表，那之前<code>id=5</code>的数据是在（<code>5%4=1</code>，即第一张表），现在应该放到（<code>5%8=5</code>，即第<code>5</code>张表），也就是说<strong>历史数据要做迁移了</strong>。</li></ul><h5 id="range-hash取模混合"><a href="#range-hash取模混合" class="headerlink" title="range+hash取模混合"></a>range+hash取模混合</h5><p>既然range存在热点数据问题，hash取模扩容迁移数据比较困难，我们可以综合两种方案一起嘛，取之之长，弃之之短。</p><p>比较简单的做法就是，在拆分库的时候，我们可以先用<strong>range范围</strong>方案，比如订单id在04000万的区间，划分为订单库1，id在4000万8000万的数据，划分到订单库2,将来要扩容时，id在8000万~1.2亿的数据，划分到订单库3。然后订单库内，再用<strong>hash取模</strong>的策略，把不同订单划分到不同的表。</p><p><img src="/../img/Interview-Exp-2023-06-29/hash-range.jpg" alt="hash-range"></p><h4 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h4><ul><li>事务问题</li></ul><p>分库分表后，假设两个表在不同的数据库，那么本地事务已经无效啦，需要使用分布式事务了。</p><ul><li>跨库关联</li></ul><p>跨节点Join的问题：解决这一问题可以分两次查询实现</p><ul><li>排序问题</li></ul><p>跨节点的count,order by,group by以及聚合函数等问题：可以分别在各个节点上得到结果后在应用程序端进行合并。</p><ul><li><p>分页问题</p></li><li><p>方案1：在个节点查到对应结果后，在代码端汇聚再分页。</p></li><li><p>方案2：把分页交给前端，前端传来pageSize和pageNo，在各个数据库节点都执行分页，然后汇聚总数量前端。这样缺点就是会造成空查，如果分页需要排序，也不好搞。</p></li><li><p>分布式ID</p></li></ul><p>据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑UUID，或者使用雪花算法生成分布式ID。</p><h4 id="目前流行的分库分表中间件"><a href="#目前流行的分库分表中间件" class="headerlink" title="目前流行的分库分表中间件"></a><strong>目前流行的分库分表中间件</strong></h4><ul><li>cobar</li><li>Mycat</li><li>Sharding-JDBC</li><li>Atlas</li><li>TDDL（淘宝）</li><li>vitess</li></ul><h2 id="9-transactional原理"><a href="#9-transactional原理" class="headerlink" title="9.@transactional原理"></a>9.@transactional原理</h2><p>@Transactional的原理如下：</p><ol><li>@Transactional注解会被 Spring AOP 拦截器拦截，并在方法执行前后开启和提交事务。</li><li>Spring AOP 使用动态代理技术生成一个代理对象，该代理对象包装了被 <code>@Transactional</code> 注解修饰的目标对象。</li><li>当调用代理对象的方法时，Spring AOP 会在方法执行前先判断当前线程是否已经存在一个事务。如果存在，则使用该事务；如果不存在，则创建一个新事务。</li><li>当方法执行完成后，Spring AOP 会根据方法执行结果决定是提交事务还是回滚事务。如果方法执行过程中抛出了异常，则回滚事务；否则，提交事务。</li><li>在事务管理过程中，Spring 会使用事务管理器（如 DataSourceTransactionManager）来管理事务。当事务提交或回滚时，事务管理器会负责将事务的状态改变，并将事务提交或回滚到底层数据库中去。</li></ol><h2 id="10-联合索引-where-a-x3D-xxx-and-b-gt-xxx-and-c-x3D-xxx-能用索引吗"><a href="#10-联合索引-where-a-x3D-xxx-and-b-gt-xxx-and-c-x3D-xxx-能用索引吗" class="headerlink" title="10.联合索引 where a &#x3D; xxx and b &gt; xxx and c &#x3D; xxx 能用索引吗"></a>10.联合索引 where a &#x3D; xxx and b &gt; xxx and c &#x3D; xxx 能用索引吗</h2><p>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段后面的字段无法用到联合索引。但是，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配这四种范围查询，并不会停止匹配。</p><h2 id="11-为什么遇到范围查询就会停止查询，你知道原理吗"><a href="#11-为什么遇到范围查询就会停止查询，你知道原理吗" class="headerlink" title="11.为什么遇到范围查询就会停止查询，你知道原理吗"></a>11.为什么遇到范围查询就会停止查询，你知道原理吗</h2><p>因为<strong>前一个条件</strong>相同的情况下 <strong>当前条件</strong>才会是<strong>有序的</strong>。<br>当<strong>前一个条件</strong>不同 那么无法保证<strong>当前条件</strong>为有序的 所以索引失效</p><p><a href="https://blog.csdn.net/weixin_52534279/article/details/119308663">https://blog.csdn.net/weixin_52534279/article/details/119308663</a></p><h2 id="12-从输入URL-到页面展示的过程"><a href="#12-从输入URL-到页面展示的过程" class="headerlink" title="12.从输入URL 到页面展示的过程"></a>12.从输入URL 到页面展示的过程</h2><p>小林coding有讲到</p><p><a href="https://xiaolincoding.com/network/1_base/what_happen_url.html">https://xiaolincoding.com/network/1_base/what_happen_url.html</a></p><h2 id="13-简述-HTTPS-的加密与认证过程"><a href="#13-简述-HTTPS-的加密与认证过程" class="headerlink" title="13.简述 HTTPS 的加密与认证过程"></a>13.简述 HTTPS 的加密与认证过程</h2><p><a href="https://xiaolincoding.com/network/2_http/http_interview.html#http-%E4%B8%8E-https">https://xiaolincoding.com/network/2_http/http_interview.html#http-%E4%B8%8E-https</a></p><ul><li><strong>混合加密</strong>的方式实现信息的<strong>机密性</strong>，解决了窃听的风险。</li><li><strong>摘要算法</strong>的方式来实现<strong>完整性</strong>，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li>将服务器公钥放入到<strong>数字证书</strong>中，解决了冒充的风险。</li></ul><h2 id="14-SSL-运行在那一层"><a href="#14-SSL-运行在那一层" class="headerlink" title="14.SSL 运行在那一层"></a>14.SSL 运行在那一层</h2><p>在弄清SSL协议在网络协议的哪一层之前，我们先要知道SSL协议是有记录协议和握手协议之分：</p><p><strong>（1）记录协议。</strong>它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。</p><p><strong>（2）握手协议。</strong>它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p><p>实际上SSL协议是位于应用层和传输层之间，可以为任何基于TCP等可靠连接的应用层协议提供安全性保证，为数据通讯提供安全支持。</p><h2 id="15-启动一个程序是进程还是线程"><a href="#15-启动一个程序是进程还是线程" class="headerlink" title="15.启动一个程序是进程还是线程"></a>15.启动一个程序是进程还是线程</h2><p>启动一个程序会创建一个进程，而不是线程。进程是操作系统分配资源的基本单位，包括代码、数据和系统资源等，每个进程都有独立的地址空间和系统资源，可以并发地执行多个任务。</p><h2 id="16-进程是怎么调度的"><a href="#16-进程是怎么调度的" class="headerlink" title="16.进程是怎么调度的"></a>16.进程是怎么调度的</h2><p>发生进程切换时，本质是CPU资源占用者间的切换。此时需要保存当前进程在PCB中的执行上下文(CPU状态)，然后恢复下一个进程的执行上下文。</p><p>处理机调度涉及两个方面，一是选择进程：从就绪队列中挑选下一个占用CPU运行的进程。二是选择CPU资源：从多个可用CPU中挑选就绪进程可使用的CPU资源。</p><p>调度策略是指确定如何从就绪队列中选择下一个执行进程，可以理解为调度算法。评价算法的基准有以下几个：</p><ol><li>CPU使用率：CPU处于忙状态的时间百分比</li><li>吞吐量：单位时间内完成的进程数量</li><li>周转时间：进程从初始化到结束(包括等待)的总时间</li><li>就绪等待时间：进程在就绪队列中的总时间</li><li>响应时间：从提交请求到产生响应所花费的总时间</li></ol><p>另外，处理机调度需要保证公平：</p><ol><li>保证每个进程占用相同的CPU时间</li><li>保证每个进程的等待时间相同</li></ol><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="先来先服务算法-FCFS-First-Come-First-Served"><a href="#先来先服务算法-FCFS-First-Come-First-Served" class="headerlink" title="先来先服务算法(FCFS: First Come, First Served)"></a>先来先服务算法(FCFS: First Come, First Served)</h4><p>FCFS依据进程进入就绪状态的先后顺序排列，它简单、易于实现。</p><h4 id="短进程优先算法-SPN"><a href="#短进程优先算法-SPN" class="headerlink" title="短进程优先算法(SPN)"></a>短进程优先算法(SPN)</h4><p>SPN是FCFS算法的改进，它选择预期执行时间最短进程占用CPU进入运行状态。SPN算法的优点是具有最优平均周转时间。</p><h4 id="最高响应比优先算法-HRRN-Highest-Response-Ratio-Next"><a href="#最高响应比优先算法-HRRN-Highest-Response-Ratio-Next" class="headerlink" title="最高响应比优先算法(HRRN: Highest Response Ratio Next)"></a>最高响应比优先算法(HRRN: Highest Response Ratio Next)</h4><p>选择就绪队列中响应比R值最高的进程，R计算方法如下：<br> Ｒ＝（ｗ+s)&#x2F;s<br> w: 等待时间(waiting time)<br> s: 执行时间(service time)</p><h4 id="时间片轮转算法-RR-Round-Robin"><a href="#时间片轮转算法-RR-Round-Robin" class="headerlink" title="时间片轮转算法(RR: Round Robin)"></a>时间片轮转算法(RR: Round Robin)</h4><p>RR算法是对FCFS的改进，在FCFS的基础上加入对进程执行时间(CPU时间片)的限制。当进程的时间片用完后，按照FCFS的规则选择下一个进程。</p><h2 id="17-java中-sleep-和-wait-的区别"><a href="#17-java中-sleep-和-wait-的区别" class="headerlink" title="17.java中 sleep() 和 wait() 的区别"></a>17.java中 sleep() 和 wait() 的区别</h2><p>在 Java 中，sleep() 和 wait() 都可以用来控制线程的执行。它们的主要区别如下：</p><ol><li>sleep() 属于 Thread 类中的静态方法，它可以让当前线程暂停执行一段时间，但不会释放锁。wait() 则是 Object 类中的实例方法，它可以让当前线程暂停执行，并释放锁，等待被唤醒。</li><li>sleep() 方法的参数是一个时间段，单位是毫秒，表示当前线程暂停执行的时间长度。wait() 方法则没有参数，它一直等待直到被其他线程调用 notify() 或 notifyAll() 方法唤醒。</li><li>sleep() 方法可以在任何地方调用，而 wait() 方法只能在同步块或同步方法中调用。</li><li>sleep() 方法不依赖于锁，因此可以在没有同步块的情况下使用。wait() 方法需要在同步块或同步方法中使用，并且会释放锁，以便其他线程可以访问共享资源。</li></ol><p>综上所述，sleep() 和 wait() 的主要区别在于它们的用途和使用方式不同。sleep() 用于暂停当前线程，wait() 用于等待其他线程的唤醒。sleep() 不释放锁，wait() 释放锁。因此，在使用时需要根据实际情况进行选择。</p><h2 id="18-线程池构造函数参数有哪些，详细解释下"><a href="#18-线程池构造函数参数有哪些，详细解释下" class="headerlink" title="18.线程池构造函数参数有哪些，详细解释下"></a>18.线程池构造函数参数有哪些，详细解释下</h2><p>在 Java 中，线程池是一种常见的多线程编程方式，可以有效地管理和复用线程，提高程序的性能和响应性。Java 中的线程池是通过 ThreadPoolExecutor 类来实现的，该类的构造函数参数包括以下几个：</p><ol><li>corePoolSize：线程池的核心线程数，即线程池中保留的最小线程数。当提交的任务数超过核心线程数时，线程池会自动创建新的线程来处理任务。</li><li>maximumPoolSize：线程池的最大线程数，即线程池中允许的最大线程数。当提交的任务数超过最大线程数时，线程池会根据拒绝策略来处理任务。</li><li>keepAliveTime：线程空闲的存活时间，即当线程池中的线程数大于核心线程数时，多余的空闲线程在等待新任务到来的过程中，能够保持存活的时间。单位为时间单位。</li><li>unit：keepAliveTime 的时间单位，可以是 TimeUnit 中的常量，例如 TimeUnit.SECONDS。</li><li>workQueue：用于存放等待执行的任务的阻塞队列，可以选择不同的队列实现，例如 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue 等。</li><li>threadFactory：用于创建新线程的工厂类，可以自定义线程的名称、优先级、是否为守护线程等属性。</li><li>handler：用于处理任务拒绝策略的处理器，可以选择不同的拒绝策略，例如 AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy 等。</li></ol><p>总之，线程池构造函数参数包括核心线程数、最大线程数、线程空闲存活时间、等待执行的任务队列、新线程的创建工厂、任务拒绝策略处理器等。根据不同的需求和条件，可以选择不同的参数来创建合适的线程池。</p>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis-数据一致性</title>
    <link href="/2023/06/13/redis-cache-coherence/"/>
    <url>/2023/06/13/redis-cache-coherence/</url>
    
    <content type="html"><![CDATA[<h1 id="redis与数据库的数据一致性解决方案"><a href="#redis与数据库的数据一致性解决方案" class="headerlink" title="redis与数据库的数据一致性解决方案"></a>redis与数据库的数据一致性解决方案</h1><h2 id="1-一致性"><a href="#1-一致性" class="headerlink" title="1.一致性"></a>1.一致性</h2><p>一致性是指系统中各节点数据保持一致。分布式系统中，可以理解为多个节点中的数据是一致的。</p><p>一致性根据严苛程度分类：</p><p>强一致性：写进去的数据是什么，读出来的数据就是什么，对性能影响最大；</p><p>弱一致性：数据写入成功后，系统不保证能立刻读出最新的数据，也不承诺多久之后数据可以达到一致，但保证到某个时间级别后，数据能达到一致；</p><p>最终一致性：最终一致性是弱一致性的一个特例，最终一致性同样只保证数据写入成功后，在某个时间点后数据会达到一致。这个系统无法保证强一致性的时间片段被称为不一致窗口。不一致时间窗口的时间长短取决于很多因素，比如副本个数、网络延迟、系统负载等。</p><p>最终一致性是弱一致性中非常受大众推崇的一种一致性模型，也是目前业界在大型分布式系统的数据一致性上比较推崇的模型。</p><h2 id="2-数据同步策略"><a href="#2-数据同步策略" class="headerlink" title="2.数据同步策略"></a>2.数据同步策略</h2><p>为保证缓存数据与数据库数据一致，主要考虑如下两种策略实现：</p><p>1.先删除缓存，再更新数据库；</p><p>2.先更新数据库，再删除缓存；</p><p>3.延时双删</p><p>4.使用消息队列</p><p>5.使用canal</p><h3 id="1-先删除缓存，再更新数据库"><a href="#1-先删除缓存，再更新数据库" class="headerlink" title="1.先删除缓存，再更新数据库"></a>1.先删除缓存，再更新数据库</h3><p><img src="/../img/redis-cache-coherence/rm-cache-first-success.png" alt="先删除缓存"></p><p>但是实际的环境中无法严格确定线程的执行情况，可能会遇到如下情况导致缓存更新脏数据</p><p><img src="/../img/redis-cache-coherence/rm-cache-first-fail.png" alt="更新脏数据"></p><h3 id="2-先更新数据库，再删除缓存"><a href="#2-先更新数据库，再删除缓存" class="headerlink" title="2.先更新数据库，再删除缓存"></a>2.先更新数据库，再删除缓存</h3><p><img src="/../img/redis-cache-coherence/update-db-first-success.png" alt="先更新数据库"></p><p>但是这种方法也会出现问题</p><p><img src="/../img/redis-cache-coherence/update-db-first-fail.png" alt="先更新数据库-失败"></p><h3 id="3-延时双删"><a href="#3-延时双删" class="headerlink" title="3.延时双删"></a>3.延时双删</h3><p><img src="/../img/redis-cache-coherence/delay-delete.png" alt="延时双删"></p><p>延时双删可以解决以上两种同步策略更新脏数据的问题</p><h3 id="4-使用消息队列"><a href="#4-使用消息队列" class="headerlink" title="4.使用消息队列"></a>4.使用消息队列</h3><p><img src="/../img/redis-cache-coherence/MQ.png" alt="MQ"></p><h3 id="5-canal"><a href="#5-canal" class="headerlink" title="5.canal"></a>5.canal</h3><p><img src="/../img/redis-cache-coherence/canal.png" alt="canal"></p><h3 id="6-分布式锁"><a href="#6-分布式锁" class="headerlink" title="6.分布式锁"></a>6.分布式锁</h3><p>加锁可以保证强一致性，但是效率较低</p><p><img src="/../img/redis-cache-coherence/lock.png" alt="lock"></p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis高可用之缓存雪崩</title>
    <link href="/2023/06/09/redis-cache-avalanche/"/>
    <url>/2023/06/09/redis-cache-avalanche/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>大量缓存数据在同一时间过期（失效）时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是<strong>缓存雪崩</strong></p><p><img src="/../img/redis-cache-avalanche/redis-cache-avalanche.png" alt="缓存雪崩"></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p> 1.给不同的Key的TTL添加随机值</p><p> 2.利用Redis集群提高服务的可用性</p><p> 3.给缓存业务添加降级限流策略</p><p> 4.给业务添加多级缓存</p><p>5.设置缓存不过期</p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis高可用之缓存击穿</title>
    <link href="/2023/06/08/redis-cache-breakdown/"/>
    <url>/2023/06/08/redis-cache-breakdown/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>缓存雪崩是指只大量热点key同时失效的情况，如果是单个热点key，在不停的扛着大并发，在这个key失效的瞬间，持续的大并发请求就会击破缓存，直接请求到数据库，好像蛮力击穿一样。这种情况就是<strong>缓存击穿</strong>（Cache Breakdown）。</p><p><img src="/../img/redis-cache-breakdown/redis-cache-breakdown.png" alt="缓存击穿"></p><p>从定义上可以看出，缓存击穿和缓存雪崩很类似，只不过是缓存击穿是一个热点key失效，而缓存雪崩是大量热点key失效。因此，可以将缓存击穿看作是缓存雪崩的一个子集。</p><h1 id="发生原因"><a href="#发生原因" class="headerlink" title="发生原因"></a>发生原因</h1><p>缓存中不存在所需的热点数据：当系统中某个热点数据需要被频繁访问时，如果这个热点数据最开始没有被缓存，那么就会导致系统每次请求都需要直接查询数据库，造成数据库负担。</p><p>缓存的热点数据过期：当一个热点数据过期并需要重新缓存时，如果此时有大量请求，那么就会导致所有请求都要直接查询数据库。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol><li>使用互斥锁（Mutex Key），只让一个线程构建缓存，其他线程等待构建缓存执行完毕，重新从缓存中获取数据。单机通过synchronized或lock来处理，分布式环境采用分布式锁。</li></ol><p><img src="/../img/redis-cache-breakdown/lock.png" alt="互斥锁解决缓存击穿"></p><ol start="2"><li>逻辑过期</li></ol><p><img src="/../img/redis-cache-breakdown/logicExpire.png" alt="逻辑过期"></p><ol start="3"><li><p>给hot key设置合适的过期时间</p><p>在对缓存一致性要求不高时，不给热点key设置过期时间，或设置合适的过期时间，同时启动一个定时任务去更新此key。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis高可用之缓存穿透</title>
    <link href="/2023/05/30/redis-cache-penetration/"/>
    <url>/2023/05/30/redis-cache-penetration/</url>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>缓存穿透（cache penetration）是用户访问的数据既不在缓存当中，也不在数据库中。出于容错的考虑，如果从底层数据库查询不到数据，则不写入缓存。这就导致每次请求都会到底层数据库进行查询，缓存也失去了意义。当高并发或有人利用不存在的Key频繁攻击时，数据库的压力骤增，甚至崩溃，这就是缓存穿透问题。</p><p><img src="/../img/redis-cache-penetration/redis-cache-penetration.png" alt="redis-cache-penetration"></p><h1 id="发生场景"><a href="#发生场景" class="headerlink" title="发生场景"></a>发生场景</h1><p><strong>缓存穿透</strong>发生的场景一般有两类：</p><ul><li>原来数据是存在的，但由于某些原因（误删除、主动清理等）在缓存和数据库层面被删除了，但前端或前置的应用程序依旧保有这些数据；</li><li>恶意攻击行为，利用不存在的Key或者恶意尝试导致产生大量不存在的业务数据请求。</li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h3 id="方案一：缓存空值（null）或默认值"><a href="#方案一：缓存空值（null）或默认值" class="headerlink" title="方案一：缓存空值（null）或默认值"></a><strong>方案一：缓存空值（null）或默认值</strong></h3><p>分析业务请求，如果是正常业务请求时发生缓存穿透现象，可针对相应的业务数据，在数据库查询不存在时，将其缓存为空值（null）或默认值。需要注意的是，针对空值的缓存失效时间不宜过长，一般设置为5分钟之内。当数据库被写入或更新该key的新数据时，缓存必须同时被刷新，避免数据不一致。</p><h3 id="方案二：业务逻辑前置校验"><a href="#方案二：业务逻辑前置校验" class="headerlink" title="方案二：业务逻辑前置校验"></a><strong>方案二：业务逻辑前置校验</strong></h3><p>在业务请求的入口处进行数据合法性校验，检查请求参数是否合理、是否包含非法值、是否恶意请求等，提前有效阻断非法请求。比如，根据年龄查询时，请求的年龄为-10岁，这显然是不合法的请求参数，直接在参数校验时进行判断返回。</p><h3 id="方案三：使用布隆过滤器请求白名单"><a href="#方案三：使用布隆过滤器请求白名单" class="headerlink" title="方案三：使用布隆过滤器请求白名单"></a><strong>方案三：使用布隆过滤器请求白名单</strong></h3><p>在写入数据时，使用布隆过滤器进行标记（相当于设置白名单），业务请求发现缓存中无对应数据时，可先通过查询布隆过滤器判断数据是否在白名单内，如果不在白名单内，则直接返回空或失败。</p><h4 id="布隆过滤器（BloomFilter）"><a href="#布隆过滤器（BloomFilter）" class="headerlink" title="布隆过滤器（BloomFilter）"></a>布隆过滤器（BloomFilter）</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>布隆过滤器是一种概率型数据结构，它的特点是高效的插入和查询，能确定某个字符串一定存在或者可能存在。</p><p><strong>布隆过滤器不存储具体数据，所以占用空间小，查询结果存在误差，但误差可控，同时不支持删除操作。</strong></p><h5 id="构成："><a href="#构成：" class="headerlink" title="构成："></a>构成：</h5><p>布隆过滤器的原理本质上和散列表是一样的。但布隆过滤器为了节约内存，不是使用的数组，而是使用的位图。</p><p>它包括<strong>一个位图</strong> 和 <strong>n个hash函数</strong></p><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>当一个元素加入位图时，通过k个hash函数将元素映射到位图的k个点，并把它们置1；当检索时，再通过k个hash函数运算检查位图的k个点是否都为1；如果有不为1的点，那么认为该key不存在；如果全部为1，则可能存在。</p><p>布隆过滤器是不支持删除操作的，原因在于：在位图中每个槽位只有两种状态（0或者1），一个槽位被置为1，但不确定它被设置了多少次；也不知道被多少个key hash映射而来；以及具体被哪个hash函数映射而来。</p><p>值得注意的是，只要有一个槽位为0，则key一定不存在；如果key映射的所有槽位都为1，不能说明一定存在，只能说明可能存在（假阳率）。</p><p><img src="/../img/redis-cache-penetration/bloomfilter.png" alt="bloomfilter"></p><h3 id="方案四：用户黑名单限制"><a href="#方案四：用户黑名单限制" class="headerlink" title="方案四：用户黑名单限制"></a><strong>方案四：用户黑名单限制</strong></h3><p>当发生异常情况时，实时监控访问的对象和数据，分析用户行为，针对故意请求、爬虫或攻击者，进行特定用户的限制；</p><p>当然，可能针对缓存穿透的情况，也有可能是其他的原因引起，可以针对具体情况，采用对应的措施。</p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis持久化之AOF</title>
    <link href="/2023/05/13/redis-aof/"/>
    <url>/2023/05/13/redis-aof/</url>
    
    <content type="html"><![CDATA[<h1 id="redis持久化AOF"><a href="#redis持久化AOF" class="headerlink" title="redis持久化AOF"></a>redis持久化AOF</h1><p> AOF (Append Only File)  持久化默认是关闭的，通过将 redis.conf 中将 appendonly no，修改为 appendonly yes 来开启AOF 持久化功能，如果服务器开始了 AOF 持久化功能，服务器会优先使用 AOF 文件来还原数据库状态。只有在 AOF 持久化功能处于关闭状态时，服务器才会使用 RDB 文件来还原数据库状态。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>每当 Redis 接受到会修改数据集的命令时，就会把<strong>命令</strong>追加到 AOF 文件里，当你重启 Redis 时，AOF 文件里的命令会被重新执行一次，重建数据。</p><p>被写入 AOF 文件中的所有命令都是以 Redis 的命令请求协议格式保存的，因为 Redis 的命令请求协议是纯文本格式，所以我们可以直接打开一个 AOF 文件，观察里面的内容。</p><p>因为AOF文件里面包含了重建数据库状态所需的所有写命令，所以 服务器只要读入并重新执行一遍AOF文件里面保存的写命令，就可以还 原服务器关闭之前的数据库状态。</p><p><strong>步骤如下：</strong></p><ol><li><p>创建一个不带网络连接的伪客户端（fake client）：因为Redis的 命令只能在客户端上下文中执行，而载入AOF文件时所使用的命令直接 来源于AOF文件而不是网络连接，所以服务器使用了一个没有网络连接 的伪客户端来执行AOF文件保存的写命令，伪客户端执行命令的效果和 带网络连接的客户端执行命令的效果完全一样。</p></li><li><p>从AOF文件中分析并读取出一条写命令。</p></li><li><p>使用伪客户端执行被读出的写命令。</p></li><li><p>一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处 理完毕为止。</p></li></ol><p>执行完成后，数据库的状态就会被还原。</p><h2 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h2><p>AOF 持久化功能的实现可以分为<strong>命令追加（append）、文件写入、文件同步（sync）</strong>三个步骤。</p><h3 id="1-命令追加"><a href="#1-命令追加" class="headerlink" title="1.命令追加"></a>1.命令追加</h3><p>当 AOF 持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾。</p><p>举例：如果客户端向服务器发送以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis&gt; SET KEY VALUE<br>OK<br></code></pre></td></tr></table></figure><p>那么服务器在执行这个命令之后，会将以下协议内容追加到 aof_buf 缓冲区的末尾：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis&gt; SET KEY VALUE<br></code></pre></td></tr></table></figure><p>又例如，如果客户端向服务器发送以下命令：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis&gt; RPUSH NUMBERS ONE TWO THREE<br>(<span class="hljs-built_in">integer</span>) 3<br></code></pre></td></tr></table></figure><p>那么服务器在执行这个RPUSH命令之后，会将以下协议内容追加到aof_buf缓冲区的末尾：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis&gt; RPUSH NUMBERS ONE TWO THREE<br></code></pre></td></tr></table></figure><h3 id="2-AOF-文件的写入与同步"><a href="#2-AOF-文件的写入与同步" class="headerlink" title="2.AOF 文件的写入与同步"></a>2.AOF 文件的写入与同步</h3><p>Redis 的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责接受客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像 serverCron 函数这样需要定时运行的函数。</p><p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到 aof_buf 缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用 flushAppendOnlyFile 函数，考虑是否需要将 aof_buf 缓冲区的内容写入和同步到 AOF 文件里，这个过程可以用伪代码表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">evenLoop</span> () :<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span> :<br>        <span class="hljs-comment"># 处理文件事件，接受命令请求以及发送命令回复</span><br>        <span class="hljs-comment"># 处理请求时可能会有新内容被追加到 aof_buf 缓冲区</span><br>        processFileEvents ()<br>        <span class="hljs-comment"># 处理时间事件</span><br>        processTimeEvents ()<br>        <span class="hljs-comment"># 考虑是否要将 aof_buf 中的内容写入和保存到 AOF 文件里</span><br>        flushAppendOnlyFile ()<br></code></pre></td></tr></table></figure><p><strong>flushAppendOnlyFile 函数的行为由服务器配置的 appendfsync 选项的值来决定</strong>，各个不同值产生的行为如下表：</p><table><thead><tr><th><strong>appendfsync 选项值</strong></th><th><strong>flushAppendOnlyFile 函数行为</strong></th></tr></thead><tbody><tr><td>always</td><td>将 aof_buf 缓冲区中的所有内容写入并同步到 AOF 文件</td></tr><tr><td>everysec(默认)</td><td>将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，如果上次同步 AOF 文件的时间距离现在超过一秒钟，那么再次对 AOF 文件进行同步，并且这个操作是由一个线程专门负责执行的</td></tr><tr><td>no</td><td>将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，但并不对 AOF 文件进行同步，何时同步由操作系统来决定</td></tr></tbody></table><p><strong>服务器配置 appendfsync 选项的值直接决定 AOF 持久化功能的效率和安全性。</strong></p><p>当 appendfsync 的值为 always 时，服务器在每个事件循环都要将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，并且同步 AOF 文件，所以 always 的效率是 appendfsync 选项三个值当中最慢的一个，但从安全性来说，always 也是最安全的，因为即使出现故障停机，AOF 持久化也只会丢失一个事件循环中所产生的命令数据。</p><p>当 appendfsync 的值为 everysec 时，服务器在每个事件循环都要将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，并且每隔一秒就要在子线程中对 AOF 文件进行一次同步。从效率上来讲，everysec 模式足够快，并且就算出现故障停机，数据库也只丢失一秒钟的命令数据。</p><p>当 appendfsync 的值为 no 时，服务器在每个事件循环都要将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，至于何时对 AOF 文件进行同步，则由操作系统控制。因为处于 no 模式下的 flushAppendOnlyFile 调用无须执行同步操作，所以该模式下的 AOF 文件写入速度总是最快的，不过因为这种模式会在系统缓存中积累一段时间的写入数据，所以该模式的单次同步时长通常是三种模式中时间最长的。从平摊操作的角度来看，no 模式和 everysec 模式的效率类似，当出现故障停机时，使用 no 模式的服务器将丢失上次同步 AOF 文件之后的所有写命令数据。</p><h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a><strong>文件写入</strong></h4><p>（1）通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；</p><p>（2）具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。</p><blockquote><p>为了提高文件的写入效率，在现代的操作系统中，当用户调用 write 函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正的将缓冲区中的数据写入到磁盘里。</p><p>这种做法虽然提高了效率，但是也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里的写入数据将会丢失。</p><p>为此，系统提供了 fsync 和 fdatafync 两个同步函数，它们可以强制让操作系统立即将缓冲区的数据写入到磁盘里面，从而确保写入数据的安全性。</p><p>AOF 文件的写入与同步，就好比你在 window 系统打开一个 word 文档，当你写一些内容时就相当于写入，但是你写的内容并没有真正的保存，而是放在一个缓冲区，如果这时关闭的话内容就会丢失。只有当你点击保存时内容才真正的保存（同步）到磁盘，点击保存就好比调用同步函数 fsync 和 fdatafync。</p></blockquote><h4 id="文件同步"><a href="#文件同步" class="headerlink" title="文件同步"></a><strong>文件同步</strong></h4><p>如果由内核决定将数据写入硬盘的话，如果服务器宕机，那么就会有数据丢失的风险。为了解决这个问题，系统提供了<strong>fsync和fdatasync两个同步函数</strong>和<strong>三种写回策略</strong>，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p><p>always：服务器在每次写操作后都将 aof_buf缓冲区中的所有内容写入到AOF文件，然后立即执行fsync()函数同步AOF文件到磁盘，所以always的效率是最慢的，但也是最安全的。可靠性高，性能低。</p><p>everysec：服务器在每次写操作后都要 将aof_buf缓冲区中的所有内容写入到AOF文件，并且每隔一秒就要在子线程中对AOF文件进行一次同步，创建一个异步任务执行fsync()函数。可靠性和性能都适中。</p><p>no：将缓冲区的内容写入AOF文件后，何时进行同步由操作系统控制，不执行fsync()函数。性能好，可靠性低，宕机可能会丢失较多数据。</p><p><img src="/../img/redis-aof/aof.png"></p><h3 id="3-AOF文件的载入与数据还原"><a href="#3-AOF文件的载入与数据还原" class="headerlink" title="3.AOF文件的载入与数据还原"></a>3.AOF文件的载入与数据还原</h3><p>因为 AOF 文件里面包含了重建数据库状态所需的所有写命令，所以服务器只要读入并重新执行一遍 AOF 文件里面保存的写命令，就可以还原服务器关闭之前的数据库状态。</p><ol><li><p>创建一个不带网络连接的伪客户端（fake client）：因为 Redis 的命令只能在客户端上下文中执行，而载入 AOF 文件时所使用的命令直接来源于 AOF 文件而不是网络连接，所以服务器使用了一个没有网络连接的伪客户端来执行 AOF 文件保存的写命令，伪客户端执行命令的效果和带网络连接的客户端执行命令的效果完全一样。</p></li><li><p>从 AOF 文件中分析并读取出一条写命令。</p></li><li><p>使用伪客户端执行被读出的写命令。</p></li><li><p>一直执行步骤2和步骤3，直到 AOF 文件中的所有写命令都被处理完毕为止。</p></li></ol><p>当完成以上步骤之后，AOF 文件所保存的数据库状态就会被完整地还原出来</p><p><img src="/../img/redis-aof/aof2.png"></p><h3 id="4-AOF重写"><a href="#4-AOF重写" class="headerlink" title="4.AOF重写"></a>4.AOF重写</h3><p>因为 AOF 持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器运行时间的流逝，AOF 文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的 AOF 文件很可能对 Redis 服务器、甚至整个宿主计算机造成影响，并且 AOF 文件的体积越大，使用 AOF 文件来进行数据还原所需的时间就越长。</p><p>举个例子，如果客户端执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis&gt; RPUSH list <span class="hljs-string">&quot;A&quot;</span> <span class="hljs-string">&quot;B&quot;</span>          // [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>]<br>(<span class="hljs-built_in">integer</span>) 2<br>redis&gt; RPUSH list <span class="hljs-string">&quot;C&quot;</span>              // [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>]<br>(<span class="hljs-built_in">integer</span>) 3<br>redis&gt; RPUSH list <span class="hljs-string">&quot;D&quot;</span> <span class="hljs-string">&quot;E&quot;</span>          // [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>]<br>(<span class="hljs-built_in">integer</span>) 5<br>redis&gt; LPOP list                   // [<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>]<br><span class="hljs-string">&quot;A&quot;</span><br>redis&gt; LPOP list                   // [<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>]<br><span class="hljs-string">&quot;B&quot;</span><br>redis&gt; RPUSH list <span class="hljs-string">&quot;F&quot;</span> <span class="hljs-string">&quot;G&quot;</span>          // [<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-string">&quot;E&quot;</span>, <span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;G&quot;</span>]<br>(<span class="hljs-built_in">integer</span>) 5<br></code></pre></td></tr></table></figure><p>那么只是为了记录这个 list 键的状态，AOF 文件就需要保存六条命令。</p><p>对于实际的应用来说，写命令执行的次数和频率会比上面的简单示例要高得多，所以造成的问题也严重得多。</p><p>为了解决 AOF 文件体积膨胀的问题，Redis 提供了 AOF 文件重写（rewirte）功能。通过该功能，Redis 服务器可以创建一个新的 AOF 文件，新旧两个 AOF 文件所保存的数据库状态相同，但新 AOF 文件不会包含任何浪费空间的冗余命令，所以新 AOF 文件的体积通常会比旧 AOF 文件的体积小很多。</p><h4 id="AOF-文件重写的实现"><a href="#AOF-文件重写的实现" class="headerlink" title="AOF 文件重写的实现"></a>AOF 文件重写的实现</h4><p>虽然 Redis 将生成新 AOF 文件替换旧 AOF 文件的功能命名为 “AOF 重写”，但实际上，AOF 文件重写并不需要对现有的 AOF 文件进行任何读取、分析或者写入操作，这个功能是通过读取服务器当前的数据库状态来实现的。</p><blockquote><p>例如上面的 list 的例子，服务器为了保存 list 键的状态，必须在 AOF 文件中写入六条命令。如果服务器想要尽量少的命令记录 list 键的状态，那么最简单高效的办法不是去读取和分析现有 AOF 文件的内容，而是直接从数据库中读取键 list 的值，然后用一条 RPUSH list “C” “D” “E” “F” “G” 命令来代替保存在 AOF 文件中的六条命令，这样就可以保存 list 键所需的命令从六条减少为一条了。</p></blockquote><blockquote><p>再举例，如果服务器对 animals 键执行了一下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis&gt; SADD animals <span class="hljs-string">&quot;Cat&quot;</span>                  // &#123;<span class="hljs-string">&quot;Cat&quot;</span>&#125;<br>(<span class="hljs-built_in">integer</span>) 1<br>redis&gt; SADD animals <span class="hljs-string">&quot;Dog&quot;</span> <span class="hljs-string">&quot;Panda&quot;</span> <span class="hljs-string">&quot;Tiger&quot;</span> // &#123;<span class="hljs-string">&quot;Cat&quot;</span>, <span class="hljs-string">&quot;Dog&quot;</span>, <span class="hljs-string">&quot;Panda&quot;</span>, <span class="hljs-string">&quot;Tiger&quot;</span>&#125;<br>(<span class="hljs-built_in">integer</span>) 3<br>redis&gt; SREM animals <span class="hljs-string">&quot;Cat&quot;</span>                 // &#123;<span class="hljs-string">&quot;Dog&quot;</span>, <span class="hljs-string">&quot;Panda&quot;</span>, <span class="hljs-string">&quot;Tiger&quot;</span>&#125;<br>(<span class="hljs-built_in">integer</span>) 1<br>redis&gt; SADD animals <span class="hljs-string">&quot;Lion&quot;</span> <span class="hljs-string">&quot;Cat&quot;</span>          // &#123;<span class="hljs-string">&quot;Dog&quot;</span>, <span class="hljs-string">&quot;Panda&quot;</span>, <span class="hljs-string">&quot;Tiger&quot;</span>, <span class="hljs-string">&quot;Lion&quot;</span>, <span class="hljs-string">&quot;Cat&quot;</span>&#125;<br>(<span class="hljs-built_in">integer</span>) 2                                    <br></code></pre></td></tr></table></figure><p>那么为了记录 animals 键的状态，AOF 文件必须保存上面列出的四条命令。</p><p>如果服务器想减少保存 animals 键所需命令的数量，那么服务器可以通过读取 animals 键的值，然后用一条 SADD animals “Dog” “Panda” “Tiger” “Lion” “Cat” 命令来代替上面的四条命令，这样就将保存 animals 键所需的命令从四条减少为一条了。</p></blockquote><p>除了上面列举的列表键和集合键之外，其他所有类型的键都可以用同样的方法去减少 AOF 文件中的命令数量。<strong>首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，这就是AOF重写功能的实现原理</strong>。 </p><p><strong>因为 aof_rewrite 函数生成的新 AOF 文件只包含还原当前数据库状态所必须的命令，所以新 AOF 文件不会浪费任何硬盘空间</strong>。</p><blockquote><p>注意：</p><p>在实际中，为了避免在执行命令是造成客户端输入缓冲区溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，会先检查所包含的元素数量，如果元素数量超过了 redis.h&#x2F;REDIS_AOF_REWRITE_ITEMS_PRE_CMD 常量的值，那么重写程序将使用多条命令来记录键的值，而不单单使用一条命令。</p><p>在目前版本中，REDIS_AOF_REWRITE_ITEMS_PRE_CMD 常量的值是64，也就是说，如果一个集合键包含了超过64个元素，那么重写程序会用多条 SADD 命令来记录这个集合，并且每条命令设置的元素数量也为64个。</p></blockquote><h4 id="AOF-后台重写"><a href="#AOF-后台重写" class="headerlink" title="AOF 后台重写"></a>AOF 后台重写</h4><p>上面介绍的 AOF 重写程序 aof_rewrite 函数可以很好的创建一个新 AOF 文件的任务，但是因为这个函数会进行大量的写入操作，所以调用这个函数的线程将被长时间阻塞，因为 Redis 服务器使用单个线程来处理命令请求，所以如果由服务器直接调用aof_rewrite 函数的话，那么在重写 AOF 文件期间，服务器将无法处理客户端发来的命令请求。</p><p>所以 Redis 决定将 AOF 重写程序放到子进程里执行，这样做可以同时达到两个目的：</p><p>1.子进程进行 AOF 重写期间，服务器（父进程）可以继续处理命令请求。</p><p>2.子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</p><p>但是，使用子进程也有一个问题需要解决，因为子进程在进行 AOF 重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的 AOF 文件所保存的数据库状态不一致。</p><p>为了解决数据不一致问题，Redis 服务器设置了一个 AOF 重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当 Redis 服务器执行完一个写命令之后，它会同时将这个写命令发送给 AOF 缓冲区和 AOF 重写缓冲区，如图所示。</p><p><img src="/../img/redis-aof/aof3.png"></p><p>这样在子进程重写AOF时，主进程会执行以下工作：</p><p>（1）执行客户端发来的命令。</p><p>（2）将执行后的写命令追加到AOF缓冲区。AOF缓冲区的内容会定期被写入和同步到AOF文件，对现有AOF 文件的处理工作会如常进行。</p><p>（3）将执行后的写命令追加到AOF重写缓冲区。从创建子进程开始，服务器执行的所有写命令都会被记录到AOF 重写缓冲区里面。</p><p>这样一来可以保证：</p><ul><li>AOF 缓冲区的内容会定期被写入和同步到 AOF 文件，对现有 AOF 文件的处理工作会如常进行。</li><li>从创建子进程开始，服务器执行的所有写命令都会被记录到 AOF 重写缓冲区里面。</li></ul><p>当子进程完成 AOF 重写工作之后，它会向父进程发送一个信号，父进程在接到该信号后，会调用一个信号处理函数，并执行一下工作：</p><ol><li><p>将 AOF 重写缓冲区中的所有内容写入到新 AOF 文件中，这是新的 AOF 文件所保存的数据库状态将和服务器当前的数据库状态一致。</p></li><li><p>对新的 AOF 文件进行改名，原子地（atomic）覆盖现有的 AOF 文件，完成新旧两个 AOF 文件的替换。</p></li></ol><p>这个信号处理函数执行完毕之后，父进程就可以继续像往常一样接受命令请求了。</p><p><strong>在整个 AOF 后台重写过程中，只有信号处理函数执行时会对服务器进程（父进程）造成阻塞，在其他时候，AOF 后台重写不会阻塞父进程</strong>，这将 AOF 重写对服务器性能造成的影响降到了最低。</p><p>以上就是 AOF 后台重写，也即是 BGREWRITEAOF命令的实现原理。</p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis持久化之RDB</title>
    <link href="/2023/05/10/redis-rdb/"/>
    <url>/2023/05/10/redis-rdb/</url>
    
    <content type="html"><![CDATA[<h1 id="redis持久化-RDB"><a href="#redis持久化-RDB" class="headerlink" title="redis持久化-RDB"></a>redis持久化-RDB</h1><p>RDB是Redis用来进行持久化的一种方式，是把当前内存中的数据集快照写入磁盘，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里。</p><h2 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h2><p>RDB 有两种触发方式，分别是自动触发和手动触发。</p><h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><p>在 redis.conf 配置文件中</p><p><strong>save：</strong>这里是用来配置触发 Redis的 RDB 持久化条件，也就是什么时候将内存中的数据保存到硬盘。比如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>：表示<span class="hljs-number">900</span> 秒内如果至少有 <span class="hljs-number">1</span> 个 key 的值变化，则保存<br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span>：表示<span class="hljs-number">300</span> 秒内如果至少有 <span class="hljs-number">10</span> 个 key 的值变化，则保存<br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span>：表示<span class="hljs-number">60</span> 秒内如果至少有 <span class="hljs-number">10000</span> 个 key 的值变化，则保存<br></code></pre></td></tr></table></figure><p>当然如果你只是用Redis的缓存功能，不需要持久化，那么你可以注释掉所有的 save 行来停用保存功能。可以直接一个空字符串来实现停用：save “”</p><p><strong>stop-writes-on-bgsave-error ：</strong>默认值为yes。当启用了RDB且最后一次后台保存数据失败，Redis是否停止接收数据。这会让用户意识到数据没有正确持久化到磁盘上，否则没有人会注意到灾难（disaster）发生了。如果Redis重启了，那么又可以重新开始接收数据了</p><p><strong>rdbcompression ；</strong>默认值是yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能，但是存储在磁盘上的快照会比较大。</p><p><strong>rdbchecksum ：</strong>默认值是yes。在存储快照后，我们还可以让redis使用CRC64算法来进行数据校验，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</p><p><strong>dbfilename ：</strong>设置快照的文件名，默认是 dump.rdb</p><p><strong>dir：</strong>设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。默认是和当前配置文件保存在同一目录。</p><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>手动触发Redis进行RDB持久化的命令有两种：</p><p>　　1、save</p><p>　　该命令会阻塞当前Redis服务器，执行save命令期间，Redis不能处理其他命令，直到RDB过程完成为止。</p><p>　　显然该命令对于内存比较大的实例会造成长时间阻塞，这是致命的缺陷，为了解决此问题，Redis提供了第二种方式。</p><p>　　2、bgsave</p><p>　　执行该命令时，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。</p><p>　　<strong>基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令。</strong></p><p>　　<strong>ps:执行执行 flushall 命令，也会产生dump.rdb文件，但里面是空的，无意义</strong></p><h2 id="RDB执行流程"><a href="#RDB执行流程" class="headerlink" title="RDB执行流程"></a>RDB执行流程</h2><h3 id="全量快照"><a href="#全量快照" class="headerlink" title="全量快照"></a>全量快照</h3><p>Redis中的RDB持久化方式，采用了写时复制技术（copy on write）和fork子进程。</p><p><img src="/../img/redis-rdb/rdb1.png" alt="rdb-bgsave工作流程"></p><p>快照开始时，主线程会fork出一个用于快照操作的子线程，并且复制一份数据对应的映射页表给子线程。子线程可以通过这个页表访问主线程的原始数据，然后将数据生成快照文件，存储到磁盘中。我们知道存储磁盘的时间是比较长的，当这个时候有请求进行想写数据怎么办呢？</p><p>这个时候就要用到 写时复制，即当请求需要对键值C进行操作时，主线程会把新数据或修改后的数据写到一个新的物理内存地址上（键值对C’），并修改主线程自己的页表映射。所以，子进程读到的类似于原始数据的一个副本，而主线程也可以正常进行修改。</p><p>这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。</p><h3 id="增量快照"><a href="#增量快照" class="headerlink" title="增量快照"></a>增量快照</h3><p>如果一直使用全量同步，一方面时间的推移，磁盘存储的快照文件会越来越多。另一方面如果频繁的进行全量同步，则需要主线线程频繁的fork出bgsvae线程，这样对Redis的性能是会产生影响的，并且也需要持续的对磁盘进行写操作。</p><p> 这个时候，我们可以采用另一只同步方式：增量快照。所谓增量快照，就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。在第一次做完全量快照后，T1 和 T2 时刻如果再做快照，我们只需要将被修改的数据写入快照文件就行。但是，这么做的前提是，我们需要记住哪些数据被修改了。你可不要小瞧这个“记住”功能，它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。如下图所示：</p><p><img src="/../img/redis-rdb/rdb2.png"></p><p>如果我们对每一个键值对的修改，都做个记录，那么，如果有 1 万个被修改的键值对，我们就需要有 1 万条额外的记录。而且，有的时候，键值对非常小，比如只有 32 字节，而记录它被修改的元数据信息，可能就需要 8 字节，这样的画，为了“记住”修改，引入的额外空间开销比较大。这对于内存资源宝贵的 Redis 来说，有些得不偿失。</p><p>所以说，全量快照和增量快照都有各自的优点和缺点，至于实际应用时，则要根据具体情况进行权衡。</p><h2 id="RDB-的优势和劣势"><a href="#RDB-的优势和劣势" class="headerlink" title="RDB 的优势和劣势"></a>RDB 的优势和劣势</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>1.RDB是一个非常紧凑(compact)的文件，它保存了redis 在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。</p><p>2.生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</p><p>3.RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><p>1、RDB方式数据没办法做到实时持久化&#x2F;秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作(内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑)，频繁执行成本过高(影响性能)</p><p>2、RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题(版本不兼容)</p><p>3、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改(数据有丢失)</p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode代码块无法自动补全</title>
    <link href="/2023/05/04/vscode-code-snippet/"/>
    <url>/2023/05/04/vscode-code-snippet/</url>
    
    <content type="html"><![CDATA[<h1 id="VSCode代码块无法自动补全"><a href="#VSCode代码块无法自动补全" class="headerlink" title="VSCode代码块无法自动补全"></a>VSCode代码块无法自动补全</h1><p><strong>触发条件</strong>：第一次使用代码补全功能，且光标落在了自动补全的默认区域形成了灰色背景区域</p><p><strong>触发现象</strong>：连续（第二次）自动补充和基本的代码提示功能失效</p><p><strong>恢复措施</strong>：光标离开默认区域，将编码状态重置为第一次自动补充，而非第二次自动补充（连续自动补充）</p><p>从前面的3点中可以看出，这个现象和代码补充、代码片段有关系</p><p>Code snippet (代码片段)在vscode中指的是基于IDE支持的利用快捷方式快速输入一小段，或者称之为一整块代码的功能，在日常编程，特别是在工作中写内容相似的业务代码时，利用snippet功能，可以极大加快编程效率</p><p>关键词snippet，在setting中搜索后的结果就是这样，可以看到整体分为，文本编辑器和扩展，其实就可以理解为vscode 自带的、通用的和自己下载的第三方插件，我们就着重看下文本编辑器里面的。可以看到第三个设置控制活动代码段是否阻止快速建议，这里是阻止了活动代码的快速建议。</p><p><img src="/../img/vscode-snippet/snippet-setting.png" alt="setting"></p><p>我们将√取消掉，再次尝试，发现一切就正常了</p>]]></content>
    
    
    <categories>
      
      <category>开发工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tips</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP三次握手四次挥手</title>
    <link href="/2023/05/03/establish-http-connection/"/>
    <url>/2023/05/03/establish-http-connection/</url>
    
    <content type="html"><![CDATA[<h1 id="通俗易懂地描述HTTP三次握手四次挥手"><a href="#通俗易懂地描述HTTP三次握手四次挥手" class="headerlink" title="通俗易懂地描述HTTP三次握手四次挥手"></a>通俗易懂地描述HTTP三次握手四次挥手</h1><h2 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h2><p>​超文本传输协议（英文：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。</p><p>​HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。</p><p>​2014年12月，互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组将HTTP&#x2F;2标准提议递交至IESG进行讨论，于2015年2月17日被批准。 HTTP&#x2F;2标准于2015年5月以RFC 7540正式发表，取代HTTP 1.1成为HTTP的实现标准。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>HTTP 是基于TCP的，建立一个HTTP连接本质上就是建立一个TCP连接，TCP连接是全双工的，全双工的连接意味着客户端可以向服务端发送数据，服务端也可以向客户端发送数据。为了方便理解，我们可以把建立TCP连接看作在客户端与服务端之间建立两个通道，一个用于客户端给服务端发送数据（socketChannel），一个用于服务端给客户端发送数据(serverSocketChannel)。</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="/../img/http1.png" alt="三次握手"></p><h4 id="三次握手流程："><a href="#三次握手流程：" class="headerlink" title="三次握手流程："></a>三次握手流程：</h4><p>第一次握手：建立连接时，客户端发送syn包（syn&#x3D;x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。<br>第二次握手：服务器收到syn包，必须确认客户的SYN（ack&#x3D;x+1），同时自己也发送一个SYN包（syn&#x3D;y），即SYN+ACK包，此时服务器进入SYN_RECV状态；<br>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p><p>上述流程可理解为：</p><p>1.客户端向服务端发送建立通道(socketChannel)的请求</p><p>2.服务端同意客户端的请求，此时建立客户端向服务端发送数据的通道(socketChannel)</p><p>3.服务端发送确认连接的消息，同时携带服务端请求建立通道（serverSocketChannel）的请求</p><p>4.客户端收到服务端建立完毕（socketChannel）的确认消息，并同意建立（serverSocketChannel）</p><p>5.客户端发送建立（serverSocketChannel）的确认信息</p><p>6.服务端收到确认信息，此时双方连接建立</p><h4 id="为什么连接建立需要三次握手，而不是两次握手？"><a href="#为什么连接建立需要三次握手，而不是两次握手？" class="headerlink" title="为什么连接建立需要三次握手，而不是两次握手？"></a><strong>为什么连接建立需要三次握手，而不是两次握手？</strong></h4><p>防止失效的连接请求报文段被服务端接收，从而产生错误。</p><p>PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。</p><p>若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。</p><p>此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求，如果服务端正确接收并确认应答，双方便开始通信，通信结束后释放连接。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端早已进入CLOSED状态，服务端将会一直等待下去，这样浪费服务端连接资源。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="/../img/http2.png" alt="四次挥手"></p><h3 id="四次挥手的流程："><a href="#四次挥手的流程：" class="headerlink" title="四次挥手的流程："></a>四次挥手的流程：</h3><p>1.客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p><p>2.服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。<br>3.客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p><p>4.服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p><p>5.客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p><p>6.服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p><p>上述流程可理解为：</p><p>1.客户端发送关闭（socketChannel）的请求</p><p>2.服务端确认关闭（socketChannel）并发送确认信息</p><p>3.客户端接收到确认信息，并等待服务端发送关闭（serverSocketChannel的信息）</p><p>Q：为什么服务端不直接将关闭（serverSocketChannel）的请求连同确认信息一同发送呢？</p><p>A：关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接。（socketChannel关闭了，但是服务端还有数据要发送，不能直接关闭serverSocketChannel，要继续通过它发送剩余数据）。</p><p>4.服务端数据发送完毕，发送关闭（serverSocketChannel）的请求</p><p>5.客户端收到请求关闭（serverSocketChannel），并发送确认信息</p><p>6.服务端收到确认信息，此时双方连接关闭</p><h3 id="为什么需要四次挥手？"><a href="#为什么需要四次挥手？" class="headerlink" title="为什么需要四次挥手？"></a><strong>为什么需要四次挥手？</strong></h3><p>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。</p><p>服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接。 从上⾯过程可知，TCP 是全双工模式，并且支持半关闭特性，提供了连接的一端在结束发送后还能接收来自另一端数据的能力。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><p>通俗的来说，两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MinIO 介绍使用</title>
    <link href="/2023/05/02/MinIo/"/>
    <url>/2023/05/02/MinIo/</url>
    
    <content type="html"><![CDATA[<h1 id="MinIO-介绍使用"><a href="#MinIO-介绍使用" class="headerlink" title="MinIO 介绍使用"></a>MinIO 介绍使用</h1><h1 id="MinIO-介绍"><a href="#MinIO-介绍" class="headerlink" title="MinIO 介绍"></a>MinIO 介绍</h1><p>MinIO 是一款基于Go语言发开的高性能、分布式的对象存储系统。客户端支持Java,Net,Python,Javacript, Golang语言。</p><p><a href="https://docs.min.io/">MinIO 英文官网</a> <a href="http://docs.minio.org.cn/docs/">MinIO 中文官网</a> 注意：中文官方更新不及时，会有很多坑，请以英文官网为准。</p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>1、Object：存储到minio的基本对象，如文件，字节流，Anything。。。。</p><p>2、Bucket：用来存储Object的逻辑空间。每个Bucket之间的数据是互相隔离的。对于客户端而言，就相当于存放文件的顶层文件夹。</p><p>3、Drlve：存储数据的磁盘，在MinIO启动时，以参数的方式传入。MinIO中所有的对象数据都会存在Drive里。</p><p>4、Set：即一组 Drive的集合，分布式部署根据集群规模自动划分一个或者多个Set，每个Set中的Drive 分布在不同位置。一个对象存储在一个Set上。</p><p>4.1、一个对象存储在一个Set上。</p><p>4.2、一个集群划分为多个Set。</p><p>4.3、一个Set包含的Drive数量是固定的，默认由系统根据集群规模自动计算得出。</p><p>4.4、一个Set中的drive 尽可能分布在不同的节点上。</p><p>5、纠删码：Minio 使用纠删码机制来保证高可靠性。</p><p>5.1、使用highwayhash来处理数据损坏（Bit Rot Protectio）。关于纠删码，简单来说就是可以通过数学计算，把丢失的数据进行还原。</p><p>5.2、纠删码是恢复丢失和算怀数据的数学算法，minio采用reed-solomincode将对象拆分成N&#x2F;2数据和N&#x2F;2奇偶校验块。这就意味着如果是12块盘，一个对象会被分成6个数据快、6个奇偶校验块，你可以丢失任意6块盘（不管其存放的是数据块还是奇偶校验块），你任可以从剩下的盘中的数据进行恢复。</p><p>5.2、纠删码模式，把数据分成 DATA BLOCk：数据块、 PARITY BLOCK：校验块。一个BLOCK 10M左右，如果一个文件小于10M，就以文件大小进行分块。如果一个文件大于10m，就以10M为一个文件单位进行分块。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>1、互联网非结构化数据的存储需求</p><p>​1.1 、电商网站：海量商品图片</p><p>2.1、视频网站：海量视频文件</p><p>3.1、网盘：海量文件</p><h2 id="MinIO优势"><a href="#MinIO优势" class="headerlink" title="MinIO优势"></a>MinIO优势</h2><p>1、数据保护</p><p>​1.1、分布式MInio采用纠删码来放反多个节点待机和位衰减 bit rot</p><p>​1.2、分布式Minio至少需要4个硬盘，使用分布式Minio自动引入了纠删码功能。</p><p>2、高可用</p><p>​2.1、单机Minio服务存在单点故障，相反，如果是有一个N快硬盘的分布式Minio，只要有N&#x2F;2硬盘在线，你的数据就是安全的。不过你需要至少有N&#x2F;2+1个硬盘来创建新的对象。</p><p>​2.2、例如，一个16节点的Minio集群，每个节点16块块硬盘，计算8台服务器宕机，这个集群仍然是可读的，不过你需要9台服务器才能写入数据。</p><p>3、一致性</p><p>​3.1、Minio在分布式和单机模式下，所有读写炒作都严格遵守read-after-write 一致性模型</p><h1 id="MinIO-使用"><a href="#MinIO-使用" class="headerlink" title="MinIO 使用"></a>MinIO 使用</h1><h2 id="使用【服务端】"><a href="#使用【服务端】" class="headerlink" title="使用【服务端】"></a>使用【服务端】</h2><h3 id="单机模式-（linux部署）"><a href="#单机模式-（linux部署）" class="headerlink" title="单机模式 （linux部署）"></a>单机模式 （linux部署）</h3><p>ps：初始用户名密码：minioadmin</p><p>1、下载linux minio， wget <a href="https://dl.min.io/server/minio/release/linux-amd64/minio">https://dl.min.io/server/minio/release/linux-amd64/minio</a></p><p>2、linux部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">修改用户名密码：<br>export MINIO_ROOT_USER=username<br>export MINIO_ROOT_PASSWORD=password<br><br>启动：<br>./minio server --console-address &quot;:9090&quot; /mnt/data<br><br>后台启动，指定日志路径：<br>nohup ./minio server --console-address :&quot;9090&quot; ./miniodata/data &gt;./miniodata/minio.log 2&gt;&amp;1 &amp;<br><br>ps：接口默认地址：9000<br>指定console端口：9090<br></code></pre></td></tr></table></figure><p>3、docker部署</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run \<br>  -p 9000:9000 \<br>  -p 9001:9001 \<br>  -e &quot;MINIO_ROOT_USER=AKIAIOSFODNN7EXAMPLE&quot; \<br>  -e &quot;MINIO_ROOT_PASSWORD=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY&quot; \<br>  quay.io/minio/minio server /data --console-address &quot;:9001&quot;<br></code></pre></td></tr></table></figure><p>4、docker部署纠删码模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 9000:9000 -p 9090:9090 --name minio \<br> -v /mnt/data1:/data1 \<br> -v /mnt/data2:/data2 \<br> -v /mnt/data3:/data3 \<br> -v /mnt/data4:/data4 \<br> -v /mnt/data5:/data5 \<br> -v /mnt/data6:/data6 \<br> -v /mnt/data7:/data7 \<br> -v /mnt/data8:/data8 \<br>minio/minio server /data&#123;1...8&#125; --console-address &quot;:9090&quot;<br></code></pre></td></tr></table></figure><p>5、缺点：单点故障，直接宕机</p><h3 id="分布式部署"><a href="#分布式部署" class="headerlink" title="分布式部署"></a>分布式部署</h3><p>注意事项：</p><p>1、linux部署：启动一个分布式Minio实例，你只需要把硬盘位置作为参数传给minio server命令即可，然后，你需要在所有其他节点运行同样的命令。</p><p>2、分布式Minio里所有的节点需要有同样的access秘钥和secret秘钥，这样这些节点才能建立连接。为了实现这个，你需要在执行minioserver命令前，先将access秘钥和secret秘钥expoert成环境变量。新版本使用MINIO_ROOT_USER&amp;MINIO_ROOTPASSWORD。</p><p>3、【举例1】8个节点，每个节点1块盘。启动分布式Minio实例，8个节点，每节点1块盘，需要再8个节点上都运行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export MINIO_ROOT_USER=admin<br>export MINIO_ROOT_PASSWORD=123456<br></code></pre></td></tr></table></figure><p>【举例1.1】下面示例的IP仅供示例参考没需要改成你真实的IP地址和文件夹路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">minio server http://192.168.1.11/export1 \<br>http://192.168.1.12/export2 \<br>http://192.168.1.13/export3 \<br>http://192.168.1.14/export4 \<br>http://192.168.1.15/export5 \<br>http://192.168.1.16/export6 \<br>http://192.168.1.17/export7 \<br>http://192.168.1.18/export8 \<br></code></pre></td></tr></table></figure><p>【举例2】4个节点，每个节点2块盘。启动分布式Minio实例，4个节点，每节点2块盘，需要再4个节点上都运行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export MINIO_ROOT_USER=admin<br>export MINIO_ROOT_PASSWORD=123456<br></code></pre></td></tr></table></figure><p>【举例2.1】下面示例的IP仅供示例参考没需要改成你真实的IP地址和文件夹路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">http://192.168.1.11/export1 \<br>http://192.168.1.11/export2 \<br>http://192.168.1.12/export1 \<br>http://192.168.1.12/export2 \<br>http://192.168.1.13/export1 \<br>http://192.168.1.13/export2 \<br>http://192.168.1.14/export1 \<br>http://192.168.1.14/export2 \<br></code></pre></td></tr></table></figure><p> 5、统一入口：使用Nginx 统一入口，可以做ip hash策略分散服务器压力。</p><p>【例如 ：】</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> minio &#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.11:9001</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.12:9001</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.13:9001</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.14:9001</span>;<br>&#125;<br><br><span class="hljs-section">upstream</span> console &#123;<br>    ip_hash;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.11:5001</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.12:5002</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.13:5003</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.1.14:5004</span>;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>      <span class="hljs-number">9000</span>;<br>    <span class="hljs-attribute">listen</span> [::] <span class="hljs-number">9000</span>;<br>    <span class="hljs-attribute">server_name</span> localhost;<br>    <br>    <span class="hljs-attribute">localhost</span> / &#123;<br>    <br>        <span class="hljs-attribute">proxy_pass</span> http://minio;<br>    &#125;<br>&#125;<br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>      <span class="hljs-number">5000</span>;<br>    <span class="hljs-attribute">listen</span> [::] <span class="hljs-number">5000</span>;<br>    <span class="hljs-attribute">server_name</span> localhost;<br>    <br>    <span class="hljs-attribute">localhost</span> / &#123;<br>    <br>    <span class="hljs-attribute">proxy_pass</span> http://console;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>6、<a href="https://docs.min.io/docs/deploy-minio-on-docker-compose.html">docker-compose部署</a></p><h2 id="使用【客户端】"><a href="#使用【客户端】" class="headerlink" title="使用【客户端】"></a>使用【客户端】</h2><p>介绍：MinIO Clinet(mc) 为ls,cat，cp，mirror，diff,find 等UNIX命令提供一种替代方案。它支持文件系统和兼容Amazon S3的云存储服务（AWS Signature v2和v4）。</p><h3 id="Windows-部署"><a href="#Windows-部署" class="headerlink" title="Windows 部署"></a>Windows 部署</h3><p>ps:注意9001 是接口端口，不是console端口。</p><p>1、下载 </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//</span>dl.min.io<span class="hljs-regexp">/client/m</span>c<span class="hljs-regexp">/release/</span>linux-amd64/mc <br></code></pre></td></tr></table></figure><p>2、赋予权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x mc<br>./mc --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p>3、查询mc host配置</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mc config host ls<br></code></pre></td></tr></table></figure><p>　　4、 添加minio服务</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mc config host add minio-server http:<span class="hljs-comment">//81.70.144.153:9001/</span><br>minioadmin minioadmin<br></code></pre></td></tr></table></figure><p>　　5、 mc命令【管理文件】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 加入配置文件：</span><br>mc config host add minio01 http://81.70.144.153:9000 minioadmin minioadmin<br><br><span class="hljs-comment"># 连接查看minio文件内容：</span><br>mc <span class="hljs-built_in">ls</span> tuling minio01<br><br><span class="hljs-comment"># 下载文件</span><br>mc <span class="hljs-built_in">cp</span> minio01/yeb/数据结构算法面试题.txt D:\<br><br><span class="hljs-comment"># 上传文件</span><br>mc <span class="hljs-built_in">cp</span> D:\测试.txt minio01/yeb<br><br><span class="hljs-comment"># 删除文件</span><br>mc <span class="hljs-built_in">rm</span> minio01/yeb/测试.txt<br></code></pre></td></tr></table></figure><p>6、mc命令【管理桶（Bucket）】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建bucket</span><br>mc mb minio01/yeb1<br><br><span class="hljs-comment"># 删除bucket(有数据删除失败)</span><br>mc rb minio01/yeb1<br><br><span class="hljs-comment"># bucket不为空，强制删除，慎用</span><br>mc rb --force minio01/yeb1<br><br><span class="hljs-comment"># 查看bucket磁盘使用情况</span><br>mc <span class="hljs-built_in">du</span> minio01/yeb<br></code></pre></td></tr></table></figure><p>7、mc命令【admin使用】</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Minio<span class="hljs-built_in"> Client </span>提供了‘admin’子命令来对minio部署执行管理任务<br><span class="hljs-built_in"></span><br><span class="hljs-built_in">service </span>服务器停止并且重启所有Minio服务器<br>udpate 更新所有MInio服务器<br><span class="hljs-built_in">info</span> 显示minio服务器信息<span class="hljs-built_in"></span><br><span class="hljs-built_in">user </span>管理用户<span class="hljs-built_in"></span><br><span class="hljs-built_in">group </span>管理小组<span class="hljs-built_in"></span><br><span class="hljs-built_in">policy </span>minio服务器中定义策略管理<br>cofnig 配置管理minio服务器<br>heal 修复minio服务器上的磁盘、桶、对象<span class="hljs-built_in"></span><br><span class="hljs-built_in">profile </span>生成概要文件数据进行调试<br>top 顶部提供minio统计信息<br>trace 跟踪显示minio服务器的http跟踪<span class="hljs-built_in"></span><br><span class="hljs-built_in">console </span>控制台显示minio服务器的控制台日志<br>prometheus prometheys配置<br>kms kms管理操作<br></code></pre></td></tr></table></figure><h2 id="官方-Java-demo使用"><a href="#官方-Java-demo使用" class="headerlink" title="官方 Java demo使用"></a><a href="https://github.com/minio/minio-java">官方 Java demo使用</a></h2><h3 id="附：content-type-与后缀名对应"><a href="#附：content-type-与后缀名对应" class="headerlink" title="附：content-type 与后缀名对应"></a>附：content-type 与后缀名对应</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;.*&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/octet-stream&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.001&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-001&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.301&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-301&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.323&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/h323&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.906&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-906&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.907&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;drawing/907&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.a11&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-a11&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.acp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/x-mei-aac&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ai&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/postscript&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.aif&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/aiff&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.aifc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/aiff&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.aiff&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/aiff&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.anv&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-anv&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.asa&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/asa&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.asf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/x-ms-asf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.asp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/asp&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.asx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/x-ms-asf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.au&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/basic&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.avi&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/avi&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.awf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.adobe.workflow&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.biz&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.bmp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-bmp&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.bot&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-bot&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.c4t&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-c4t&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.c90&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-c90&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.cal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-cals&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.cat&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/s-pki.seccat&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.cdf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-netcdf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.cdr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-cdr&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.cel&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-cel&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.cer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-x509-ca-cert&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.cg4&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-g4&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.cgm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-cgm&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.cit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-cit&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.class&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java/*&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.cml&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.cmp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-cmp&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.cmx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-cmx&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.cot&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-cot&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.crl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/pkix-crl&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.crt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-x509-ca-cert&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.csi&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-csi&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.css&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/css&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.cut&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-cut&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.dbf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-dbf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.dbm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-dbm&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.dbx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-dbx&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.dcd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.dcx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-dcx&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.der&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-x509-ca-cert&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.dgn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-dgn&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.dib&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-dib&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.dll&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-msdownload&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.doc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/msword&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.dot&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/msword&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.drw&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-drw&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.dtd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.dwf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Model/vnd.dwf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.dwg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-dwg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.dxb&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-dxb&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.dxf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-dxf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.edn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.adobe.edn&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.emf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-emf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.eml&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;message/rfc822&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.epi&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-epi&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.eps&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-ps&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.etd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-ebx&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.exe&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-msdownload&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.fax&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;image/fax&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.fdf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.fdf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.fif&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/fractals&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.fo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.frm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-frm&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.g4&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-g4&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.gbr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-gbr&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.gcd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-gcd&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.gif&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;image/gif&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.gl2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-gl2&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.gp4&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-gp4&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.hgl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-hgl&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.hmr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-hmr&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.hpg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-hpgl&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.hpl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-hpl&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.hqx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/mac-binhex40&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.hrf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-hrf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.hta&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/hta&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.htc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/x-component&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.htm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/html&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.html&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/html&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.htt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/webviewhtml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.htx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/html&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.icb&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-icb&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ico&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;image/x-icon&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.iff&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-iff&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ig4&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-g4&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.igs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-igs&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.iii&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-iphone&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.img&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-img&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-internet-signup&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.isp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-internet-signup&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.IVF&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/x-ivf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.java&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;java/*&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.jfif&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;image/jpeg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.jpe&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;image/jpeg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.jpeg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;image/jpeg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.jpg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;image/jpeg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.js&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-javascript&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.jsp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/html&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.la1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/x-liquid-file&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.lar&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-laplayer-reg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.latex&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-latex&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.lavs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/x-liquid-secure&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.lbm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-lbm&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.lmsff&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/x-la-lms&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ls&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-javascript&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ltr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-ltr&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.m1v&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/x-mpeg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.m2v&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/x-mpeg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.m3u&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/mpegurl&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.m4e&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/mpeg4&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mac&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-mac&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.man&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-troff-man&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.math&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mdb&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-mdb&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mfp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-shockwave-flash&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mht&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;message/rfc822&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mhtml&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;message/rfc822&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mi&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-mi&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/mid&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.midi&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/mid&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mil&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-mil&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mml&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mnd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/x-musicnet-download&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/x-musicnet-stream&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mocha&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-javascript&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.movie&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/x-sgi-movie&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mp1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/mp1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mp2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/mp2&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mp2v&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/mpeg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mp3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/mp3&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mp4&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/mp4&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mpa&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/x-mpg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mpd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/-project&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mpe&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/x-mpeg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mpeg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/mpg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mpg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/mpg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mpga&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/rn-mpeg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mpp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/-project&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mps&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/x-mpeg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mpt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/-project&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mpv&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/mpg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mpv2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/mpeg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mpw&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/s-project&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mpx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/-project&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mtx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.mxp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-mmxp&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.net&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;image/pnetvue&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.nrf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-nrf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.nws&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;message/rfc822&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.odc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/x-ms-odc&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.out&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-out&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.p10&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/pkcs10&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.p12&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-pkcs12&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.p7b&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-pkcs7-certificates&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.p7c&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/pkcs7-mime&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.p7m&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/pkcs7-mime&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.p7r&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-pkcs7-certreqresp&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.p7s&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/pkcs7-signature&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.pc5&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-pc5&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.pci&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-pci&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.pcl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-pcl&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.pcx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-pcx&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.pdf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/pdf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.pdx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.adobe.pdx&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.pfx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-pkcs12&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.pgl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-pgl&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.pic&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-pic&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.pko&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application-pki.pko&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.pl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-perl&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.plg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/html&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.pls&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/scpls&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.plt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-plt&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.png&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;image/png&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.pot&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;applications-powerpoint&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ppa&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vs-powerpoint&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ppm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-ppm&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.pps&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application-powerpoint&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ppt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;applications-powerpoint&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.pr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-pr&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.prf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/pics-rules&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.prn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-prn&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.prt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-prt&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ps&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/postscript&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ptn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-ptn&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.pwz&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/powerpoint&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.r3t&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/vnd.rn-realtext3d&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ra&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/vnd.rn-realaudio&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ram&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/x-pn-realaudio&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ras&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-ras&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rat&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/rat-file&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rdf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rec&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.rn-recording&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.red&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-red&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rgb&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-rgb&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rjs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.rn-realsystem-rjs&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rjt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.rn-realsystem-rjt&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rlc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-rlc&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-rle&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.rn-realmedia&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rmf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.adobe.rmf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rmi&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/mid&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rmj&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.rn-realsystem-rmj&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rmm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/x-pn-realaudio&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rmp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.rn-rn_music_package&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rms&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.rn-realmedia-secure&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rmvb&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.rn-realmedia-vbr&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rmx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.rn-realsystem-rmx&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rnx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.rn-realplayer&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;image/vnd.rn-realpix&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rpm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/x-pn-realaudio-plugin&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rsml&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.rn-rsml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/vnd.rn-realtext&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rtf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-rtf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.rv&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/vnd.rn-realvideo&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.sam&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-sam&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.sat&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-sat&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.sdp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/sdp&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.sdw&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-sdw&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.sit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-stuffit&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.slb&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-slb&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.sld&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-sld&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.slk&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;drawing/x-slk&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.smi&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/smil&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.smil&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/smil&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.smk&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-smk&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.snd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/basic&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.sol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/plain&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.sor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/plain&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.spc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-pkcs7-certificates&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.spl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/futuresplash&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.spp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ssm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/streamingmedia&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.sst&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application-pki.certstore&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.stl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/-pki.stl&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.stm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/html&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.sty&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-sty&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.svg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.swf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-shockwave-flash&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.tdf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-tdf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.tg4&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-tg4&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.tga&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-tga&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.tif&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;image/tiff&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.tiff&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;image/tiff&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.tld&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.top&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;drawing/x-top&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.torrent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-bittorrent&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.tsd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.txt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/plain&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.uin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-icq&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.uls&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/iuls&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.vcf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/x-vcard&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.vda&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-vda&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.vdx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.visio&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.vml&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.vpg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-vpeg005&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.vsd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-vsd&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.vss&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.visio&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.vst&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-vst&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.vsw&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.visio&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.vsx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.visio&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.vtx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.visio&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.vxml&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wav&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/wav&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wax&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/x-ms-wax&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wb1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-wb1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wb2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-wb2&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wb3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-wb3&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wbmp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;image/vnd.wap.wbmp&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wiz&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/msword&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wk3&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-wk3&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wk4&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-wk4&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wkq&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-wkq&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-wks&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/x-ms-wm&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wma&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/x-ms-wma&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wmd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-ms-wmd&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wmf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-wmf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wml&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/vnd.wap.wml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wmv&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/x-ms-wmv&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wmx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/x-ms-wmx&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wmz&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-ms-wmz&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wp6&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-wp6&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wpd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-wpd&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wpg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-wpg&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wpl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/-wpl&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wq1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-wq1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wr1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-wr1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-wri&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wrk&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-wrk&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ws&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-ws&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.ws2&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-ws&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wsc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/scriptlet&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wsdl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.wvx&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;video/x-ms-wvx&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.xdp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.adobe.xdp&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.xdr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.xfd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.adobe.xfd&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.xfdf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/vnd.adobe.xfdf&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.xhtml&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/html&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.xls&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-xls&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.xlw&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-xlw&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.xml&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.xpl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;audio/scpls&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.xq&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.xql&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.xquery&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.xsd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.xsl&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.xslt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/xml&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.xwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-xwd&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.x_b&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-x_b&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;.x_t&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;application/x-x_t&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>原帖地址：<a href="https://www.cnblogs.com/lwqstyle/p/16587503.html">https://www.cnblogs.com/lwqstyle/p/16587503.html</a></p>]]></content>
    
    
    <categories>
      
      <category>MinIO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MinIo</tag>
      
      <tag>tips</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flutter常用插件</title>
    <link href="/2023/05/02/flutter-dependencies/"/>
    <url>/2023/05/02/flutter-dependencies/</url>
    
    <content type="html"><![CDATA[<h1 id="flutter开发中常用的插件"><a href="#flutter开发中常用的插件" class="headerlink" title="flutter开发中常用的插件"></a>flutter开发中常用的插件</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">get</span>    <span class="hljs-comment">#getx框架</span><br><span class="hljs-string">flutter_local_notifications</span>      <span class="hljs-comment">#本地通知</span><br><span class="hljs-string">email_validator</span>     <span class="hljs-comment">#邮箱验证，比较全面</span><br><span class="hljs-string">crypto</span>       <span class="hljs-comment"># 加密算法 SHA-1 、 SHA-224 、 SHA-256 、 SHA-384 、  SHA-512 、 SHA-512/224 、 SHA-512/256、 MD5 、HMAC (i.e. HMAC-MD5, HMAC-SHA1, HMAC-SHA256)</span><br><span class="hljs-string">event_bus</span>    <span class="hljs-comment"># 事件监听  类似于通知</span><br><span class="hljs-string">translator</span>    <span class="hljs-comment">#google翻译</span><br><span class="hljs-string">hive</span>    <span class="hljs-comment">#数据持久化存储</span><br><span class="hljs-string">shared_preferences</span>     <span class="hljs-comment">#数据持久化存储</span><br><span class="hljs-string">image_picker</span>    <span class="hljs-comment">#相册</span><br><span class="hljs-string">sticky_headers</span>   <span class="hljs-comment">#悬浮cell</span><br><span class="hljs-string">flutter_spinkit</span>    <span class="hljs-comment">#加载提示框</span><br><span class="hljs-string">flutter_sound</span>    <span class="hljs-comment">#音频 -》录音、播放</span><br><span class="hljs-string">audio_session</span>    <span class="hljs-comment">#音频硬件配置插件</span><br><span class="hljs-string">connectivity_plus</span>  <span class="hljs-comment">#网络监测</span><br><span class="hljs-string">dio</span>    <span class="hljs-comment">#网络请求库</span><br><span class="hljs-string">http</span>    <span class="hljs-comment">#网络请求库</span><br><span class="hljs-string">flutter_native_splash</span>    <span class="hljs-comment">#启动页</span><br><span class="hljs-string">flutter_picker</span>    <span class="hljs-comment">#时间选择</span><br><span class="hljs-string">flutter_screenutil</span>    <span class="hljs-comment">#屏幕适配</span><br><span class="hljs-string">flutter_easyloading</span>    <span class="hljs-comment">#加载进度框</span><br><span class="hljs-string">flutter_blue</span>    <span class="hljs-comment">#蓝牙</span><br><span class="hljs-string">date_format</span>    <span class="hljs-comment">#日期转换</span><br><span class="hljs-string">app_settings</span>    <span class="hljs-comment">#跳转到系统设置界面</span><br><span class="hljs-string">path_provider</span>    <span class="hljs-comment">#文件管理</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tips</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>负载均衡冲突</title>
    <link href="/2023/05/02/cloud-loadBalancerConflict/"/>
    <url>/2023/05/02/cloud-loadBalancerConflict/</url>
    
    <content type="html"><![CDATA[<h1 id="负载均衡冲突"><a href="#负载均衡冲突" class="headerlink" title="负载均衡冲突"></a>负载均衡冲突</h1><p>nacos使用ribbon负载均衡<br>而openfeign在新版中改用spring-cloud-loadbalancer<br>两者同时使用需要将nacos的ribbon排除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- nacos客户端依赖包 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/05/02/hello-world/"/>
    <url>/2023/05/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
